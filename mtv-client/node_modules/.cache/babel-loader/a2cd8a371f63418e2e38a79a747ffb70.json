{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"react-d3-library\", [], factory);else if (typeof exports === 'object') exports[\"react-d3-library\"] = factory();else root[\"react-d3-library\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      exports.Component = __webpack_require__(1);\n      exports.AreaChart = __webpack_require__(49);\n      exports.BarChart = __webpack_require__(52);\n      exports.LineChart = __webpack_require__(54);\n      exports.PieChart = __webpack_require__(56);\n      exports.ScatterPlot = __webpack_require__(58);\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _d3DataToJSX = __webpack_require__(33);\n\n      var _d3DataToJSX2 = _interopRequireDefault(_d3DataToJSX);\n\n      var _ChildComponent = __webpack_require__(39);\n\n      var _ChildComponent2 = _interopRequireDefault(_ChildComponent);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var _class = function (_React$Component) {\n        _inherits(_class, _React$Component);\n\n        function _class(props) {\n          _classCallCheck(this, _class);\n\n          var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));\n\n          _this.state = {\n            d3DOM: [],\n            state: []\n          };\n          return _this;\n        }\n\n        _createClass(_class, [{\n          key: 'componentWillReceiveProps',\n          value: function componentWillReceiveProps(nextProps) {\n            var d3Data = (0, _d3DataToJSX2.default)(nextProps.data);\n            this.setState({\n              d3DOM: d3Data.mappedData,\n              state: d3Data.state\n            });\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            return _react2.default.createElement('div', null, _react2.default.createElement(_ChildComponent2.default, {\n              data: this.state,\n              getState: this.getState\n            }));\n          }\n        }]);\n\n        return _class;\n      }(_react2.default.Component);\n\n      exports.default = _class;\n      ;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      module.exports = __webpack_require__(3);\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var _assign = __webpack_require__(5);\n\n        var ReactChildren = __webpack_require__(6);\n\n        var ReactComponent = __webpack_require__(19);\n\n        var ReactPureComponent = __webpack_require__(22);\n\n        var ReactClass = __webpack_require__(23);\n\n        var ReactDOMFactories = __webpack_require__(25);\n\n        var ReactElement = __webpack_require__(10);\n\n        var ReactPropTypes = __webpack_require__(30);\n\n        var ReactVersion = __webpack_require__(31);\n\n        var onlyChild = __webpack_require__(32);\n\n        var warning = __webpack_require__(12);\n\n        var createElement = ReactElement.createElement;\n        var createFactory = ReactElement.createFactory;\n        var cloneElement = ReactElement.cloneElement;\n\n        if (process.env.NODE_ENV !== 'production') {\n          var ReactElementValidator = __webpack_require__(26);\n\n          createElement = ReactElementValidator.createElement;\n          createFactory = ReactElementValidator.createFactory;\n          cloneElement = ReactElementValidator.cloneElement;\n        }\n\n        var __spread = _assign;\n\n        if (process.env.NODE_ENV !== 'production') {\n          var warned = false;\n\n          __spread = function () {\n            process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;\n            warned = true;\n            return _assign.apply(null, arguments);\n          };\n        }\n\n        var React = {\n          // Modern\n          Children: {\n            map: ReactChildren.map,\n            forEach: ReactChildren.forEach,\n            count: ReactChildren.count,\n            toArray: ReactChildren.toArray,\n            only: onlyChild\n          },\n          Component: ReactComponent,\n          PureComponent: ReactPureComponent,\n          createElement: createElement,\n          cloneElement: cloneElement,\n          isValidElement: ReactElement.isValidElement,\n          // Classic\n          PropTypes: ReactPropTypes,\n          createClass: ReactClass.createClass,\n          createFactory: createFactory,\n          createMixin: function (mixin) {\n            // Currently a noop. Will be used to validate and trace mixins.\n            return mixin;\n          },\n          // This looks DOM specific but these are actually isomorphic helpers\n          // since they are just generating DOM strings.\n          DOM: ReactDOMFactories,\n          version: ReactVersion,\n          // Deprecated hook for JSX spread, don't use this for anything.\n          __spread: __spread\n        };\n        module.exports = React;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n      /***/\n\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      /*\n      object-assign\n      (c) Sindre Sorhus\n      @license MIT\n      */\n      'use strict';\n      /* eslint-disable no-unused-vars */\n\n      var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n      function toObject(val) {\n        if (val === null || val === undefined) {\n          throw new TypeError('Object.assign cannot be called with null or undefined');\n        }\n\n        return Object(val);\n      }\n\n      function shouldUseNative() {\n        try {\n          if (!Object.assign) {\n            return false;\n          } // Detect buggy property enumeration order in older V8 versions.\n          // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\n\n          var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n\n          test1[5] = 'de';\n\n          if (Object.getOwnPropertyNames(test1)[0] === '5') {\n            return false;\n          } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n          var test2 = {};\n\n          for (var i = 0; i < 10; i++) {\n            test2['_' + String.fromCharCode(i)] = i;\n          }\n\n          var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n            return test2[n];\n          });\n\n          if (order2.join('') !== '0123456789') {\n            return false;\n          } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n          var test3 = {};\n          'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n            test3[letter] = letter;\n          });\n\n          if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n            return false;\n          }\n\n          return true;\n        } catch (err) {\n          // We don't expect any of the above to throw, but better to be safe.\n          return false;\n        }\n      }\n\n      module.exports = shouldUseNative() ? Object.assign : function (target, source) {\n        var from;\n        var to = toObject(target);\n        var symbols;\n\n        for (var s = 1; s < arguments.length; s++) {\n          from = Object(arguments[s]);\n\n          for (var key in from) {\n            if (hasOwnProperty.call(from, key)) {\n              to[key] = from[key];\n            }\n          }\n\n          if (getOwnPropertySymbols) {\n            symbols = getOwnPropertySymbols(from);\n\n            for (var i = 0; i < symbols.length; i++) {\n              if (propIsEnumerable.call(from, symbols[i])) {\n                to[symbols[i]] = from[symbols[i]];\n              }\n            }\n          }\n        }\n\n        return to;\n      };\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * Copyright 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       */\n      'use strict';\n\n      var PooledClass = __webpack_require__(7);\n\n      var ReactElement = __webpack_require__(10);\n\n      var emptyFunction = __webpack_require__(13);\n\n      var traverseAllChildren = __webpack_require__(16);\n\n      var twoArgumentPooler = PooledClass.twoArgumentPooler;\n      var fourArgumentPooler = PooledClass.fourArgumentPooler;\n      var userProvidedKeyEscapeRegex = /\\/+/g;\n\n      function escapeUserProvidedKey(text) {\n        return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n      }\n      /**\n       * PooledClass representing the bookkeeping associated with performing a child\n       * traversal. Allows avoiding binding callbacks.\n       *\n       * @constructor ForEachBookKeeping\n       * @param {!function} forEachFunction Function to perform traversal with.\n       * @param {?*} forEachContext Context to perform context with.\n       */\n\n\n      function ForEachBookKeeping(forEachFunction, forEachContext) {\n        this.func = forEachFunction;\n        this.context = forEachContext;\n        this.count = 0;\n      }\n\n      ForEachBookKeeping.prototype.destructor = function () {\n        this.func = null;\n        this.context = null;\n        this.count = 0;\n      };\n\n      PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);\n\n      function forEachSingleChild(bookKeeping, child, name) {\n        var func = bookKeeping.func,\n            context = bookKeeping.context;\n        func.call(context, child, bookKeeping.count++);\n      }\n      /**\n       * Iterates through children that are typically specified as `props.children`.\n       *\n       * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach\n       *\n       * The provided forEachFunc(child, index) will be called for each\n       * leaf child.\n       *\n       * @param {?*} children Children tree container.\n       * @param {function(*, int)} forEachFunc\n       * @param {*} forEachContext Context for forEachContext.\n       */\n\n\n      function forEachChildren(children, forEachFunc, forEachContext) {\n        if (children == null) {\n          return children;\n        }\n\n        var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);\n        traverseAllChildren(children, forEachSingleChild, traverseContext);\n        ForEachBookKeeping.release(traverseContext);\n      }\n      /**\n       * PooledClass representing the bookkeeping associated with performing a child\n       * mapping. Allows avoiding binding callbacks.\n       *\n       * @constructor MapBookKeeping\n       * @param {!*} mapResult Object containing the ordered map of results.\n       * @param {!function} mapFunction Function to perform mapping with.\n       * @param {?*} mapContext Context to perform mapping with.\n       */\n\n\n      function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {\n        this.result = mapResult;\n        this.keyPrefix = keyPrefix;\n        this.func = mapFunction;\n        this.context = mapContext;\n        this.count = 0;\n      }\n\n      MapBookKeeping.prototype.destructor = function () {\n        this.result = null;\n        this.keyPrefix = null;\n        this.func = null;\n        this.context = null;\n        this.count = 0;\n      };\n\n      PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);\n\n      function mapSingleChildIntoContext(bookKeeping, child, childKey) {\n        var result = bookKeeping.result,\n            keyPrefix = bookKeeping.keyPrefix,\n            func = bookKeeping.func,\n            context = bookKeeping.context;\n        var mappedChild = func.call(context, child, bookKeeping.count++);\n\n        if (Array.isArray(mappedChild)) {\n          mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n        } else if (mappedChild != null) {\n          if (ReactElement.isValidElement(mappedChild)) {\n            mappedChild = ReactElement.cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n          }\n\n          result.push(mappedChild);\n        }\n      }\n\n      function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n        var escapedPrefix = '';\n\n        if (prefix != null) {\n          escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n        }\n\n        var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);\n        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n        MapBookKeeping.release(traverseContext);\n      }\n      /**\n       * Maps children that are typically specified as `props.children`.\n       *\n       * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map\n       *\n       * The provided mapFunction(child, key, index) will be called for each\n       * leaf child.\n       *\n       * @param {?*} children Children tree container.\n       * @param {function(*, int)} func The map function.\n       * @param {*} context Context for mapFunction.\n       * @return {object} Object containing the ordered map of results.\n       */\n\n\n      function mapChildren(children, func, context) {\n        if (children == null) {\n          return children;\n        }\n\n        var result = [];\n        mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n        return result;\n      }\n\n      function forEachSingleChildDummy(traverseContext, child, name) {\n        return null;\n      }\n      /**\n       * Count the number of children that are typically specified as\n       * `props.children`.\n       *\n       * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count\n       *\n       * @param {?*} children Children tree container.\n       * @return {number} The number of children.\n       */\n\n\n      function countChildren(children, context) {\n        return traverseAllChildren(children, forEachSingleChildDummy, null);\n      }\n      /**\n       * Flatten a children object (typically specified as `props.children`) and\n       * return an array with appropriately re-keyed children.\n       *\n       * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray\n       */\n\n\n      function toArray(children) {\n        var result = [];\n        mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n        return result;\n      }\n\n      var ReactChildren = {\n        forEach: forEachChildren,\n        map: mapChildren,\n        mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,\n        count: countChildren,\n        toArray: toArray\n      };\n      module.exports = ReactChildren;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        * \n        */\n        'use strict';\n\n        var _prodInvariant = __webpack_require__(8);\n\n        var invariant = __webpack_require__(9);\n        /**\n         * Static poolers. Several custom versions for each potential number of\n         * arguments. A completely generic pooler is easy to implement, but would\n         * require accessing the `arguments` object. In each of these, `this` refers to\n         * the Class itself, not an instance. If any others are needed, simply add them\n         * here, or in their own files.\n         */\n\n\n        var oneArgumentPooler = function (copyFieldsFrom) {\n          var Klass = this;\n\n          if (Klass.instancePool.length) {\n            var instance = Klass.instancePool.pop();\n            Klass.call(instance, copyFieldsFrom);\n            return instance;\n          } else {\n            return new Klass(copyFieldsFrom);\n          }\n        };\n\n        var twoArgumentPooler = function (a1, a2) {\n          var Klass = this;\n\n          if (Klass.instancePool.length) {\n            var instance = Klass.instancePool.pop();\n            Klass.call(instance, a1, a2);\n            return instance;\n          } else {\n            return new Klass(a1, a2);\n          }\n        };\n\n        var threeArgumentPooler = function (a1, a2, a3) {\n          var Klass = this;\n\n          if (Klass.instancePool.length) {\n            var instance = Klass.instancePool.pop();\n            Klass.call(instance, a1, a2, a3);\n            return instance;\n          } else {\n            return new Klass(a1, a2, a3);\n          }\n        };\n\n        var fourArgumentPooler = function (a1, a2, a3, a4) {\n          var Klass = this;\n\n          if (Klass.instancePool.length) {\n            var instance = Klass.instancePool.pop();\n            Klass.call(instance, a1, a2, a3, a4);\n            return instance;\n          } else {\n            return new Klass(a1, a2, a3, a4);\n          }\n        };\n\n        var standardReleaser = function (instance) {\n          var Klass = this;\n          !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;\n          instance.destructor();\n\n          if (Klass.instancePool.length < Klass.poolSize) {\n            Klass.instancePool.push(instance);\n          }\n        };\n\n        var DEFAULT_POOL_SIZE = 10;\n        var DEFAULT_POOLER = oneArgumentPooler;\n        /**\n         * Augments `CopyConstructor` to be a poolable class, augmenting only the class\n         * itself (statically) not adding any prototypical fields. Any CopyConstructor\n         * you give this may have a `poolSize` property, and will look for a\n         * prototypical `destructor` on instances.\n         *\n         * @param {Function} CopyConstructor Constructor that can be used to reset.\n         * @param {Function} pooler Customizable pooler.\n         */\n\n        var addPoolingTo = function (CopyConstructor, pooler) {\n          // Casting as any so that flow ignores the actual implementation and trusts\n          // it to match the type we declared\n          var NewKlass = CopyConstructor;\n          NewKlass.instancePool = [];\n          NewKlass.getPooled = pooler || DEFAULT_POOLER;\n\n          if (!NewKlass.poolSize) {\n            NewKlass.poolSize = DEFAULT_POOL_SIZE;\n          }\n\n          NewKlass.release = standardReleaser;\n          return NewKlass;\n        };\n\n        var PooledClass = {\n          addPoolingTo: addPoolingTo,\n          oneArgumentPooler: oneArgumentPooler,\n          twoArgumentPooler: twoArgumentPooler,\n          threeArgumentPooler: threeArgumentPooler,\n          fourArgumentPooler: fourArgumentPooler\n        };\n        module.exports = PooledClass;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       * \n       */\n      'use strict';\n      /**\n       * WARNING: DO NOT manually require this module.\n       * This is a replacement for `invariant(...)` used by the error code system\n       * and will _only_ be required by the corresponding babel pass.\n       * It always throws.\n       */\n\n      function reactProdInvariant(code) {\n        var argCount = arguments.length - 1;\n        var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;\n\n        for (var argIdx = 0; argIdx < argCount; argIdx++) {\n          message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);\n        }\n\n        message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';\n        var error = new Error(message);\n        error.name = 'Invariant Violation';\n        error.framesToPop = 1; // we don't care about reactProdInvariant's own frame\n\n        throw error;\n      }\n\n      module.exports = reactProdInvariant;\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright (c) 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n        /**\n         * Use invariant() to assert state which your program assumes to be true.\n         *\n         * Provide sprintf-style format (only %s is supported) and arguments\n         * to provide information about what broke and what you were\n         * expecting.\n         *\n         * The invariant message will be stripped in production, but the invariant\n         * will remain to ensure logic does not differ in production.\n         */\n\n        var validateFormat = function validateFormat(format) {};\n\n        if (process.env.NODE_ENV !== 'production') {\n          validateFormat = function validateFormat(format) {\n            if (format === undefined) {\n              throw new Error('invariant requires an error message argument');\n            }\n          };\n        }\n\n        function invariant(condition, format, a, b, c, d, e, f) {\n          validateFormat(format);\n\n          if (!condition) {\n            var error;\n\n            if (format === undefined) {\n              error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n            } else {\n              var args = [a, b, c, d, e, f];\n              var argIndex = 0;\n              error = new Error(format.replace(/%s/g, function () {\n                return args[argIndex++];\n              }));\n              error.name = 'Invariant Violation';\n            }\n\n            error.framesToPop = 1; // we don't care about invariant's own frame\n\n            throw error;\n          }\n        }\n\n        module.exports = invariant;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2014-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var _assign = __webpack_require__(5);\n\n        var ReactCurrentOwner = __webpack_require__(11);\n\n        var warning = __webpack_require__(12);\n\n        var canDefineProperty = __webpack_require__(14);\n\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        var REACT_ELEMENT_TYPE = __webpack_require__(15);\n\n        var RESERVED_PROPS = {\n          key: true,\n          ref: true,\n          __self: true,\n          __source: true\n        };\n        var specialPropKeyWarningShown, specialPropRefWarningShown;\n\n        function hasValidRef(config) {\n          if (process.env.NODE_ENV !== 'production') {\n            if (hasOwnProperty.call(config, 'ref')) {\n              var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n\n          return config.ref !== undefined;\n        }\n\n        function hasValidKey(config) {\n          if (process.env.NODE_ENV !== 'production') {\n            if (hasOwnProperty.call(config, 'key')) {\n              var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n\n          return config.key !== undefined;\n        }\n\n        function defineKeyPropWarningGetter(props, displayName) {\n          var warnAboutAccessingKey = function () {\n            if (!specialPropKeyWarningShown) {\n              specialPropKeyWarningShown = true;\n              process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;\n            }\n          };\n\n          warnAboutAccessingKey.isReactWarning = true;\n          Object.defineProperty(props, 'key', {\n            get: warnAboutAccessingKey,\n            configurable: true\n          });\n        }\n\n        function defineRefPropWarningGetter(props, displayName) {\n          var warnAboutAccessingRef = function () {\n            if (!specialPropRefWarningShown) {\n              specialPropRefWarningShown = true;\n              process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;\n            }\n          };\n\n          warnAboutAccessingRef.isReactWarning = true;\n          Object.defineProperty(props, 'ref', {\n            get: warnAboutAccessingRef,\n            configurable: true\n          });\n        }\n        /**\n         * Factory method to create a new React element. This no longer adheres to\n         * the class pattern, so do not use new to call it. Also, no instanceof check\n         * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n         * if something is a React Element.\n         *\n         * @param {*} type\n         * @param {*} key\n         * @param {string|object} ref\n         * @param {*} self A *temporary* helper to detect places where `this` is\n         * different from the `owner` when React.createElement is called, so that we\n         * can warn. We want to get rid of owner and replace string `ref`s with arrow\n         * functions, and as long as `this` and owner are the same, there will be no\n         * change in behavior.\n         * @param {*} source An annotation object (added by a transpiler or otherwise)\n         * indicating filename, line number, and/or other information.\n         * @param {*} owner\n         * @param {*} props\n         * @internal\n         */\n\n\n        var ReactElement = function (type, key, ref, self, source, owner, props) {\n          var element = {\n            // This tag allow us to uniquely identify this as a React Element\n            $$typeof: REACT_ELEMENT_TYPE,\n            // Built-in properties that belong on the element\n            type: type,\n            key: key,\n            ref: ref,\n            props: props,\n            // Record the component responsible for creating this element.\n            _owner: owner\n          };\n\n          if (process.env.NODE_ENV !== 'production') {\n            // The validation flag is currently mutative. We put it on\n            // an external backing store so that we can freeze the whole object.\n            // This can be replaced with a WeakMap once they are implemented in\n            // commonly used development environments.\n            element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n            // the validation flag non-enumerable (where possible, which should\n            // include every environment we run tests in), so the test framework\n            // ignores it.\n\n            if (canDefineProperty) {\n              Object.defineProperty(element._store, 'validated', {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: false\n              }); // self and source are DEV only properties.\n\n              Object.defineProperty(element, '_self', {\n                configurable: false,\n                enumerable: false,\n                writable: false,\n                value: self\n              }); // Two elements created in two different places should be considered\n              // equal for testing purposes and therefore we hide it from enumeration.\n\n              Object.defineProperty(element, '_source', {\n                configurable: false,\n                enumerable: false,\n                writable: false,\n                value: source\n              });\n            } else {\n              element._store.validated = false;\n              element._self = self;\n              element._source = source;\n            }\n\n            if (Object.freeze) {\n              Object.freeze(element.props);\n              Object.freeze(element);\n            }\n          }\n\n          return element;\n        };\n        /**\n         * Create and return a new ReactElement of the given type.\n         * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement\n         */\n\n\n        ReactElement.createElement = function (type, config, children) {\n          var propName; // Reserved names are extracted\n\n          var props = {};\n          var key = null;\n          var ref = null;\n          var self = null;\n          var source = null;\n\n          if (config != null) {\n            if (hasValidRef(config)) {\n              ref = config.ref;\n            }\n\n            if (hasValidKey(config)) {\n              key = '' + config.key;\n            }\n\n            self = config.__self === undefined ? null : config.__self;\n            source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                props[propName] = config[propName];\n              }\n            }\n          } // Children can be more than one argument, and those are transferred onto\n          // the newly allocated props object.\n\n\n          var childrenLength = arguments.length - 2;\n\n          if (childrenLength === 1) {\n            props.children = children;\n          } else if (childrenLength > 1) {\n            var childArray = Array(childrenLength);\n\n            for (var i = 0; i < childrenLength; i++) {\n              childArray[i] = arguments[i + 2];\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (Object.freeze) {\n                Object.freeze(childArray);\n              }\n            }\n\n            props.children = childArray;\n          } // Resolve default props\n\n\n          if (type && type.defaultProps) {\n            var defaultProps = type.defaultProps;\n\n            for (propName in defaultProps) {\n              if (props[propName] === undefined) {\n                props[propName] = defaultProps[propName];\n              }\n            }\n          }\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (key || ref) {\n              if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n                var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n                if (key) {\n                  defineKeyPropWarningGetter(props, displayName);\n                }\n\n                if (ref) {\n                  defineRefPropWarningGetter(props, displayName);\n                }\n              }\n            }\n          }\n\n          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        };\n        /**\n         * Return a function that produces ReactElements of a given type.\n         * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory\n         */\n\n\n        ReactElement.createFactory = function (type) {\n          var factory = ReactElement.createElement.bind(null, type); // Expose the type on the factory and the prototype so that it can be\n          // easily accessed on elements. E.g. `<Foo />.type === Foo`.\n          // This should not be named `constructor` since this may not be the function\n          // that created the element, and it may not even be a constructor.\n          // Legacy hook TODO: Warn if this is accessed\n\n          factory.type = type;\n          return factory;\n        };\n\n        ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {\n          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n          return newElement;\n        };\n        /**\n         * Clone and return a new ReactElement using element as the starting point.\n         * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement\n         */\n\n\n        ReactElement.cloneElement = function (element, config, children) {\n          var propName; // Original props are copied\n\n          var props = _assign({}, element.props); // Reserved names are extracted\n\n\n          var key = element.key;\n          var ref = element.ref; // Self is preserved since the owner is preserved.\n\n          var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n          // transpiler, and the original source is probably a better indicator of the\n          // true owner.\n\n          var source = element._source; // Owner will be preserved, unless ref is overridden\n\n          var owner = element._owner;\n\n          if (config != null) {\n            if (hasValidRef(config)) {\n              // Silently steal the ref from the parent.\n              ref = config.ref;\n              owner = ReactCurrentOwner.current;\n            }\n\n            if (hasValidKey(config)) {\n              key = '' + config.key;\n            } // Remaining properties override existing props\n\n\n            var defaultProps;\n\n            if (element.type && element.type.defaultProps) {\n              defaultProps = element.type.defaultProps;\n            }\n\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                if (config[propName] === undefined && defaultProps !== undefined) {\n                  // Resolve default props\n                  props[propName] = defaultProps[propName];\n                } else {\n                  props[propName] = config[propName];\n                }\n              }\n            }\n          } // Children can be more than one argument, and those are transferred onto\n          // the newly allocated props object.\n\n\n          var childrenLength = arguments.length - 2;\n\n          if (childrenLength === 1) {\n            props.children = children;\n          } else if (childrenLength > 1) {\n            var childArray = Array(childrenLength);\n\n            for (var i = 0; i < childrenLength; i++) {\n              childArray[i] = arguments[i + 2];\n            }\n\n            props.children = childArray;\n          }\n\n          return ReactElement(element.type, key, ref, self, source, owner, props);\n        };\n        /**\n         * Verifies the object is a ReactElement.\n         * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement\n         * @param {?object} object\n         * @return {boolean} True if `object` is a valid component.\n         * @final\n         */\n\n\n        ReactElement.isValidElement = function (object) {\n          return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        };\n\n        module.exports = ReactElement;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       * \n       */\n      'use strict';\n      /**\n       * Keeps track of the current owner.\n       *\n       * The current owner is the component who should own any components that are\n       * currently being constructed.\n       */\n\n      var ReactCurrentOwner = {\n        /**\n         * @internal\n         * @type {ReactComponent}\n         */\n        current: null\n      };\n      module.exports = ReactCurrentOwner;\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2014-2015, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var emptyFunction = __webpack_require__(13);\n        /**\n         * Similar to invariant but only logs a warning if the condition is not met.\n         * This can be used to log issues in development environments in critical\n         * paths. Removing the logging code for production environments will keep the\n         * same logic and follow the same code paths.\n         */\n\n\n        var warning = emptyFunction;\n\n        if (process.env.NODE_ENV !== 'production') {\n          (function () {\n            var printWarning = function printWarning(format) {\n              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n\n              var argIndex = 0;\n              var message = 'Warning: ' + format.replace(/%s/g, function () {\n                return args[argIndex++];\n              });\n\n              if (typeof console !== 'undefined') {\n                console.error(message);\n              }\n\n              try {\n                // --- Welcome to debugging React ---\n                // This error was thrown as a convenience so that you can use this stack\n                // to find the callsite that caused this warning to fire.\n                throw new Error(message);\n              } catch (x) {}\n            };\n\n            warning = function warning(condition, format) {\n              if (format === undefined) {\n                throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n              }\n\n              if (format.indexOf('Failed Composite propType: ') === 0) {\n                return; // Ignore CompositeComponent proptype check.\n              }\n\n              if (!condition) {\n                for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n                  args[_key2 - 2] = arguments[_key2];\n                }\n\n                printWarning.apply(undefined, [format].concat(args));\n              }\n            };\n          })();\n        }\n\n        module.exports = warning;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       * \n       */\n\n      function makeEmptyFunction(arg) {\n        return function () {\n          return arg;\n        };\n      }\n      /**\n       * This function accepts and discards inputs; it has no side effects. This is\n       * primarily useful idiomatically for overridable function endpoints which\n       * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n       */\n\n\n      var emptyFunction = function emptyFunction() {};\n\n      emptyFunction.thatReturns = makeEmptyFunction;\n      emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n      emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n      emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n\n      emptyFunction.thatReturnsThis = function () {\n        return this;\n      };\n\n      emptyFunction.thatReturnsArgument = function (arg) {\n        return arg;\n      };\n\n      module.exports = emptyFunction;\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        * \n        */\n        'use strict';\n\n        var canDefineProperty = false;\n\n        if (process.env.NODE_ENV !== 'production') {\n          try {\n            // $FlowFixMe https://github.com/facebook/flow/issues/285\n            Object.defineProperty({}, 'x', {\n              get: function () {}\n            });\n            canDefineProperty = true;\n          } catch (x) {// IE will fail on defineProperty\n          }\n        }\n\n        module.exports = canDefineProperty;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright 2014-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       * \n       */\n      'use strict'; // The Symbol used to tag the ReactElement type. If there is no native Symbol\n      // nor polyfill, then a plain number is used for performance.\n\n      var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;\n      module.exports = REACT_ELEMENT_TYPE;\n      /***/\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var _prodInvariant = __webpack_require__(8);\n\n        var ReactCurrentOwner = __webpack_require__(11);\n\n        var REACT_ELEMENT_TYPE = __webpack_require__(15);\n\n        var getIteratorFn = __webpack_require__(17);\n\n        var invariant = __webpack_require__(9);\n\n        var KeyEscapeUtils = __webpack_require__(18);\n\n        var warning = __webpack_require__(12);\n\n        var SEPARATOR = '.';\n        var SUBSEPARATOR = ':';\n        /**\n         * This is inlined from ReactElement since this file is shared between\n         * isomorphic and renderers. We could extract this to a\n         *\n         */\n\n        /**\n         * TODO: Test that a single child and an array with one item have the same key\n         * pattern.\n         */\n\n        var didWarnAboutMaps = false;\n        /**\n         * Generate a key string that identifies a component within a set.\n         *\n         * @param {*} component A component that could contain a manual key.\n         * @param {number} index Index that is used if a manual key is not provided.\n         * @return {string}\n         */\n\n        function getComponentKey(component, index) {\n          // Do some typechecking here since we call this blindly. We want to ensure\n          // that we don't block potential future ES APIs.\n          if (component && typeof component === 'object' && component.key != null) {\n            // Explicit key\n            return KeyEscapeUtils.escape(component.key);\n          } // Implicit key determined by the index in the set\n\n\n          return index.toString(36);\n        }\n        /**\n         * @param {?*} children Children tree container.\n         * @param {!string} nameSoFar Name of the key path so far.\n         * @param {!function} callback Callback to invoke with each child found.\n         * @param {?*} traverseContext Used to pass information throughout the traversal\n         * process.\n         * @return {!number} The number of children in this subtree.\n         */\n\n\n        function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n          var type = typeof children;\n\n          if (type === 'undefined' || type === 'boolean') {\n            // All of the above are perceived as null.\n            children = null;\n          }\n\n          if (children === null || type === 'string' || type === 'number' || // The following is inlined from ReactElement. This means we can optimize\n          // some checks. React Fiber also inlines this logic for similar purposes.\n          type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {\n            callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n            // so that it's consistent if the number of children grows.\n            nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n            return 1;\n          }\n\n          var child;\n          var nextName;\n          var subtreeCount = 0; // Count of children found in the current subtree.\n\n          var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n          if (Array.isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              child = children[i];\n              nextName = nextNamePrefix + getComponentKey(child, i);\n              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n            }\n          } else {\n            var iteratorFn = getIteratorFn(children);\n\n            if (iteratorFn) {\n              var iterator = iteratorFn.call(children);\n              var step;\n\n              if (iteratorFn !== children.entries) {\n                var ii = 0;\n\n                while (!(step = iterator.next()).done) {\n                  child = step.value;\n                  nextName = nextNamePrefix + getComponentKey(child, ii++);\n                  subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n                }\n              } else {\n                if (process.env.NODE_ENV !== 'production') {\n                  var mapsAsChildrenAddendum = '';\n\n                  if (ReactCurrentOwner.current) {\n                    var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();\n\n                    if (mapsAsChildrenOwnerName) {\n                      mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';\n                    }\n                  }\n\n                  process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;\n                  didWarnAboutMaps = true;\n                } // Iterator will provide entry [k,v] tuples rather than values.\n\n\n                while (!(step = iterator.next()).done) {\n                  var entry = step.value;\n\n                  if (entry) {\n                    child = entry[1];\n                    nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);\n                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n                  }\n                }\n              }\n            } else if (type === 'object') {\n              var addendum = '';\n\n              if (process.env.NODE_ENV !== 'production') {\n                addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';\n\n                if (children._isReactElement) {\n                  addendum = ' It looks like you\\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';\n                }\n\n                if (ReactCurrentOwner.current) {\n                  var name = ReactCurrentOwner.current.getName();\n\n                  if (name) {\n                    addendum += ' Check the render method of `' + name + '`.';\n                  }\n                }\n              }\n\n              var childrenString = String(children);\n              true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;\n            }\n          }\n\n          return subtreeCount;\n        }\n        /**\n         * Traverses children that are typically specified as `props.children`, but\n         * might also be specified through attributes:\n         *\n         * - `traverseAllChildren(this.props.children, ...)`\n         * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n         *\n         * The `traverseContext` is an optional argument that is passed through the\n         * entire traversal. It can be used to store accumulations or anything else that\n         * the callback might find relevant.\n         *\n         * @param {?*} children Children tree object.\n         * @param {!function} callback To invoke upon traversing each child.\n         * @param {?*} traverseContext Context for traversal.\n         * @return {!number} The number of children in this subtree.\n         */\n\n\n        function traverseAllChildren(children, callback, traverseContext) {\n          if (children == null) {\n            return 0;\n          }\n\n          return traverseAllChildrenImpl(children, '', callback, traverseContext);\n        }\n\n        module.exports = traverseAllChildren;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 17 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       * \n       */\n      'use strict';\n      /* global Symbol */\n\n      var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n      var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n      /**\n       * Returns the iterator method function contained on the iterable object.\n       *\n       * Be sure to invoke the function with the iterable as context:\n       *\n       *     var iteratorFn = getIteratorFn(myIterable);\n       *     if (iteratorFn) {\n       *       var iterator = iteratorFn.call(myIterable);\n       *       ...\n       *     }\n       *\n       * @param {?object} maybeIterable\n       * @return {?function}\n       */\n\n      function getIteratorFn(maybeIterable) {\n        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n\n        if (typeof iteratorFn === 'function') {\n          return iteratorFn;\n        }\n      }\n\n      module.exports = getIteratorFn;\n      /***/\n    },\n    /* 18 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       * \n       */\n      'use strict';\n      /**\n       * Escape and wrap key so it is safe to use as a reactid\n       *\n       * @param {string} key to be escaped.\n       * @return {string} the escaped key.\n       */\n\n      function escape(key) {\n        var escapeRegex = /[=:]/g;\n        var escaperLookup = {\n          '=': '=0',\n          ':': '=2'\n        };\n        var escapedString = ('' + key).replace(escapeRegex, function (match) {\n          return escaperLookup[match];\n        });\n        return '$' + escapedString;\n      }\n      /**\n       * Unescape and unwrap key for human-readable display\n       *\n       * @param {string} key to unescape.\n       * @return {string} the unescaped key.\n       */\n\n\n      function unescape(key) {\n        var unescapeRegex = /(=0|=2)/g;\n        var unescaperLookup = {\n          '=0': '=',\n          '=2': ':'\n        };\n        var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);\n        return ('' + keySubstring).replace(unescapeRegex, function (match) {\n          return unescaperLookup[match];\n        });\n      }\n\n      var KeyEscapeUtils = {\n        escape: escape,\n        unescape: unescape\n      };\n      module.exports = KeyEscapeUtils;\n      /***/\n    },\n    /* 19 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var _prodInvariant = __webpack_require__(8);\n\n        var ReactNoopUpdateQueue = __webpack_require__(20);\n\n        var canDefineProperty = __webpack_require__(14);\n\n        var emptyObject = __webpack_require__(21);\n\n        var invariant = __webpack_require__(9);\n\n        var warning = __webpack_require__(12);\n        /**\n         * Base class helpers for the updating state of a component.\n         */\n\n\n        function ReactComponent(props, context, updater) {\n          this.props = props;\n          this.context = context;\n          this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n          // renderer.\n\n          this.updater = updater || ReactNoopUpdateQueue;\n        }\n\n        ReactComponent.prototype.isReactComponent = {};\n        /**\n         * Sets a subset of the state. Always use this to mutate\n         * state. You should treat `this.state` as immutable.\n         *\n         * There is no guarantee that `this.state` will be immediately updated, so\n         * accessing `this.state` after calling this method may return the old value.\n         *\n         * There is no guarantee that calls to `setState` will run synchronously,\n         * as they may eventually be batched together.  You can provide an optional\n         * callback that will be executed when the call to setState is actually\n         * completed.\n         *\n         * When a function is provided to setState, it will be called at some point in\n         * the future (not synchronously). It will be called with the up to date\n         * component arguments (state, props, context). These values can be different\n         * from this.* because your function may be called after receiveProps but before\n         * shouldComponentUpdate, and this new state, props, and context will not yet be\n         * assigned to this.\n         *\n         * @param {object|function} partialState Next partial state or function to\n         *        produce next partial state to be merged with current state.\n         * @param {?function} callback Called after state is updated.\n         * @final\n         * @protected\n         */\n\n        ReactComponent.prototype.setState = function (partialState, callback) {\n          !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;\n          this.updater.enqueueSetState(this, partialState);\n\n          if (callback) {\n            this.updater.enqueueCallback(this, callback, 'setState');\n          }\n        };\n        /**\n         * Forces an update. This should only be invoked when it is known with\n         * certainty that we are **not** in a DOM transaction.\n         *\n         * You may want to call this when you know that some deeper aspect of the\n         * component's state has changed but `setState` was not called.\n         *\n         * This will not invoke `shouldComponentUpdate`, but it will invoke\n         * `componentWillUpdate` and `componentDidUpdate`.\n         *\n         * @param {?function} callback Called after update is complete.\n         * @final\n         * @protected\n         */\n\n\n        ReactComponent.prototype.forceUpdate = function (callback) {\n          this.updater.enqueueForceUpdate(this);\n\n          if (callback) {\n            this.updater.enqueueCallback(this, callback, 'forceUpdate');\n          }\n        };\n        /**\n         * Deprecated APIs. These APIs used to exist on classic React classes but since\n         * we would like to deprecate them, we're not going to move them over to this\n         * modern base class. Instead, we define a getter that warns if it's accessed.\n         */\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          var deprecatedAPIs = {\n            isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n            replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n          };\n\n          var defineDeprecationWarning = function (methodName, info) {\n            if (canDefineProperty) {\n              Object.defineProperty(ReactComponent.prototype, methodName, {\n                get: function () {\n                  process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;\n                  return undefined;\n                }\n              });\n            }\n          };\n\n          for (var fnName in deprecatedAPIs) {\n            if (deprecatedAPIs.hasOwnProperty(fnName)) {\n              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n            }\n          }\n        }\n\n        module.exports = ReactComponent;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 20 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2015-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var warning = __webpack_require__(12);\n\n        function warnNoop(publicInstance, callerName) {\n          if (process.env.NODE_ENV !== 'production') {\n            var constructor = publicInstance.constructor;\n            process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;\n          }\n        }\n        /**\n         * This is the abstract API for an update queue.\n         */\n\n\n        var ReactNoopUpdateQueue = {\n          /**\n           * Checks whether or not this composite component is mounted.\n           * @param {ReactClass} publicInstance The instance we want to test.\n           * @return {boolean} True if mounted, false otherwise.\n           * @protected\n           * @final\n           */\n          isMounted: function (publicInstance) {\n            return false;\n          },\n\n          /**\n           * Enqueue a callback that will be executed after all the pending updates\n           * have processed.\n           *\n           * @param {ReactClass} publicInstance The instance to use as `this` context.\n           * @param {?function} callback Called after state is updated.\n           * @internal\n           */\n          enqueueCallback: function (publicInstance, callback) {},\n\n          /**\n           * Forces an update. This should only be invoked when it is known with\n           * certainty that we are **not** in a DOM transaction.\n           *\n           * You may want to call this when you know that some deeper aspect of the\n           * component's state has changed but `setState` was not called.\n           *\n           * This will not invoke `shouldComponentUpdate`, but it will invoke\n           * `componentWillUpdate` and `componentDidUpdate`.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @internal\n           */\n          enqueueForceUpdate: function (publicInstance) {\n            warnNoop(publicInstance, 'forceUpdate');\n          },\n\n          /**\n           * Replaces all of the state. Always use this or `setState` to mutate state.\n           * You should treat `this.state` as immutable.\n           *\n           * There is no guarantee that `this.state` will be immediately updated, so\n           * accessing `this.state` after calling this method may return the old value.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @param {object} completeState Next state.\n           * @internal\n           */\n          enqueueReplaceState: function (publicInstance, completeState) {\n            warnNoop(publicInstance, 'replaceState');\n          },\n\n          /**\n           * Sets a subset of the state. This only exists because _pendingState is\n           * internal. This provides a merging strategy that is not available to deep\n           * properties which is confusing. TODO: Expose pendingState or don't use it\n           * during the merge.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @param {object} partialState Next partial state to be merged with state.\n           * @internal\n           */\n          enqueueSetState: function (publicInstance, partialState) {\n            warnNoop(publicInstance, 'setState');\n          }\n        };\n        module.exports = ReactNoopUpdateQueue;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 21 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright (c) 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var emptyObject = {};\n\n        if (process.env.NODE_ENV !== 'production') {\n          Object.freeze(emptyObject);\n        }\n\n        module.exports = emptyObject;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 22 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * Copyright 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       */\n      'use strict';\n\n      var _assign = __webpack_require__(5);\n\n      var ReactComponent = __webpack_require__(19);\n\n      var ReactNoopUpdateQueue = __webpack_require__(20);\n\n      var emptyObject = __webpack_require__(21);\n      /**\n       * Base class helpers for the updating state of a component.\n       */\n\n\n      function ReactPureComponent(props, context, updater) {\n        // Duplicated from ReactComponent.\n        this.props = props;\n        this.context = context;\n        this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n        // renderer.\n\n        this.updater = updater || ReactNoopUpdateQueue;\n      }\n\n      function ComponentDummy() {}\n\n      ComponentDummy.prototype = ReactComponent.prototype;\n      ReactPureComponent.prototype = new ComponentDummy();\n      ReactPureComponent.prototype.constructor = ReactPureComponent; // Avoid an extra prototype jump for these methods.\n\n      _assign(ReactPureComponent.prototype, ReactComponent.prototype);\n\n      ReactPureComponent.prototype.isPureReactComponent = true;\n      module.exports = ReactPureComponent;\n      /***/\n    },\n    /* 23 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var _prodInvariant = __webpack_require__(8),\n            _assign = __webpack_require__(5);\n\n        var ReactComponent = __webpack_require__(19);\n\n        var ReactElement = __webpack_require__(10);\n\n        var ReactPropTypeLocationNames = __webpack_require__(24);\n\n        var ReactNoopUpdateQueue = __webpack_require__(20);\n\n        var emptyObject = __webpack_require__(21);\n\n        var invariant = __webpack_require__(9);\n\n        var warning = __webpack_require__(12);\n\n        var MIXINS_KEY = 'mixins'; // Helper function to allow the creation of anonymous functions which do not\n        // have .name set to the name of the variable being assigned to.\n\n        function identity(fn) {\n          return fn;\n        }\n        /**\n         * Policies that describe methods in `ReactClassInterface`.\n         */\n\n\n        var injectedMixins = [];\n        /**\n         * Composite components are higher-level components that compose other composite\n         * or host components.\n         *\n         * To create a new type of `ReactClass`, pass a specification of\n         * your new class to `React.createClass`. The only requirement of your class\n         * specification is that you implement a `render` method.\n         *\n         *   var MyComponent = React.createClass({\n         *     render: function() {\n         *       return <div>Hello World</div>;\n         *     }\n         *   });\n         *\n         * The class specification supports a specific protocol of methods that have\n         * special meaning (e.g. `render`). See `ReactClassInterface` for\n         * more the comprehensive protocol. Any other properties and methods in the\n         * class specification will be available on the prototype.\n         *\n         * @interface ReactClassInterface\n         * @internal\n         */\n\n        var ReactClassInterface = {\n          /**\n           * An array of Mixin objects to include when defining your component.\n           *\n           * @type {array}\n           * @optional\n           */\n          mixins: 'DEFINE_MANY',\n\n          /**\n           * An object containing properties and methods that should be defined on\n           * the component's constructor instead of its prototype (static methods).\n           *\n           * @type {object}\n           * @optional\n           */\n          statics: 'DEFINE_MANY',\n\n          /**\n           * Definition of prop types for this component.\n           *\n           * @type {object}\n           * @optional\n           */\n          propTypes: 'DEFINE_MANY',\n\n          /**\n           * Definition of context types for this component.\n           *\n           * @type {object}\n           * @optional\n           */\n          contextTypes: 'DEFINE_MANY',\n\n          /**\n           * Definition of context types this component sets for its children.\n           *\n           * @type {object}\n           * @optional\n           */\n          childContextTypes: 'DEFINE_MANY',\n          // ==== Definition methods ====\n\n          /**\n           * Invoked when the component is mounted. Values in the mapping will be set on\n           * `this.props` if that prop is not specified (i.e. using an `in` check).\n           *\n           * This method is invoked before `getInitialState` and therefore cannot rely\n           * on `this.state` or use `this.setState`.\n           *\n           * @return {object}\n           * @optional\n           */\n          getDefaultProps: 'DEFINE_MANY_MERGED',\n\n          /**\n           * Invoked once before the component is mounted. The return value will be used\n           * as the initial value of `this.state`.\n           *\n           *   getInitialState: function() {\n           *     return {\n           *       isOn: false,\n           *       fooBaz: new BazFoo()\n           *     }\n           *   }\n           *\n           * @return {object}\n           * @optional\n           */\n          getInitialState: 'DEFINE_MANY_MERGED',\n\n          /**\n           * @return {object}\n           * @optional\n           */\n          getChildContext: 'DEFINE_MANY_MERGED',\n\n          /**\n           * Uses props from `this.props` and state from `this.state` to render the\n           * structure of the component.\n           *\n           * No guarantees are made about when or how often this method is invoked, so\n           * it must not have side effects.\n           *\n           *   render: function() {\n           *     var name = this.props.name;\n           *     return <div>Hello, {name}!</div>;\n           *   }\n           *\n           * @return {ReactComponent}\n           * @nosideeffects\n           * @required\n           */\n          render: 'DEFINE_ONCE',\n          // ==== Delegate methods ====\n\n          /**\n           * Invoked when the component is initially created and about to be mounted.\n           * This may have side effects, but any external subscriptions or data created\n           * by this method must be cleaned up in `componentWillUnmount`.\n           *\n           * @optional\n           */\n          componentWillMount: 'DEFINE_MANY',\n\n          /**\n           * Invoked when the component has been mounted and has a DOM representation.\n           * However, there is no guarantee that the DOM node is in the document.\n           *\n           * Use this as an opportunity to operate on the DOM when the component has\n           * been mounted (initialized and rendered) for the first time.\n           *\n           * @param {DOMElement} rootNode DOM element representing the component.\n           * @optional\n           */\n          componentDidMount: 'DEFINE_MANY',\n\n          /**\n           * Invoked before the component receives new props.\n           *\n           * Use this as an opportunity to react to a prop transition by updating the\n           * state using `this.setState`. Current props are accessed via `this.props`.\n           *\n           *   componentWillReceiveProps: function(nextProps, nextContext) {\n           *     this.setState({\n           *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n           *     });\n           *   }\n           *\n           * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n           * transition may cause a state change, but the opposite is not true. If you\n           * need it, you are probably looking for `componentWillUpdate`.\n           *\n           * @param {object} nextProps\n           * @optional\n           */\n          componentWillReceiveProps: 'DEFINE_MANY',\n\n          /**\n           * Invoked while deciding if the component should be updated as a result of\n           * receiving new props, state and/or context.\n           *\n           * Use this as an opportunity to `return false` when you're certain that the\n           * transition to the new props/state/context will not require a component\n           * update.\n           *\n           *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n           *     return !equal(nextProps, this.props) ||\n           *       !equal(nextState, this.state) ||\n           *       !equal(nextContext, this.context);\n           *   }\n           *\n           * @param {object} nextProps\n           * @param {?object} nextState\n           * @param {?object} nextContext\n           * @return {boolean} True if the component should update.\n           * @optional\n           */\n          shouldComponentUpdate: 'DEFINE_ONCE',\n\n          /**\n           * Invoked when the component is about to update due to a transition from\n           * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n           * and `nextContext`.\n           *\n           * Use this as an opportunity to perform preparation before an update occurs.\n           *\n           * NOTE: You **cannot** use `this.setState()` in this method.\n           *\n           * @param {object} nextProps\n           * @param {?object} nextState\n           * @param {?object} nextContext\n           * @param {ReactReconcileTransaction} transaction\n           * @optional\n           */\n          componentWillUpdate: 'DEFINE_MANY',\n\n          /**\n           * Invoked when the component's DOM representation has been updated.\n           *\n           * Use this as an opportunity to operate on the DOM when the component has\n           * been updated.\n           *\n           * @param {object} prevProps\n           * @param {?object} prevState\n           * @param {?object} prevContext\n           * @param {DOMElement} rootNode DOM element representing the component.\n           * @optional\n           */\n          componentDidUpdate: 'DEFINE_MANY',\n\n          /**\n           * Invoked when the component is about to be removed from its parent and have\n           * its DOM representation destroyed.\n           *\n           * Use this as an opportunity to deallocate any external resources.\n           *\n           * NOTE: There is no `componentDidUnmount` since your component will have been\n           * destroyed by that point.\n           *\n           * @optional\n           */\n          componentWillUnmount: 'DEFINE_MANY',\n          // ==== Advanced methods ====\n\n          /**\n           * Updates the component's currently mounted DOM representation.\n           *\n           * By default, this implements React's rendering and reconciliation algorithm.\n           * Sophisticated clients may wish to override this.\n           *\n           * @param {ReactReconcileTransaction} transaction\n           * @internal\n           * @overridable\n           */\n          updateComponent: 'OVERRIDE_BASE'\n        };\n        /**\n         * Mapping from class specification keys to special processing functions.\n         *\n         * Although these are declared like instance properties in the specification\n         * when defining classes using `React.createClass`, they are actually static\n         * and are accessible on the constructor instead of the prototype. Despite\n         * being static, they must be defined outside of the \"statics\" key under\n         * which all other static methods are defined.\n         */\n\n        var RESERVED_SPEC_KEYS = {\n          displayName: function (Constructor, displayName) {\n            Constructor.displayName = displayName;\n          },\n          mixins: function (Constructor, mixins) {\n            if (mixins) {\n              for (var i = 0; i < mixins.length; i++) {\n                mixSpecIntoComponent(Constructor, mixins[i]);\n              }\n            }\n          },\n          childContextTypes: function (Constructor, childContextTypes) {\n            if (process.env.NODE_ENV !== 'production') {\n              validateTypeDef(Constructor, childContextTypes, 'childContext');\n            }\n\n            Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);\n          },\n          contextTypes: function (Constructor, contextTypes) {\n            if (process.env.NODE_ENV !== 'production') {\n              validateTypeDef(Constructor, contextTypes, 'context');\n            }\n\n            Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);\n          },\n\n          /**\n           * Special case getDefaultProps which should move into statics but requires\n           * automatic merging.\n           */\n          getDefaultProps: function (Constructor, getDefaultProps) {\n            if (Constructor.getDefaultProps) {\n              Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);\n            } else {\n              Constructor.getDefaultProps = getDefaultProps;\n            }\n          },\n          propTypes: function (Constructor, propTypes) {\n            if (process.env.NODE_ENV !== 'production') {\n              validateTypeDef(Constructor, propTypes, 'prop');\n            }\n\n            Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);\n          },\n          statics: function (Constructor, statics) {\n            mixStaticSpecIntoComponent(Constructor, statics);\n          },\n          autobind: function () {}\n        };\n\n        function validateTypeDef(Constructor, typeDef, location) {\n          for (var propName in typeDef) {\n            if (typeDef.hasOwnProperty(propName)) {\n              // use a warning instead of an invariant so components\n              // don't show up in prod but only in __DEV__\n              process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;\n            }\n          }\n        }\n\n        function validateMethodOverride(isAlreadyDefined, name) {\n          var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null; // Disallow overriding of base class methods unless explicitly allowed.\n\n          if (ReactClassMixin.hasOwnProperty(name)) {\n            !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;\n          } // Disallow defining methods more than once unless explicitly allowed.\n\n\n          if (isAlreadyDefined) {\n            !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;\n          }\n        }\n        /**\n         * Mixin helper which handles policy validation and reserved\n         * specification keys when building React classes.\n         */\n\n\n        function mixSpecIntoComponent(Constructor, spec) {\n          if (!spec) {\n            if (process.env.NODE_ENV !== 'production') {\n              var typeofSpec = typeof spec;\n              var isMixinValid = typeofSpec === 'object' && spec !== null;\n              process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;\n            }\n\n            return;\n          }\n\n          !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;\n          !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;\n          var proto = Constructor.prototype;\n          var autoBindPairs = proto.__reactAutoBindPairs; // By handling mixins before any other properties, we ensure the same\n          // chaining order is applied to methods with DEFINE_MANY policy, whether\n          // mixins are listed before or after these methods in the spec.\n\n          if (spec.hasOwnProperty(MIXINS_KEY)) {\n            RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n          }\n\n          for (var name in spec) {\n            if (!spec.hasOwnProperty(name)) {\n              continue;\n            }\n\n            if (name === MIXINS_KEY) {\n              // We have already handled mixins in a special case above.\n              continue;\n            }\n\n            var property = spec[name];\n            var isAlreadyDefined = proto.hasOwnProperty(name);\n            validateMethodOverride(isAlreadyDefined, name);\n\n            if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n              RESERVED_SPEC_KEYS[name](Constructor, property);\n            } else {\n              // Setup methods on prototype:\n              // The following member methods should not be automatically bound:\n              // 1. Expected ReactClass methods (in the \"interface\").\n              // 2. Overridden methods (that were mixed in).\n              var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\n              var isFunction = typeof property === 'function';\n              var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;\n\n              if (shouldAutoBind) {\n                autoBindPairs.push(name, property);\n                proto[name] = property;\n              } else {\n                if (isAlreadyDefined) {\n                  var specPolicy = ReactClassInterface[name]; // These cases should already be caught by validateMethodOverride.\n\n                  !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0; // For methods which are defined more than once, call the existing\n                  // methods before calling the new property, merging if appropriate.\n\n                  if (specPolicy === 'DEFINE_MANY_MERGED') {\n                    proto[name] = createMergedResultFunction(proto[name], property);\n                  } else if (specPolicy === 'DEFINE_MANY') {\n                    proto[name] = createChainedFunction(proto[name], property);\n                  }\n                } else {\n                  proto[name] = property;\n\n                  if (process.env.NODE_ENV !== 'production') {\n                    // Add verbose displayName to the function, which helps when looking\n                    // at profiling tools.\n                    if (typeof property === 'function' && spec.displayName) {\n                      proto[name].displayName = spec.displayName + '_' + name;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        function mixStaticSpecIntoComponent(Constructor, statics) {\n          if (!statics) {\n            return;\n          }\n\n          for (var name in statics) {\n            var property = statics[name];\n\n            if (!statics.hasOwnProperty(name)) {\n              continue;\n            }\n\n            var isReserved = name in RESERVED_SPEC_KEYS;\n            !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;\n            var isInherited = name in Constructor;\n            !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;\n            Constructor[name] = property;\n          }\n        }\n        /**\n         * Merge two objects, but throw if both contain the same key.\n         *\n         * @param {object} one The first object, which is mutated.\n         * @param {object} two The second object\n         * @return {object} one after it has been mutated to contain everything in two.\n         */\n\n\n        function mergeIntoWithNoDuplicateKeys(one, two) {\n          !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;\n\n          for (var key in two) {\n            if (two.hasOwnProperty(key)) {\n              !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;\n              one[key] = two[key];\n            }\n          }\n\n          return one;\n        }\n        /**\n         * Creates a function that invokes two functions and merges their return values.\n         *\n         * @param {function} one Function to invoke first.\n         * @param {function} two Function to invoke second.\n         * @return {function} Function that invokes the two argument functions.\n         * @private\n         */\n\n\n        function createMergedResultFunction(one, two) {\n          return function mergedResult() {\n            var a = one.apply(this, arguments);\n            var b = two.apply(this, arguments);\n\n            if (a == null) {\n              return b;\n            } else if (b == null) {\n              return a;\n            }\n\n            var c = {};\n            mergeIntoWithNoDuplicateKeys(c, a);\n            mergeIntoWithNoDuplicateKeys(c, b);\n            return c;\n          };\n        }\n        /**\n         * Creates a function that invokes two functions and ignores their return vales.\n         *\n         * @param {function} one Function to invoke first.\n         * @param {function} two Function to invoke second.\n         * @return {function} Function that invokes the two argument functions.\n         * @private\n         */\n\n\n        function createChainedFunction(one, two) {\n          return function chainedFunction() {\n            one.apply(this, arguments);\n            two.apply(this, arguments);\n          };\n        }\n        /**\n         * Binds a method to the component.\n         *\n         * @param {object} component Component whose method is going to be bound.\n         * @param {function} method Method to be bound.\n         * @return {function} The bound method.\n         */\n\n\n        function bindAutoBindMethod(component, method) {\n          var boundMethod = method.bind(component);\n\n          if (process.env.NODE_ENV !== 'production') {\n            boundMethod.__reactBoundContext = component;\n            boundMethod.__reactBoundMethod = method;\n            boundMethod.__reactBoundArguments = null;\n            var componentName = component.constructor.displayName;\n            var _bind = boundMethod.bind;\n\n            boundMethod.bind = function (newThis) {\n              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              } // User is trying to bind() an autobound method; we effectively will\n              // ignore the value of \"this\" that the user is trying to use, so\n              // let's warn.\n\n\n              if (newThis !== component && newThis !== null) {\n                process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;\n              } else if (!args.length) {\n                process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;\n                return boundMethod;\n              }\n\n              var reboundMethod = _bind.apply(boundMethod, arguments);\n\n              reboundMethod.__reactBoundContext = component;\n              reboundMethod.__reactBoundMethod = method;\n              reboundMethod.__reactBoundArguments = args;\n              return reboundMethod;\n            };\n          }\n\n          return boundMethod;\n        }\n        /**\n         * Binds all auto-bound methods in a component.\n         *\n         * @param {object} component Component whose method is going to be bound.\n         */\n\n\n        function bindAutoBindMethods(component) {\n          var pairs = component.__reactAutoBindPairs;\n\n          for (var i = 0; i < pairs.length; i += 2) {\n            var autoBindKey = pairs[i];\n            var method = pairs[i + 1];\n            component[autoBindKey] = bindAutoBindMethod(component, method);\n          }\n        }\n        /**\n         * Add more to the ReactClass base class. These are all legacy features and\n         * therefore not already part of the modern ReactComponent.\n         */\n\n\n        var ReactClassMixin = {\n          /**\n           * TODO: This will be deprecated because state should always keep a consistent\n           * type signature and the only use case for this, is to avoid that.\n           */\n          replaceState: function (newState, callback) {\n            this.updater.enqueueReplaceState(this, newState);\n\n            if (callback) {\n              this.updater.enqueueCallback(this, callback, 'replaceState');\n            }\n          },\n\n          /**\n           * Checks whether or not this composite component is mounted.\n           * @return {boolean} True if mounted, false otherwise.\n           * @protected\n           * @final\n           */\n          isMounted: function () {\n            return this.updater.isMounted(this);\n          }\n        };\n\n        var ReactClassComponent = function () {};\n\n        _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);\n        /**\n         * Module for creating composite components.\n         *\n         * @class ReactClass\n         */\n\n\n        var ReactClass = {\n          /**\n           * Creates a composite component class given a class specification.\n           * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass\n           *\n           * @param {object} spec Class specification (which must define `render`).\n           * @return {function} Component constructor function.\n           * @public\n           */\n          createClass: function (spec) {\n            // To keep our warnings more understandable, we'll use a little hack here to\n            // ensure that Constructor.name !== 'Constructor'. This makes sure we don't\n            // unnecessarily identify a class without displayName as 'Constructor'.\n            var Constructor = identity(function (props, context, updater) {\n              // This constructor gets overridden by mocks. The argument is used\n              // by mocks to assert on what gets mounted.\n              if (process.env.NODE_ENV !== 'production') {\n                process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;\n              } // Wire up auto-binding\n\n\n              if (this.__reactAutoBindPairs.length) {\n                bindAutoBindMethods(this);\n              }\n\n              this.props = props;\n              this.context = context;\n              this.refs = emptyObject;\n              this.updater = updater || ReactNoopUpdateQueue;\n              this.state = null; // ReactClasses doesn't have constructors. Instead, they use the\n              // getInitialState and componentWillMount methods for initialization.\n\n              var initialState = this.getInitialState ? this.getInitialState() : null;\n\n              if (process.env.NODE_ENV !== 'production') {\n                // We allow auto-mocks to proceed as if they're returning null.\n                if (initialState === undefined && this.getInitialState._isMockFunction) {\n                  // This is probably bad practice. Consider warning here and\n                  // deprecating this convenience.\n                  initialState = null;\n                }\n              }\n\n              !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;\n              this.state = initialState;\n            });\n            Constructor.prototype = new ReactClassComponent();\n            Constructor.prototype.constructor = Constructor;\n            Constructor.prototype.__reactAutoBindPairs = [];\n            injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n            mixSpecIntoComponent(Constructor, spec); // Initialize the defaultProps property after all mixins have been merged.\n\n            if (Constructor.getDefaultProps) {\n              Constructor.defaultProps = Constructor.getDefaultProps();\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              // This is a tag to indicate that the use of these method names is ok,\n              // since it's used with createClass. If it's not, then it's likely a\n              // mistake so we'll warn you to use the static property, property\n              // initializer or constructor respectively.\n              if (Constructor.getDefaultProps) {\n                Constructor.getDefaultProps.isReactClassApproved = {};\n              }\n\n              if (Constructor.prototype.getInitialState) {\n                Constructor.prototype.getInitialState.isReactClassApproved = {};\n              }\n            }\n\n            !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;\n\n            if (process.env.NODE_ENV !== 'production') {\n              process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;\n              process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;\n            } // Reduce time spent doing lookups by setting these on the prototype.\n\n\n            for (var methodName in ReactClassInterface) {\n              if (!Constructor.prototype[methodName]) {\n                Constructor.prototype[methodName] = null;\n              }\n            }\n\n            return Constructor;\n          },\n          injection: {\n            injectMixin: function (mixin) {\n              injectedMixins.push(mixin);\n            }\n          }\n        };\n        module.exports = ReactClass;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 24 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        * \n        */\n        'use strict';\n\n        var ReactPropTypeLocationNames = {};\n\n        if (process.env.NODE_ENV !== 'production') {\n          ReactPropTypeLocationNames = {\n            prop: 'prop',\n            context: 'context',\n            childContext: 'child context'\n          };\n        }\n\n        module.exports = ReactPropTypeLocationNames;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 25 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var ReactElement = __webpack_require__(10);\n        /**\n         * Create a factory that creates HTML tag elements.\n         *\n         * @private\n         */\n\n\n        var createDOMFactory = ReactElement.createFactory;\n\n        if (process.env.NODE_ENV !== 'production') {\n          var ReactElementValidator = __webpack_require__(26);\n\n          createDOMFactory = ReactElementValidator.createFactory;\n        }\n        /**\n         * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.\n         * This is also accessible via `React.DOM`.\n         *\n         * @public\n         */\n\n\n        var ReactDOMFactories = {\n          a: createDOMFactory('a'),\n          abbr: createDOMFactory('abbr'),\n          address: createDOMFactory('address'),\n          area: createDOMFactory('area'),\n          article: createDOMFactory('article'),\n          aside: createDOMFactory('aside'),\n          audio: createDOMFactory('audio'),\n          b: createDOMFactory('b'),\n          base: createDOMFactory('base'),\n          bdi: createDOMFactory('bdi'),\n          bdo: createDOMFactory('bdo'),\n          big: createDOMFactory('big'),\n          blockquote: createDOMFactory('blockquote'),\n          body: createDOMFactory('body'),\n          br: createDOMFactory('br'),\n          button: createDOMFactory('button'),\n          canvas: createDOMFactory('canvas'),\n          caption: createDOMFactory('caption'),\n          cite: createDOMFactory('cite'),\n          code: createDOMFactory('code'),\n          col: createDOMFactory('col'),\n          colgroup: createDOMFactory('colgroup'),\n          data: createDOMFactory('data'),\n          datalist: createDOMFactory('datalist'),\n          dd: createDOMFactory('dd'),\n          del: createDOMFactory('del'),\n          details: createDOMFactory('details'),\n          dfn: createDOMFactory('dfn'),\n          dialog: createDOMFactory('dialog'),\n          div: createDOMFactory('div'),\n          dl: createDOMFactory('dl'),\n          dt: createDOMFactory('dt'),\n          em: createDOMFactory('em'),\n          embed: createDOMFactory('embed'),\n          fieldset: createDOMFactory('fieldset'),\n          figcaption: createDOMFactory('figcaption'),\n          figure: createDOMFactory('figure'),\n          footer: createDOMFactory('footer'),\n          form: createDOMFactory('form'),\n          h1: createDOMFactory('h1'),\n          h2: createDOMFactory('h2'),\n          h3: createDOMFactory('h3'),\n          h4: createDOMFactory('h4'),\n          h5: createDOMFactory('h5'),\n          h6: createDOMFactory('h6'),\n          head: createDOMFactory('head'),\n          header: createDOMFactory('header'),\n          hgroup: createDOMFactory('hgroup'),\n          hr: createDOMFactory('hr'),\n          html: createDOMFactory('html'),\n          i: createDOMFactory('i'),\n          iframe: createDOMFactory('iframe'),\n          img: createDOMFactory('img'),\n          input: createDOMFactory('input'),\n          ins: createDOMFactory('ins'),\n          kbd: createDOMFactory('kbd'),\n          keygen: createDOMFactory('keygen'),\n          label: createDOMFactory('label'),\n          legend: createDOMFactory('legend'),\n          li: createDOMFactory('li'),\n          link: createDOMFactory('link'),\n          main: createDOMFactory('main'),\n          map: createDOMFactory('map'),\n          mark: createDOMFactory('mark'),\n          menu: createDOMFactory('menu'),\n          menuitem: createDOMFactory('menuitem'),\n          meta: createDOMFactory('meta'),\n          meter: createDOMFactory('meter'),\n          nav: createDOMFactory('nav'),\n          noscript: createDOMFactory('noscript'),\n          object: createDOMFactory('object'),\n          ol: createDOMFactory('ol'),\n          optgroup: createDOMFactory('optgroup'),\n          option: createDOMFactory('option'),\n          output: createDOMFactory('output'),\n          p: createDOMFactory('p'),\n          param: createDOMFactory('param'),\n          picture: createDOMFactory('picture'),\n          pre: createDOMFactory('pre'),\n          progress: createDOMFactory('progress'),\n          q: createDOMFactory('q'),\n          rp: createDOMFactory('rp'),\n          rt: createDOMFactory('rt'),\n          ruby: createDOMFactory('ruby'),\n          s: createDOMFactory('s'),\n          samp: createDOMFactory('samp'),\n          script: createDOMFactory('script'),\n          section: createDOMFactory('section'),\n          select: createDOMFactory('select'),\n          small: createDOMFactory('small'),\n          source: createDOMFactory('source'),\n          span: createDOMFactory('span'),\n          strong: createDOMFactory('strong'),\n          style: createDOMFactory('style'),\n          sub: createDOMFactory('sub'),\n          summary: createDOMFactory('summary'),\n          sup: createDOMFactory('sup'),\n          table: createDOMFactory('table'),\n          tbody: createDOMFactory('tbody'),\n          td: createDOMFactory('td'),\n          textarea: createDOMFactory('textarea'),\n          tfoot: createDOMFactory('tfoot'),\n          th: createDOMFactory('th'),\n          thead: createDOMFactory('thead'),\n          time: createDOMFactory('time'),\n          title: createDOMFactory('title'),\n          tr: createDOMFactory('tr'),\n          track: createDOMFactory('track'),\n          u: createDOMFactory('u'),\n          ul: createDOMFactory('ul'),\n          'var': createDOMFactory('var'),\n          video: createDOMFactory('video'),\n          wbr: createDOMFactory('wbr'),\n          // SVG\n          circle: createDOMFactory('circle'),\n          clipPath: createDOMFactory('clipPath'),\n          defs: createDOMFactory('defs'),\n          ellipse: createDOMFactory('ellipse'),\n          g: createDOMFactory('g'),\n          image: createDOMFactory('image'),\n          line: createDOMFactory('line'),\n          linearGradient: createDOMFactory('linearGradient'),\n          mask: createDOMFactory('mask'),\n          path: createDOMFactory('path'),\n          pattern: createDOMFactory('pattern'),\n          polygon: createDOMFactory('polygon'),\n          polyline: createDOMFactory('polyline'),\n          radialGradient: createDOMFactory('radialGradient'),\n          rect: createDOMFactory('rect'),\n          stop: createDOMFactory('stop'),\n          svg: createDOMFactory('svg'),\n          text: createDOMFactory('text'),\n          tspan: createDOMFactory('tspan')\n        };\n        module.exports = ReactDOMFactories;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 26 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2014-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n\n        /**\n         * ReactElementValidator provides a wrapper around a element factory\n         * which validates the props passed to the element. This is intended to be\n         * used only in DEV and could be replaced by a static type checker for languages\n         * that support it.\n         */\n        'use strict';\n\n        var ReactCurrentOwner = __webpack_require__(11);\n\n        var ReactComponentTreeHook = __webpack_require__(27);\n\n        var ReactElement = __webpack_require__(10);\n\n        var checkReactTypeSpec = __webpack_require__(28);\n\n        var canDefineProperty = __webpack_require__(14);\n\n        var getIteratorFn = __webpack_require__(17);\n\n        var warning = __webpack_require__(12);\n\n        function getDeclarationErrorAddendum() {\n          if (ReactCurrentOwner.current) {\n            var name = ReactCurrentOwner.current.getName();\n\n            if (name) {\n              return ' Check the render method of `' + name + '`.';\n            }\n          }\n\n          return '';\n        }\n        /**\n         * Warn if there's no key explicitly set on dynamic arrays of children or\n         * object keys are not valid. This allows us to keep track of children between\n         * updates.\n         */\n\n\n        var ownerHasKeyUseWarning = {};\n\n        function getCurrentComponentErrorInfo(parentType) {\n          var info = getDeclarationErrorAddendum();\n\n          if (!info) {\n            var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n            if (parentName) {\n              info = ' Check the top-level render call using <' + parentName + '>.';\n            }\n          }\n\n          return info;\n        }\n        /**\n         * Warn if the element doesn't have an explicit key assigned to it.\n         * This element is in an array. The array could grow and shrink or be\n         * reordered. All children that haven't already been validated are required to\n         * have a \"key\" property assigned to it. Error statuses are cached so a warning\n         * will only be shown once.\n         *\n         * @internal\n         * @param {ReactElement} element Element that requires a key.\n         * @param {*} parentType element's parent's type.\n         */\n\n\n        function validateExplicitKey(element, parentType) {\n          if (!element._store || element._store.validated || element.key != null) {\n            return;\n          }\n\n          element._store.validated = true;\n          var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});\n          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n          if (memoizer[currentComponentErrorInfo]) {\n            return;\n          }\n\n          memoizer[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n          // property, it may be the creator of the child that's responsible for\n          // assigning it a key.\n\n          var childOwner = '';\n\n          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n            // Give the component that originally created this child.\n            childOwner = ' It was passed a child from ' + element._owner.getName() + '.';\n          }\n\n          process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;\n        }\n        /**\n         * Ensure that every element either is passed in a static location, in an\n         * array with an explicit keys property defined, or in an object literal\n         * with valid key property.\n         *\n         * @internal\n         * @param {ReactNode} node Statically passed child of any type.\n         * @param {*} parentType node's parent's type.\n         */\n\n\n        function validateChildKeys(node, parentType) {\n          if (typeof node !== 'object') {\n            return;\n          }\n\n          if (Array.isArray(node)) {\n            for (var i = 0; i < node.length; i++) {\n              var child = node[i];\n\n              if (ReactElement.isValidElement(child)) {\n                validateExplicitKey(child, parentType);\n              }\n            }\n          } else if (ReactElement.isValidElement(node)) {\n            // This element was passed in a valid location.\n            if (node._store) {\n              node._store.validated = true;\n            }\n          } else if (node) {\n            var iteratorFn = getIteratorFn(node); // Entry iterators provide implicit keys.\n\n            if (iteratorFn) {\n              if (iteratorFn !== node.entries) {\n                var iterator = iteratorFn.call(node);\n                var step;\n\n                while (!(step = iterator.next()).done) {\n                  if (ReactElement.isValidElement(step.value)) {\n                    validateExplicitKey(step.value, parentType);\n                  }\n                }\n              }\n            }\n          }\n        }\n        /**\n         * Given an element, validate that its props follow the propTypes definition,\n         * provided by the type.\n         *\n         * @param {ReactElement} element\n         */\n\n\n        function validatePropTypes(element) {\n          var componentClass = element.type;\n\n          if (typeof componentClass !== 'function') {\n            return;\n          }\n\n          var name = componentClass.displayName || componentClass.name;\n\n          if (componentClass.propTypes) {\n            checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);\n          }\n\n          if (typeof componentClass.getDefaultProps === 'function') {\n            process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\n          }\n        }\n\n        var ReactElementValidator = {\n          createElement: function (type, props, children) {\n            var validType = typeof type === 'string' || typeof type === 'function'; // We warn in this case but don't throw. We expect the element creation to\n            // succeed and there will likely be errors in render.\n\n            if (!validType) {\n              if (typeof type !== 'function' && typeof type !== 'string') {\n                var info = '';\n\n                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n                  info += ' You likely forgot to export your component from the file ' + 'it\\'s defined in.';\n                }\n\n                info += getDeclarationErrorAddendum();\n                process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;\n              }\n            }\n\n            var element = ReactElement.createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n            // TODO: Drop this when these are no longer allowed as the type argument.\n\n            if (element == null) {\n              return element;\n            } // Skip key warning if the type isn't valid since our key validation logic\n            // doesn't expect a non-string/function type and can throw confusing errors.\n            // We don't want exception behavior to differ between dev and prod.\n            // (Rendering will throw with a helpful message and as soon as the type is\n            // fixed, the key warnings will appear.)\n\n\n            if (validType) {\n              for (var i = 2; i < arguments.length; i++) {\n                validateChildKeys(arguments[i], type);\n              }\n            }\n\n            validatePropTypes(element);\n            return element;\n          },\n          createFactory: function (type) {\n            var validatedFactory = ReactElementValidator.createElement.bind(null, type); // Legacy hook TODO: Warn if this is accessed\n\n            validatedFactory.type = type;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (canDefineProperty) {\n                Object.defineProperty(validatedFactory, 'type', {\n                  enumerable: false,\n                  get: function () {\n                    process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;\n                    Object.defineProperty(this, 'type', {\n                      value: type\n                    });\n                    return type;\n                  }\n                });\n              }\n            }\n\n            return validatedFactory;\n          },\n          cloneElement: function (element, props, children) {\n            var newElement = ReactElement.cloneElement.apply(this, arguments);\n\n            for (var i = 2; i < arguments.length; i++) {\n              validateChildKeys(arguments[i], newElement.type);\n            }\n\n            validatePropTypes(newElement);\n            return newElement;\n          }\n        };\n        module.exports = ReactElementValidator;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 27 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2016-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        * \n        */\n        'use strict';\n\n        var _prodInvariant = __webpack_require__(8);\n\n        var ReactCurrentOwner = __webpack_require__(11);\n\n        var invariant = __webpack_require__(9);\n\n        var warning = __webpack_require__(12);\n\n        function isNative(fn) {\n          // Based on isNative() from Lodash\n          var funcToString = Function.prototype.toString;\n          var hasOwnProperty = Object.prototype.hasOwnProperty;\n          var reIsNative = RegExp('^' + funcToString // Take an example native function source for comparison\n          .call(hasOwnProperty) // Strip regex characters so we can use it for regex\n          .replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&') // Remove hasOwnProperty from the template to make it generic\n          .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n\n          try {\n            var source = funcToString.call(fn);\n            return reIsNative.test(source);\n          } catch (err) {\n            return false;\n          }\n        }\n\n        var canUseCollections = // Array.from\n        typeof Array.from === 'function' && // Map\n        typeof Map === 'function' && isNative(Map) && // Map.prototype.keys\n        Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) && // Set\n        typeof Set === 'function' && isNative(Set) && // Set.prototype.keys\n        Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);\n        var setItem;\n        var getItem;\n        var removeItem;\n        var getItemIDs;\n        var addRoot;\n        var removeRoot;\n        var getRootIDs;\n\n        if (canUseCollections) {\n          var itemMap = new Map();\n          var rootIDSet = new Set();\n\n          setItem = function (id, item) {\n            itemMap.set(id, item);\n          };\n\n          getItem = function (id) {\n            return itemMap.get(id);\n          };\n\n          removeItem = function (id) {\n            itemMap['delete'](id);\n          };\n\n          getItemIDs = function () {\n            return Array.from(itemMap.keys());\n          };\n\n          addRoot = function (id) {\n            rootIDSet.add(id);\n          };\n\n          removeRoot = function (id) {\n            rootIDSet['delete'](id);\n          };\n\n          getRootIDs = function () {\n            return Array.from(rootIDSet.keys());\n          };\n        } else {\n          var itemByKey = {};\n          var rootByKey = {}; // Use non-numeric keys to prevent V8 performance issues:\n          // https://github.com/facebook/react/pull/7232\n\n          var getKeyFromID = function (id) {\n            return '.' + id;\n          };\n\n          var getIDFromKey = function (key) {\n            return parseInt(key.substr(1), 10);\n          };\n\n          setItem = function (id, item) {\n            var key = getKeyFromID(id);\n            itemByKey[key] = item;\n          };\n\n          getItem = function (id) {\n            var key = getKeyFromID(id);\n            return itemByKey[key];\n          };\n\n          removeItem = function (id) {\n            var key = getKeyFromID(id);\n            delete itemByKey[key];\n          };\n\n          getItemIDs = function () {\n            return Object.keys(itemByKey).map(getIDFromKey);\n          };\n\n          addRoot = function (id) {\n            var key = getKeyFromID(id);\n            rootByKey[key] = true;\n          };\n\n          removeRoot = function (id) {\n            var key = getKeyFromID(id);\n            delete rootByKey[key];\n          };\n\n          getRootIDs = function () {\n            return Object.keys(rootByKey).map(getIDFromKey);\n          };\n        }\n\n        var unmountedIDs = [];\n\n        function purgeDeep(id) {\n          var item = getItem(id);\n\n          if (item) {\n            var childIDs = item.childIDs;\n            removeItem(id);\n            childIDs.forEach(purgeDeep);\n          }\n        }\n\n        function describeComponentFrame(name, source, ownerName) {\n          return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n        }\n\n        function getDisplayName(element) {\n          if (element == null) {\n            return '#empty';\n          } else if (typeof element === 'string' || typeof element === 'number') {\n            return '#text';\n          } else if (typeof element.type === 'string') {\n            return element.type;\n          } else {\n            return element.type.displayName || element.type.name || 'Unknown';\n          }\n        }\n\n        function describeID(id) {\n          var name = ReactComponentTreeHook.getDisplayName(id);\n          var element = ReactComponentTreeHook.getElement(id);\n          var ownerID = ReactComponentTreeHook.getOwnerID(id);\n          var ownerName;\n\n          if (ownerID) {\n            ownerName = ReactComponentTreeHook.getDisplayName(ownerID);\n          }\n\n          process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;\n          return describeComponentFrame(name, element && element._source, ownerName);\n        }\n\n        var ReactComponentTreeHook = {\n          onSetChildren: function (id, nextChildIDs) {\n            var item = getItem(id);\n            !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;\n            item.childIDs = nextChildIDs;\n\n            for (var i = 0; i < nextChildIDs.length; i++) {\n              var nextChildID = nextChildIDs[i];\n              var nextChild = getItem(nextChildID);\n              !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;\n              !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;\n              !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;\n\n              if (nextChild.parentID == null) {\n                nextChild.parentID = id; // TODO: This shouldn't be necessary but mounting a new root during in\n                // componentWillMount currently causes not-yet-mounted components to\n                // be purged from our tree data so their parent id is missing.\n              }\n\n              !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;\n            }\n          },\n          onBeforeMountComponent: function (id, element, parentID) {\n            var item = {\n              element: element,\n              parentID: parentID,\n              text: null,\n              childIDs: [],\n              isMounted: false,\n              updateCount: 0\n            };\n            setItem(id, item);\n          },\n          onBeforeUpdateComponent: function (id, element) {\n            var item = getItem(id);\n\n            if (!item || !item.isMounted) {\n              // We may end up here as a result of setState() in componentWillUnmount().\n              // In this case, ignore the element.\n              return;\n            }\n\n            item.element = element;\n          },\n          onMountComponent: function (id) {\n            var item = getItem(id);\n            !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;\n            item.isMounted = true;\n            var isRoot = item.parentID === 0;\n\n            if (isRoot) {\n              addRoot(id);\n            }\n          },\n          onUpdateComponent: function (id) {\n            var item = getItem(id);\n\n            if (!item || !item.isMounted) {\n              // We may end up here as a result of setState() in componentWillUnmount().\n              // In this case, ignore the element.\n              return;\n            }\n\n            item.updateCount++;\n          },\n          onUnmountComponent: function (id) {\n            var item = getItem(id);\n\n            if (item) {\n              // We need to check if it exists.\n              // `item` might not exist if it is inside an error boundary, and a sibling\n              // error boundary child threw while mounting. Then this instance never\n              // got a chance to mount, but it still gets an unmounting event during\n              // the error boundary cleanup.\n              item.isMounted = false;\n              var isRoot = item.parentID === 0;\n\n              if (isRoot) {\n                removeRoot(id);\n              }\n            }\n\n            unmountedIDs.push(id);\n          },\n          purgeUnmountedComponents: function () {\n            if (ReactComponentTreeHook._preventPurging) {\n              // Should only be used for testing.\n              return;\n            }\n\n            for (var i = 0; i < unmountedIDs.length; i++) {\n              var id = unmountedIDs[i];\n              purgeDeep(id);\n            }\n\n            unmountedIDs.length = 0;\n          },\n          isMounted: function (id) {\n            var item = getItem(id);\n            return item ? item.isMounted : false;\n          },\n          getCurrentStackAddendum: function (topElement) {\n            var info = '';\n\n            if (topElement) {\n              var name = getDisplayName(topElement);\n              var owner = topElement._owner;\n              info += describeComponentFrame(name, topElement._source, owner && owner.getName());\n            }\n\n            var currentOwner = ReactCurrentOwner.current;\n            var id = currentOwner && currentOwner._debugID;\n            info += ReactComponentTreeHook.getStackAddendumByID(id);\n            return info;\n          },\n          getStackAddendumByID: function (id) {\n            var info = '';\n\n            while (id) {\n              info += describeID(id);\n              id = ReactComponentTreeHook.getParentID(id);\n            }\n\n            return info;\n          },\n          getChildIDs: function (id) {\n            var item = getItem(id);\n            return item ? item.childIDs : [];\n          },\n          getDisplayName: function (id) {\n            var element = ReactComponentTreeHook.getElement(id);\n\n            if (!element) {\n              return null;\n            }\n\n            return getDisplayName(element);\n          },\n          getElement: function (id) {\n            var item = getItem(id);\n            return item ? item.element : null;\n          },\n          getOwnerID: function (id) {\n            var element = ReactComponentTreeHook.getElement(id);\n\n            if (!element || !element._owner) {\n              return null;\n            }\n\n            return element._owner._debugID;\n          },\n          getParentID: function (id) {\n            var item = getItem(id);\n            return item ? item.parentID : null;\n          },\n          getSource: function (id) {\n            var item = getItem(id);\n            var element = item ? item.element : null;\n            var source = element != null ? element._source : null;\n            return source;\n          },\n          getText: function (id) {\n            var element = ReactComponentTreeHook.getElement(id);\n\n            if (typeof element === 'string') {\n              return element;\n            } else if (typeof element === 'number') {\n              return '' + element;\n            } else {\n              return null;\n            }\n          },\n          getUpdateCount: function (id) {\n            var item = getItem(id);\n            return item ? item.updateCount : 0;\n          },\n          getRootIDs: getRootIDs,\n          getRegisteredIDs: getItemIDs\n        };\n        module.exports = ReactComponentTreeHook;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 28 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var _prodInvariant = __webpack_require__(8);\n\n        var ReactPropTypeLocationNames = __webpack_require__(24);\n\n        var ReactPropTypesSecret = __webpack_require__(29);\n\n        var invariant = __webpack_require__(9);\n\n        var warning = __webpack_require__(12);\n\n        var ReactComponentTreeHook;\n\n        if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {\n          // Temporary hack.\n          // Inline requires don't work well with Jest:\n          // https://github.com/facebook/react/issues/7240\n          // Remove the inline requires when we don't need them anymore:\n          // https://github.com/facebook/react/pull/7178\n          ReactComponentTreeHook = __webpack_require__(27);\n        }\n\n        var loggedTypeFailures = {};\n        /**\n         * Assert that the values match with the type specs.\n         * Error messages are memorized and will only be shown once.\n         *\n         * @param {object} typeSpecs Map of name to a ReactPropType\n         * @param {object} values Runtime values that need to be type-checked\n         * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n         * @param {string} componentName Name of the component for error messages.\n         * @param {?object} element The React element that is being type-checked\n         * @param {?number} debugID The React component instance that is being type-checked\n         * @private\n         */\n\n        function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {\n          for (var typeSpecName in typeSpecs) {\n            if (typeSpecs.hasOwnProperty(typeSpecName)) {\n              var error; // Prop type validation may throw. In case they do, we don't want to\n              // fail the render phase where it didn't fail before. So we log it.\n              // After these have been cleaned up, we'll let them throw.\n\n              try {\n                // This is intentionally an invariant that gets caught. It's the same\n                // behavior as without this statement except with a better message.\n                !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;\n                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n              } catch (ex) {\n                error = ex;\n              }\n\n              process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;\n\n              if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                // Only monitor this failure once because there tends to be a lot of the\n                // same error.\n                loggedTypeFailures[error.message] = true;\n                var componentStackInfo = '';\n\n                if (process.env.NODE_ENV !== 'production') {\n                  if (!ReactComponentTreeHook) {\n                    ReactComponentTreeHook = __webpack_require__(27);\n                  }\n\n                  if (debugID !== null) {\n                    componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);\n                  } else if (element !== null) {\n                    componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);\n                  }\n                }\n\n                process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;\n              }\n            }\n          }\n        }\n\n        module.exports = checkReactTypeSpec;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 29 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       * \n       */\n      'use strict';\n\n      var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n      module.exports = ReactPropTypesSecret;\n      /***/\n    },\n    /* 30 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var ReactElement = __webpack_require__(10);\n\n        var ReactPropTypeLocationNames = __webpack_require__(24);\n\n        var ReactPropTypesSecret = __webpack_require__(29);\n\n        var emptyFunction = __webpack_require__(13);\n\n        var getIteratorFn = __webpack_require__(17);\n\n        var warning = __webpack_require__(12);\n        /**\n         * Collection of methods that allow declaration and validation of props that are\n         * supplied to React components. Example usage:\n         *\n         *   var Props = require('ReactPropTypes');\n         *   var MyArticle = React.createClass({\n         *     propTypes: {\n         *       // An optional string prop named \"description\".\n         *       description: Props.string,\n         *\n         *       // A required enum prop named \"category\".\n         *       category: Props.oneOf(['News','Photos']).isRequired,\n         *\n         *       // A prop named \"dialog\" that requires an instance of Dialog.\n         *       dialog: Props.instanceOf(Dialog).isRequired\n         *     },\n         *     render: function() { ... }\n         *   });\n         *\n         * A more formal specification of how these methods are used:\n         *\n         *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n         *   decl := ReactPropTypes.{type}(.isRequired)?\n         *\n         * Each and every declaration produces a function with the same signature. This\n         * allows the creation of custom validation functions. For example:\n         *\n         *  var MyLink = React.createClass({\n         *    propTypes: {\n         *      // An optional string or URI prop named \"href\".\n         *      href: function(props, propName, componentName) {\n         *        var propValue = props[propName];\n         *        if (propValue != null && typeof propValue !== 'string' &&\n         *            !(propValue instanceof URI)) {\n         *          return new Error(\n         *            'Expected a string or an URI for ' + propName + ' in ' +\n         *            componentName\n         *          );\n         *        }\n         *      }\n         *    },\n         *    render: function() {...}\n         *  });\n         *\n         * @internal\n         */\n\n\n        var ANONYMOUS = '<<anonymous>>';\n        var ReactPropTypes = {\n          array: createPrimitiveTypeChecker('array'),\n          bool: createPrimitiveTypeChecker('boolean'),\n          func: createPrimitiveTypeChecker('function'),\n          number: createPrimitiveTypeChecker('number'),\n          object: createPrimitiveTypeChecker('object'),\n          string: createPrimitiveTypeChecker('string'),\n          symbol: createPrimitiveTypeChecker('symbol'),\n          any: createAnyTypeChecker(),\n          arrayOf: createArrayOfTypeChecker,\n          element: createElementTypeChecker(),\n          instanceOf: createInstanceTypeChecker,\n          node: createNodeChecker(),\n          objectOf: createObjectOfTypeChecker,\n          oneOf: createEnumTypeChecker,\n          oneOfType: createUnionTypeChecker,\n          shape: createShapeTypeChecker\n        };\n        /**\n         * inlined Object.is polyfill to avoid requiring consumers ship their own\n         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n         */\n\n        /*eslint-disable no-self-compare*/\n\n        function is(x, y) {\n          // SameValue algorithm\n          if (x === y) {\n            // Steps 1-5, 7-10\n            // Steps 6.b-6.e: +0 != -0\n            return x !== 0 || 1 / x === 1 / y;\n          } else {\n            // Step 6.a: NaN == NaN\n            return x !== x && y !== y;\n          }\n        }\n        /*eslint-enable no-self-compare*/\n\n        /**\n         * We use an Error-like object for backward compatibility as people may call\n         * PropTypes directly and inspect their output. However we don't use real\n         * Errors anymore. We don't inspect their stack anyway, and creating them\n         * is prohibitively expensive if they are created too often, such as what\n         * happens in oneOfType() for any type before the one that matched.\n         */\n\n\n        function PropTypeError(message) {\n          this.message = message;\n          this.stack = '';\n        } // Make `instanceof Error` still work for returned errors.\n\n\n        PropTypeError.prototype = Error.prototype;\n\n        function createChainableTypeChecker(validate) {\n          if (process.env.NODE_ENV !== 'production') {\n            var manualPropTypeCallCache = {};\n          }\n\n          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n            componentName = componentName || ANONYMOUS;\n            propFullName = propFullName || propName;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {\n                var cacheKey = componentName + ':' + propName;\n\n                if (!manualPropTypeCallCache[cacheKey]) {\n                  process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;\n                  manualPropTypeCallCache[cacheKey] = true;\n                }\n              }\n            }\n\n            if (props[propName] == null) {\n              var locationName = ReactPropTypeLocationNames[location];\n\n              if (isRequired) {\n                if (props[propName] === null) {\n                  return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n                }\n\n                return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n              }\n\n              return null;\n            } else {\n              return validate(props, propName, componentName, location, propFullName);\n            }\n          }\n\n          var chainedCheckType = checkType.bind(null, false);\n          chainedCheckType.isRequired = checkType.bind(null, true);\n          return chainedCheckType;\n        }\n\n        function createPrimitiveTypeChecker(expectedType) {\n          function validate(props, propName, componentName, location, propFullName, secret) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n\n            if (propType !== expectedType) {\n              var locationName = ReactPropTypeLocationNames[location]; // `propValue` being instance of, say, date/regexp, pass the 'object'\n              // check, but we can offer a more precise error message here rather than\n              // 'of type `object`'.\n\n              var preciseType = getPreciseType(propValue);\n              return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n            }\n\n            return null;\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function createAnyTypeChecker() {\n          return createChainableTypeChecker(emptyFunction.thatReturns(null));\n        }\n\n        function createArrayOfTypeChecker(typeChecker) {\n          function validate(props, propName, componentName, location, propFullName) {\n            if (typeof typeChecker !== 'function') {\n              return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n            }\n\n            var propValue = props[propName];\n\n            if (!Array.isArray(propValue)) {\n              var locationName = ReactPropTypeLocationNames[location];\n              var propType = getPropType(propValue);\n              return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n            }\n\n            for (var i = 0; i < propValue.length; i++) {\n              var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n\n              if (error instanceof Error) {\n                return error;\n              }\n            }\n\n            return null;\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function createElementTypeChecker() {\n          function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n\n            if (!ReactElement.isValidElement(propValue)) {\n              var locationName = ReactPropTypeLocationNames[location];\n              var propType = getPropType(propValue);\n              return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n            }\n\n            return null;\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function createInstanceTypeChecker(expectedClass) {\n          function validate(props, propName, componentName, location, propFullName) {\n            if (!(props[propName] instanceof expectedClass)) {\n              var locationName = ReactPropTypeLocationNames[location];\n              var expectedClassName = expectedClass.name || ANONYMOUS;\n              var actualClassName = getClassName(props[propName]);\n              return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n            }\n\n            return null;\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function createEnumTypeChecker(expectedValues) {\n          if (!Array.isArray(expectedValues)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\n            return emptyFunction.thatReturnsNull;\n          }\n\n          function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n\n            for (var i = 0; i < expectedValues.length; i++) {\n              if (is(propValue, expectedValues[i])) {\n                return null;\n              }\n            }\n\n            var locationName = ReactPropTypeLocationNames[location];\n            var valuesString = JSON.stringify(expectedValues);\n            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function createObjectOfTypeChecker(typeChecker) {\n          function validate(props, propName, componentName, location, propFullName) {\n            if (typeof typeChecker !== 'function') {\n              return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n            }\n\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n\n            if (propType !== 'object') {\n              var locationName = ReactPropTypeLocationNames[location];\n              return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n            }\n\n            for (var key in propValue) {\n              if (propValue.hasOwnProperty(key)) {\n                var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n\n                if (error instanceof Error) {\n                  return error;\n                }\n              }\n            }\n\n            return null;\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function createUnionTypeChecker(arrayOfTypeCheckers) {\n          if (!Array.isArray(arrayOfTypeCheckers)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\n            return emptyFunction.thatReturnsNull;\n          }\n\n          function validate(props, propName, componentName, location, propFullName) {\n            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n              var checker = arrayOfTypeCheckers[i];\n\n              if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n                return null;\n              }\n            }\n\n            var locationName = ReactPropTypeLocationNames[location];\n            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function createNodeChecker() {\n          function validate(props, propName, componentName, location, propFullName) {\n            if (!isNode(props[propName])) {\n              var locationName = ReactPropTypeLocationNames[location];\n              return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n            }\n\n            return null;\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function createShapeTypeChecker(shapeTypes) {\n          function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n\n            if (propType !== 'object') {\n              var locationName = ReactPropTypeLocationNames[location];\n              return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n            }\n\n            for (var key in shapeTypes) {\n              var checker = shapeTypes[key];\n\n              if (!checker) {\n                continue;\n              }\n\n              var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n\n              if (error) {\n                return error;\n              }\n            }\n\n            return null;\n          }\n\n          return createChainableTypeChecker(validate);\n        }\n\n        function isNode(propValue) {\n          switch (typeof propValue) {\n            case 'number':\n            case 'string':\n            case 'undefined':\n              return true;\n\n            case 'boolean':\n              return !propValue;\n\n            case 'object':\n              if (Array.isArray(propValue)) {\n                return propValue.every(isNode);\n              }\n\n              if (propValue === null || ReactElement.isValidElement(propValue)) {\n                return true;\n              }\n\n              var iteratorFn = getIteratorFn(propValue);\n\n              if (iteratorFn) {\n                var iterator = iteratorFn.call(propValue);\n                var step;\n\n                if (iteratorFn !== propValue.entries) {\n                  while (!(step = iterator.next()).done) {\n                    if (!isNode(step.value)) {\n                      return false;\n                    }\n                  }\n                } else {\n                  // Iterator will provide entry [k,v] tuples rather than values.\n                  while (!(step = iterator.next()).done) {\n                    var entry = step.value;\n\n                    if (entry) {\n                      if (!isNode(entry[1])) {\n                        return false;\n                      }\n                    }\n                  }\n                }\n              } else {\n                return false;\n              }\n\n              return true;\n\n            default:\n              return false;\n          }\n        }\n\n        function isSymbol(propType, propValue) {\n          // Native Symbol.\n          if (propType === 'symbol') {\n            return true;\n          } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n\n\n          if (propValue['@@toStringTag'] === 'Symbol') {\n            return true;\n          } // Fallback for non-spec compliant Symbols which are polyfilled.\n\n\n          if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n            return true;\n          }\n\n          return false;\n        } // Equivalent of `typeof` but with special handling for array and regexp.\n\n\n        function getPropType(propValue) {\n          var propType = typeof propValue;\n\n          if (Array.isArray(propValue)) {\n            return 'array';\n          }\n\n          if (propValue instanceof RegExp) {\n            // Old webkits (at least until Android 4.0) return 'function' rather than\n            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n            // passes PropTypes.object.\n            return 'object';\n          }\n\n          if (isSymbol(propType, propValue)) {\n            return 'symbol';\n          }\n\n          return propType;\n        } // This handles more types than `getPropType`. Only used for error messages.\n        // See `createPrimitiveTypeChecker`.\n\n\n        function getPreciseType(propValue) {\n          var propType = getPropType(propValue);\n\n          if (propType === 'object') {\n            if (propValue instanceof Date) {\n              return 'date';\n            } else if (propValue instanceof RegExp) {\n              return 'regexp';\n            }\n          }\n\n          return propType;\n        } // Returns class name of the object, if any.\n\n\n        function getClassName(propValue) {\n          if (!propValue.constructor || !propValue.constructor.name) {\n            return ANONYMOUS;\n          }\n\n          return propValue.constructor.name;\n        }\n\n        module.exports = ReactPropTypes;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 31 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       */\n      'use strict';\n\n      module.exports = '15.4.2';\n      /***/\n    },\n    /* 32 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        /**\n        * Copyright 2013-present, Facebook, Inc.\n        * All rights reserved.\n        *\n        * This source code is licensed under the BSD-style license found in the\n        * LICENSE file in the root directory of this source tree. An additional grant\n        * of patent rights can be found in the PATENTS file in the same directory.\n        *\n        */\n        'use strict';\n\n        var _prodInvariant = __webpack_require__(8);\n\n        var ReactElement = __webpack_require__(10);\n\n        var invariant = __webpack_require__(9);\n        /**\n         * Returns the first child in a collection of children and verifies that there\n         * is only one child in the collection.\n         *\n         * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only\n         *\n         * The current implementation of this function assumes that a single child gets\n         * passed without a wrapper, but the purpose of this helper function is to\n         * abstract away the particular structure of children.\n         *\n         * @param {?object} children Child collection structure.\n         * @return {ReactElement} The first and only `ReactElement` contained in the\n         * structure.\n         */\n\n\n        function onlyChild(children) {\n          !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;\n          return children;\n        }\n\n        module.exports = onlyChild;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(4));\n      /***/\n    },\n    /* 33 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _extractData = __webpack_require__(34);\n\n      var _extractData2 = _interopRequireDefault(_extractData);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      module.exports = function (nodes) {\n        // If nodes is a single element wrap it in an array for extractData to work properly\n        if (!Array.isArray(nodes)) nodes = [nodes]; // Extract all the relevant data for React createElement from each DOM node.\n\n        var reactData = (0, _extractData2.default)(nodes);\n        return reactData;\n      };\n      /***/\n\n    },\n    /* 34 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var _getStyles = __webpack_require__(35);\n\n      var _getStyles2 = _interopRequireDefault(_getStyles);\n\n      var _getAttributes = __webpack_require__(37);\n\n      var _getAttributes2 = _interopRequireDefault(_getAttributes);\n\n      var _applyD3ReactId = __webpack_require__(38);\n\n      var _applyD3ReactId2 = _interopRequireDefault(_applyD3ReactId);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      } // Maps over all the nodes and extracts all the data relevant to React\n      // Does not map over child elements of the nodes, this is done in recursive calls from makeChildNodes\n\n\n      module.exports = function (nodes) {\n        var extractedData = {\n          state: {},\n          mappedData: []\n        }; //Check if nodes is an array otherwise convert html objects into array\n\n        if (!Array.isArray(nodes)) {\n          nodes = Array.prototype.slice.call(nodes);\n        }\n\n        var mappedData = nodes.map(function (obj, i) {\n          var output = {};\n          var nodeId = {};\n\n          if (obj['__data__']) {\n            output['__data__'] = obj['__data__'];\n          }\n\n          if (obj['__transition__']) {\n            output['__transition__'] = obj['__transition__'];\n          } //HTML tag name ...div, g, circle, etc...\n\n\n          output.tag = obj.localName;\n          var sameTagIndex = i + document.getElementsByTagName(obj.localName).length;\n          var children = [];\n          var childNodes = obj.childNodes;\n\n          for (var _i = 0; _i < obj.childNodes.length; _i++) {\n            if (childNodes[_i].tagName) children.push(childNodes[_i]);\n          }\n\n          if (!obj['data-react-d3-id']) {\n            nodeId = (0, _applyD3ReactId2.default)(Array.prototype.slice.call(children), sameTagIndex);\n\n            for (var key in nodeId.state) {\n              extractedData.state[key] = nodeId.state[key];\n            }\n          } else {\n            nodeId.children = children;\n          } // Create an array for all the child nodes\n\n\n          output.children = nodeId.children; // Build the props object to be used in react createElement and convert into react friendly syntax\n\n          output.props = (0, _getAttributes2.default)(obj.attributes, obj); // If styles exits convert the CSSStyleDeclaration into react friendly syntax-\n\n          if (output.props.style) output.props.style = (0, _getStyles2.default)(output.props.style); // Special case for text and tspan tags\n\n          if (output.tag === 'text' || output.tag === 'tspan') {\n            output.props.textContent = obj.childNodes.length ? obj.childNodes[0].data : '';\n          } // output.props['react-d3-id'] = output.tag + '.' + counter + '.' + i;\\\n\n\n          if (!obj['data-react-d3-id']) {\n            output['data-react-d3-id'] = output.tag + '.' + sameTagIndex + '.' + 0 + '.' + 0;\n            output.props.key = output.tag + '.' + sameTagIndex + '.' + 0 + '.' + 0;\n            extractedData.state[output.tag + '.' + sameTagIndex + '.' + 0 + '.' + 0] = {};\n          } else {\n            output['data-react-d3-id'] = obj['data-react-d3-id'];\n            output.props.key = obj['data-react-d3-id'];\n          }\n\n          return output;\n        });\n        extractedData.mappedData = mappedData;\n        return extractedData;\n      };\n      /***/\n\n    },\n    /* 35 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var _toCamelCase = __webpack_require__(36);\n\n      var _toCamelCase2 = _interopRequireDefault(_toCamelCase);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      module.exports = function (styleObject) {\n        var styles = {};\n\n        if (typeof styleObject === 'string') {\n          var styleArray = styleObject.split(';');\n          styleArray.pop();\n          styleArray.forEach(function (style) {\n            var indexOfColon = style.indexOf(':');\n            var key = (0, _toCamelCase2.default)(style.slice(0, indexOfColon));\n            var value = style.slice(indexOfColon + 1);\n            value = isNaN(value) ? value.trim() : Number(value);\n            styles[key.trim()] = value;\n          });\n        } else {\n          for (var key in styleObject) {\n            if (!isNaN(key)) {\n              styles[styleObject[key]] = styleObject[styleObject[key]];\n            }\n          }\n        }\n\n        return styles;\n      };\n      /***/\n\n    },\n    /* 36 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (spinalCaseValue) {\n        return spinalCaseValue.replace(/-[a-zA-Z]/g, function (match) {\n          return match[1].toUpperCase();\n        });\n      };\n      /***/\n\n    },\n    /* 37 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var _toCamelCase = __webpack_require__(36);\n\n      var _toCamelCase2 = _interopRequireDefault(_toCamelCase);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      module.exports = function (attributesObject, node) {\n        var attributes = {};\n\n        for (var key in attributesObject) {\n          if (!isNaN(key)) {\n            if (attributesObject[key].localName === 'class') {\n              attributes['className'] = attributesObject[key].nodeValue;\n            } else if (attributesObject[key].localName.indexOf('-') > -1) {\n              var reactKey = (0, _toCamelCase2.default)(attributesObject[key].localName);\n              attributes[reactKey] = attributesObject[key].nodeValue;\n            } else attributes[attributesObject[key].localName] = attributesObject[key].nodeValue;\n          }\n        }\n\n        if (node['data-react-d3-id']) {\n          attributes['data-react-d3-id'] = node['data-react-d3-id'];\n        }\n\n        if (node['__transition__']) {\n          attributes['__transition__'] = node['__transition__'];\n        }\n\n        for (var _key in node) {\n          if (_key.slice(0, 2) === '__') attributes[_key] = node[_key];\n        }\n\n        return attributes;\n      };\n      /***/\n\n    },\n    /* 38 */\n\n    /***/\n    function (module, exports) {\n      function applyD3ReactId(children, counter) {\n        var count = -1;\n        var length = 0;\n        var childCount = 0;\n        var parentCount = 0;\n        var result = {\n          state: {},\n          children: []\n        };\n\n        function apply(parent) {\n          count++;\n          parent.forEach(function (child, i) {\n            var d3Attributes = Object.keys(child);\n            var id = child.localName + '.' + counter + '.' + parentCount + '.' + count;\n            var currentNode = child['data-react-d3-id'] = id;\n            var resultObj = result.state[id] = {};\n            if (child.childNodes.length) length = child.childNodes.length;\n            if (d3Attributes.length) d3Attributes.forEach(function (key) {\n              resultObj[key] = child[key];\n            });else resultObj['__data__'] = null;\n            if (count === length) count = 0, parentCount++;\n            return child.childNodes.length ? [].slice.call(child.childNodes).forEach(function (child) {\n              return apply([child]);\n            }) : [];\n          });\n        }\n\n        apply(children);\n        result.children = children;\n        return result;\n      }\n\n      module.exports = applyD3ReactId;\n      /***/\n    },\n    /* 39 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _createReactComponents = __webpack_require__(40);\n\n      var _createReactComponents2 = _interopRequireDefault(_createReactComponents);\n\n      var _applyData = __webpack_require__(42);\n\n      var _applyData2 = _interopRequireDefault(_applyData);\n\n      var _applyZoomData = __webpack_require__(43);\n\n      var _applyZoomData2 = _interopRequireDefault(_applyZoomData);\n\n      var _applyTransitionData = __webpack_require__(44);\n\n      var _applyTransitionData2 = _interopRequireDefault(_applyTransitionData);\n\n      var _applyChartData = __webpack_require__(45);\n\n      var _applyChartData2 = _interopRequireDefault(_applyChartData);\n\n      var _mountD3Functions = __webpack_require__(46);\n\n      var _mountD3Functions2 = _interopRequireDefault(_mountD3Functions);\n\n      var _registerOnListeners = __webpack_require__(47);\n\n      var _registerOnListeners2 = _interopRequireDefault(_registerOnListeners);\n\n      var _registerEventListeners = __webpack_require__(48);\n\n      var _registerEventListeners2 = _interopRequireDefault(_registerEventListeners);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var childComponent = function (_React$Component) {\n        _inherits(childComponent, _React$Component);\n\n        function childComponent(props) {\n          _classCallCheck(this, childComponent);\n\n          var _this = _possibleConstructorReturn(this, (childComponent.__proto__ || Object.getPrototypeOf(childComponent)).call(this, props));\n\n          _this.state = {\n            reactComponents: []\n          };\n          return _this;\n        }\n\n        _createClass(childComponent, [{\n          key: 'componentWillReceiveProps',\n          value: function componentWillReceiveProps(nextProps) {\n            var props = nextProps.data;\n            var reactComponents = (0, _createReactComponents2.default)(props.d3DOM, props.state, nextProps.getState);\n            this.setState({\n              reactComponents: reactComponents\n            });\n          }\n        }, {\n          key: 'componentDidUpdate',\n          value: function componentDidUpdate() {\n            var reactD3Elements = document.querySelectorAll('[data-react-d3-id]');\n            var state = this.props.data.state;\n\n            for (var i = 0; i < reactD3Elements.length; i++) {\n              var rd3Id = reactD3Elements[i].getAttribute('data-react-d3-id');\n              var that = this;\n              if (!state[rd3Id]) continue;\n              (0, _applyData2.default)(reactD3Elements, state, rd3Id, i);\n              (0, _applyZoomData2.default)(reactD3Elements, state, rd3Id, i);\n              (0, _applyTransitionData2.default)(reactD3Elements, state, rd3Id, i);\n              (0, _applyChartData2.default)(reactD3Elements, state, rd3Id, i);\n              (0, _mountD3Functions2.default)(state, rd3Id, that);\n              (0, _registerOnListeners2.default)(reactD3Elements, state, rd3Id, i);\n              (0, _registerEventListeners2.default)(reactD3Elements, state, rd3Id, i);\n            }\n          }\n        }, {\n          key: 'componentWillUnmount',\n          value: function componentWillUnmount() {\n            if (this.hasTimer) this.hasTimer = false;\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            return _react2.default.createElement('div', {\n              className: 'react-component'\n            }, this.state.reactComponents || '');\n          }\n        }]);\n\n        return childComponent;\n      }(_react2.default.Component);\n\n      module.exports = childComponent;\n      /***/\n    },\n    /* 40 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var _extractData = __webpack_require__(34);\n\n      var _extractData2 = _interopRequireDefault(_extractData);\n\n      var _passReactState = __webpack_require__(41);\n\n      var _passReactState2 = _interopRequireDefault(_passReactState);\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      } //Recursively create all nested React components with reactData\n      //Child elements are sent back back to extractData and then mapped over to be called recursively\n      //TextContent is always passed as a child, if null react ignores it\n\n\n      function makeChildNodes(reactData, stateData, getState) {\n        return reactData.map(function (obj, i) {\n          return obj.children.length === 0 ? _react2.default.createElement(obj.tag, (0, _passReactState2.default)(obj, stateData, getState), obj.props.textContent) : _react2.default.createElement(obj.tag, obj.props, (0, _extractData2.default)(obj.children).mappedData.map(function (obj) {\n            return makeChildNodes([obj], stateData, getState);\n          }));\n        });\n      }\n\n      module.exports = makeChildNodes;\n      /***/\n    },\n    /* 41 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (obj, stateData, getState) {\n        var reactId = obj.props['data-react-d3-id']; //Applies React Component State D3 Data to new React Elements from D3\n\n        if (stateData[reactId] instanceof Object) {\n          for (var key in stateData[reactId]) {\n            if (obj.props[key]) {\n              obj.props[key] = stateData[reactId][key];\n            }\n          }\n        }\n\n        return obj.props;\n      };\n      /***/\n\n    },\n    /* 42 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (reactD3Elements, state, rd3Id, i) {\n        if (state[rd3Id]['__data__'] !== null) {\n          reactD3Elements[i]['__data__'] = state[rd3Id]['__data__'];\n        }\n      };\n      /***/\n\n    },\n    /* 43 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (reactD3Elements, state, rd3Id, i) {\n        if (state[rd3Id]['__zoom']) {\n          reactD3Elements[i]['__zoom'] = state[rd3Id]['__zoom'];\n        }\n      };\n      /***/\n\n    },\n    /* 44 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (reactD3Elements, state, rd3Id, i) {\n        if (state[rd3Id]['__transition__']) {\n          reactD3Elements[i]['__transition__'] = state[rd3Id]['__transition__'];\n        }\n      };\n      /***/\n\n    },\n    /* 45 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (reactD3Elements, state, rd3Id, i) {\n        if (state[rd3Id]['__chart__']) {\n          reactD3Elements[i]['__chart__'] = state[rd3Id]['__chart__'];\n        }\n      };\n      /***/\n\n    },\n    /* 46 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (state, rd3Id, that) {\n        if (state[rd3Id]['__onmount']) {\n          (function () {\n            var callback = state[rd3Id]['__onmount'].bind(that);\n            setTimeout(function () {\n              callback();\n            }, 0);\n          })();\n        }\n      };\n      /***/\n\n    },\n    /* 47 */\n\n    /***/\n    function (module, exports) {\n      //register event listeners stored in __on\n      module.exports = function (reactD3Elements, state, rd3Id, i) {\n        if (state[rd3Id]['__on']) {\n          reactD3Elements[i]['__on'] = state[rd3Id]['__on'];\n\n          for (var j = 0; j < state[rd3Id]['__on'].length; j++) {\n            reactD3Elements[i].addEventListener(state[rd3Id]['__on'][j][\"type\"], state[rd3Id]['__on'][j][\"listener\"], state[rd3Id]['__on'][j][\"capture\"]);\n          }\n        }\n      };\n      /***/\n\n    },\n    /* 48 */\n\n    /***/\n    function (module, exports) {\n      //register all the event listeners\n      module.exports = function (reactD3Elements, state, rd3Id, i) {\n        for (var key in state[rd3Id]) {\n          if (key !== '__data__' && key !== '__zoom' && key !== '__onmount' && key !== '__transition__' && key !== '__chart__' && key !== 'data-react-d3-id') {\n            reactD3Elements[i][key] = state[rd3Id][key];\n            var index = key.indexOf('.');\n            var eventName = index > 0 ? key.slice(4, index) : key.slice(4);\n            reactD3Elements[i].addEventListener(eventName, state[rd3Id][key]);\n          }\n        }\n      };\n      /***/\n\n    },\n    /* 49 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _d3DataToJSX = __webpack_require__(33);\n\n      var _d3DataToJSX2 = _interopRequireDefault(_d3DataToJSX);\n\n      var _ChildComponent = __webpack_require__(39);\n\n      var _ChildComponent2 = _interopRequireDefault(_ChildComponent);\n\n      var _createAreaChart = __webpack_require__(50);\n\n      var _createAreaChart2 = _interopRequireDefault(_createAreaChart);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var _class = function (_React$Component) {\n        _inherits(_class, _React$Component);\n\n        function _class(props) {\n          _classCallCheck(this, _class);\n\n          var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));\n\n          _this.state = {\n            d3DOM: [],\n            state: []\n          };\n          return _this;\n        }\n\n        _createClass(_class, [{\n          key: 'componentWillReceiveProps',\n          value: function componentWillReceiveProps(nextProps) {\n            var d3Data = (0, _d3DataToJSX2.default)((0, _createAreaChart2.default)(nextProps.data));\n            this.setState({\n              d3DOM: d3Data.mappedData,\n              state: d3Data.state\n            });\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            return _react2.default.createElement('div', null, _react2.default.createElement(_ChildComponent2.default, {\n              data: this.state\n            }));\n          }\n        }]);\n\n        return _class;\n      }(_react2.default.Component);\n\n      exports.default = _class;\n      ;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 50 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _d = __webpack_require__(51);\n\n      var _d2 = _interopRequireDefault(_d);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var createAreaChart = function createAreaChart(data) {\n        var node = document.createElement('div');\n        var margin = {\n          top: 20,\n          right: 20,\n          bottom: 30,\n          left: 50\n        },\n            width = data.width - margin.left - margin.right,\n            height = data.height - margin.top - margin.bottom;\n\n        var x = _d2.default.scale.linear().range([0, width]);\n\n        var y = _d2.default.scale.linear().range([height, 0]);\n\n        var xAxis = _d2.default.svg.axis().scale(x).orient(\"bottom\");\n\n        var yAxis = _d2.default.svg.axis().scale(y).orient(\"left\");\n\n        var area = _d2.default.svg.area().x(function (d) {\n          return x(d.xValue);\n        }).y0(height).y1(function (d) {\n          return y(d.yValue);\n        });\n\n        var svg = _d2.default.select(node).append(\"svg\").attr(\"width\", width + margin.left + margin.right).attr(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n        data.dataSet.forEach(function (d) {\n          d.xValue = +d.xValue;\n          d.yValue = +d.yValue;\n        });\n        x.domain(_d2.default.extent(data.dataSet, function (d) {\n          return d.xValue;\n        }));\n        y.domain([0, _d2.default.max(data.dataSet, function (d) {\n          return d.yValue;\n        })]);\n        svg.append(\"path\").datum(data.dataSet).attr(\"class\", data.area_class).attr(\"d\", area);\n        svg.append(\"g\").attr(\"class\", \"x \" + data.axisLine_class).attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis).append(\"text\").attr(\"y\", 20).attr(\"dy\", \".71em\").style(\"text-anchor\", \"middle\").text(data.x_display_name);\n        svg.append(\"g\").attr(\"class\", \"y \" + data.axisLine_class).call(yAxis).append(\"text\").attr(\"transform\", \"rotate(-90)\").attr(\"y\", 6).attr(\"dy\", \".71em\").style(\"text-anchor\", \"end\").text(data.y_display_name);\n        return node;\n      };\n\n      exports.default = createAreaChart;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 51 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n      !function () {\n        var d3 = {\n          version: \"3.5.17\"\n        };\n\n        var d3_arraySlice = [].slice,\n            d3_array = function (list) {\n          return d3_arraySlice.call(list);\n        };\n\n        var d3_document = this.document;\n\n        function d3_documentElement(node) {\n          return node && (node.ownerDocument || node.document || node).documentElement;\n        }\n\n        function d3_window(node) {\n          return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);\n        }\n\n        if (d3_document) {\n          try {\n            d3_array(d3_document.documentElement.childNodes)[0].nodeType;\n          } catch (e) {\n            d3_array = function (list) {\n              var i = list.length,\n                  array = new Array(i);\n\n              while (i--) array[i] = list[i];\n\n              return array;\n            };\n          }\n        }\n\n        if (!Date.now) Date.now = function () {\n          return +new Date();\n        };\n\n        if (d3_document) {\n          try {\n            d3_document.createElement(\"DIV\").style.setProperty(\"opacity\", 0, \"\");\n          } catch (error) {\n            var d3_element_prototype = this.Element.prototype,\n                d3_element_setAttribute = d3_element_prototype.setAttribute,\n                d3_element_setAttributeNS = d3_element_prototype.setAttributeNS,\n                d3_style_prototype = this.CSSStyleDeclaration.prototype,\n                d3_style_setProperty = d3_style_prototype.setProperty;\n\n            d3_element_prototype.setAttribute = function (name, value) {\n              d3_element_setAttribute.call(this, name, value + \"\");\n            };\n\n            d3_element_prototype.setAttributeNS = function (space, local, value) {\n              d3_element_setAttributeNS.call(this, space, local, value + \"\");\n            };\n\n            d3_style_prototype.setProperty = function (name, value, priority) {\n              d3_style_setProperty.call(this, name, value + \"\", priority);\n            };\n          }\n        }\n\n        d3.ascending = d3_ascending;\n\n        function d3_ascending(a, b) {\n          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n        }\n\n        d3.descending = function (a, b) {\n          return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n        };\n\n        d3.min = function (array, f) {\n          var i = -1,\n              n = array.length,\n              a,\n              b;\n\n          if (arguments.length === 1) {\n            while (++i < n) if ((b = array[i]) != null && b >= b) {\n              a = b;\n              break;\n            }\n\n            while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n          } else {\n            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n              a = b;\n              break;\n            }\n\n            while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n          }\n\n          return a;\n        };\n\n        d3.max = function (array, f) {\n          var i = -1,\n              n = array.length,\n              a,\n              b;\n\n          if (arguments.length === 1) {\n            while (++i < n) if ((b = array[i]) != null && b >= b) {\n              a = b;\n              break;\n            }\n\n            while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n          } else {\n            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n              a = b;\n              break;\n            }\n\n            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n          }\n\n          return a;\n        };\n\n        d3.extent = function (array, f) {\n          var i = -1,\n              n = array.length,\n              a,\n              b,\n              c;\n\n          if (arguments.length === 1) {\n            while (++i < n) if ((b = array[i]) != null && b >= b) {\n              a = c = b;\n              break;\n            }\n\n            while (++i < n) if ((b = array[i]) != null) {\n              if (a > b) a = b;\n              if (c < b) c = b;\n            }\n          } else {\n            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n              a = c = b;\n              break;\n            }\n\n            while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n              if (a > b) a = b;\n              if (c < b) c = b;\n            }\n          }\n\n          return [a, c];\n        };\n\n        function d3_number(x) {\n          return x === null ? NaN : +x;\n        }\n\n        function d3_numeric(x) {\n          return !isNaN(x);\n        }\n\n        d3.sum = function (array, f) {\n          var s = 0,\n              n = array.length,\n              a,\n              i = -1;\n\n          if (arguments.length === 1) {\n            while (++i < n) if (d3_numeric(a = +array[i])) s += a;\n          } else {\n            while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;\n          }\n\n          return s;\n        };\n\n        d3.mean = function (array, f) {\n          var s = 0,\n              n = array.length,\n              a,\n              i = -1,\n              j = n;\n\n          if (arguments.length === 1) {\n            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a;else --j;\n          } else {\n            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a;else --j;\n          }\n\n          if (j) return s / j;\n        };\n\n        d3.quantile = function (values, p) {\n          var H = (values.length - 1) * p + 1,\n              h = Math.floor(H),\n              v = +values[h - 1],\n              e = H - h;\n          return e ? v + e * (values[h] - v) : v;\n        };\n\n        d3.median = function (array, f) {\n          var numbers = [],\n              n = array.length,\n              a,\n              i = -1;\n\n          if (arguments.length === 1) {\n            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);\n          } else {\n            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);\n          }\n\n          if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);\n        };\n\n        d3.variance = function (array, f) {\n          var n = array.length,\n              m = 0,\n              a,\n              d,\n              s = 0,\n              i = -1,\n              j = 0;\n\n          if (arguments.length === 1) {\n            while (++i < n) {\n              if (d3_numeric(a = d3_number(array[i]))) {\n                d = a - m;\n                m += d / ++j;\n                s += d * (a - m);\n              }\n            }\n          } else {\n            while (++i < n) {\n              if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {\n                d = a - m;\n                m += d / ++j;\n                s += d * (a - m);\n              }\n            }\n          }\n\n          if (j > 1) return s / (j - 1);\n        };\n\n        d3.deviation = function () {\n          var v = d3.variance.apply(this, arguments);\n          return v ? Math.sqrt(v) : v;\n        };\n\n        function d3_bisector(compare) {\n          return {\n            left: function (a, x, lo, hi) {\n              if (arguments.length < 3) lo = 0;\n              if (arguments.length < 4) hi = a.length;\n\n              while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;\n              }\n\n              return lo;\n            },\n            right: function (a, x, lo, hi) {\n              if (arguments.length < 3) lo = 0;\n              if (arguments.length < 4) hi = a.length;\n\n              while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;\n              }\n\n              return lo;\n            }\n          };\n        }\n\n        var d3_bisect = d3_bisector(d3_ascending);\n        d3.bisectLeft = d3_bisect.left;\n        d3.bisect = d3.bisectRight = d3_bisect.right;\n\n        d3.bisector = function (f) {\n          return d3_bisector(f.length === 1 ? function (d, x) {\n            return d3_ascending(f(d), x);\n          } : f);\n        };\n\n        d3.shuffle = function (array, i0, i1) {\n          if ((m = arguments.length) < 3) {\n            i1 = array.length;\n            if (m < 2) i0 = 0;\n          }\n\n          var m = i1 - i0,\n              t,\n              i;\n\n          while (m) {\n            i = Math.random() * m-- | 0;\n            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\n          }\n\n          return array;\n        };\n\n        d3.permute = function (array, indexes) {\n          var i = indexes.length,\n              permutes = new Array(i);\n\n          while (i--) permutes[i] = array[indexes[i]];\n\n          return permutes;\n        };\n\n        d3.pairs = function (array) {\n          var i = 0,\n              n = array.length - 1,\n              p0,\n              p1 = array[0],\n              pairs = new Array(n < 0 ? 0 : n);\n\n          while (i < n) pairs[i] = [p0 = p1, p1 = array[++i]];\n\n          return pairs;\n        };\n\n        d3.transpose = function (matrix) {\n          if (!(n = matrix.length)) return [];\n\n          for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m;) {\n            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n              row[j] = matrix[j][i];\n            }\n          }\n\n          return transpose;\n        };\n\n        function d3_transposeLength(d) {\n          return d.length;\n        }\n\n        d3.zip = function () {\n          return d3.transpose(arguments);\n        };\n\n        d3.keys = function (map) {\n          var keys = [];\n\n          for (var key in map) keys.push(key);\n\n          return keys;\n        };\n\n        d3.values = function (map) {\n          var values = [];\n\n          for (var key in map) values.push(map[key]);\n\n          return values;\n        };\n\n        d3.entries = function (map) {\n          var entries = [];\n\n          for (var key in map) entries.push({\n            key: key,\n            value: map[key]\n          });\n\n          return entries;\n        };\n\n        d3.merge = function (arrays) {\n          var n = arrays.length,\n              m,\n              i = -1,\n              j = 0,\n              merged,\n              array;\n\n          while (++i < n) j += arrays[i].length;\n\n          merged = new Array(j);\n\n          while (--n >= 0) {\n            array = arrays[n];\n            m = array.length;\n\n            while (--m >= 0) {\n              merged[--j] = array[m];\n            }\n          }\n\n          return merged;\n        };\n\n        var abs = Math.abs;\n\n        d3.range = function (start, stop, step) {\n          if (arguments.length < 3) {\n            step = 1;\n\n            if (arguments.length < 2) {\n              stop = start;\n              start = 0;\n            }\n          }\n\n          if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n          var range = [],\n              k = d3_range_integerScale(abs(step)),\n              i = -1,\n              j;\n          start *= k, stop *= k, step *= k;\n          if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);else while ((j = start + step * ++i) < stop) range.push(j / k);\n          return range;\n        };\n\n        function d3_range_integerScale(x) {\n          var k = 1;\n\n          while (x * k % 1) k *= 10;\n\n          return k;\n        }\n\n        function d3_class(ctor, properties) {\n          for (var key in properties) {\n            Object.defineProperty(ctor.prototype, key, {\n              value: properties[key],\n              enumerable: false\n            });\n          }\n        }\n\n        d3.map = function (object, f) {\n          var map = new d3_Map();\n\n          if (object instanceof d3_Map) {\n            object.forEach(function (key, value) {\n              map.set(key, value);\n            });\n          } else if (Array.isArray(object)) {\n            var i = -1,\n                n = object.length,\n                o;\n            if (arguments.length === 1) while (++i < n) map.set(i, object[i]);else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n          } else {\n            for (var key in object) map.set(key, object[key]);\n          }\n\n          return map;\n        };\n\n        function d3_Map() {\n          this._ = Object.create(null);\n        }\n\n        var d3_map_proto = \"__proto__\",\n            d3_map_zero = \"\\x00\";\n        d3_class(d3_Map, {\n          has: d3_map_has,\n          get: function (key) {\n            return this._[d3_map_escape(key)];\n          },\n          set: function (key, value) {\n            return this._[d3_map_escape(key)] = value;\n          },\n          remove: d3_map_remove,\n          keys: d3_map_keys,\n          values: function () {\n            var values = [];\n\n            for (var key in this._) values.push(this._[key]);\n\n            return values;\n          },\n          entries: function () {\n            var entries = [];\n\n            for (var key in this._) entries.push({\n              key: d3_map_unescape(key),\n              value: this._[key]\n            });\n\n            return entries;\n          },\n          size: d3_map_size,\n          empty: d3_map_empty,\n          forEach: function (f) {\n            for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n          }\n        });\n\n        function d3_map_escape(key) {\n          return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n        }\n\n        function d3_map_unescape(key) {\n          return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n        }\n\n        function d3_map_has(key) {\n          return d3_map_escape(key) in this._;\n        }\n\n        function d3_map_remove(key) {\n          return (key = d3_map_escape(key)) in this._ && delete this._[key];\n        }\n\n        function d3_map_keys() {\n          var keys = [];\n\n          for (var key in this._) keys.push(d3_map_unescape(key));\n\n          return keys;\n        }\n\n        function d3_map_size() {\n          var size = 0;\n\n          for (var key in this._) ++size;\n\n          return size;\n        }\n\n        function d3_map_empty() {\n          for (var key in this._) return false;\n\n          return true;\n        }\n\n        d3.nest = function () {\n          var nest = {},\n              keys = [],\n              sortKeys = [],\n              sortValues,\n              rollup;\n\n          function map(mapType, array, depth) {\n            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\n            var i = -1,\n                n = array.length,\n                key = keys[depth++],\n                keyValue,\n                object,\n                setter,\n                valuesByKey = new d3_Map(),\n                values;\n\n            while (++i < n) {\n              if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n                values.push(object);\n              } else {\n                valuesByKey.set(keyValue, [object]);\n              }\n            }\n\n            if (mapType) {\n              object = mapType();\n\n              setter = function (keyValue, values) {\n                object.set(keyValue, map(mapType, values, depth));\n              };\n            } else {\n              object = {};\n\n              setter = function (keyValue, values) {\n                object[keyValue] = map(mapType, values, depth);\n              };\n            }\n\n            valuesByKey.forEach(setter);\n            return object;\n          }\n\n          function entries(map, depth) {\n            if (depth >= keys.length) return map;\n            var array = [],\n                sortKey = sortKeys[depth++];\n            map.forEach(function (key, keyMap) {\n              array.push({\n                key: key,\n                values: entries(keyMap, depth)\n              });\n            });\n            return sortKey ? array.sort(function (a, b) {\n              return sortKey(a.key, b.key);\n            }) : array;\n          }\n\n          nest.map = function (array, mapType) {\n            return map(mapType, array, 0);\n          };\n\n          nest.entries = function (array) {\n            return entries(map(d3.map, array, 0), 0);\n          };\n\n          nest.key = function (d) {\n            keys.push(d);\n            return nest;\n          };\n\n          nest.sortKeys = function (order) {\n            sortKeys[keys.length - 1] = order;\n            return nest;\n          };\n\n          nest.sortValues = function (order) {\n            sortValues = order;\n            return nest;\n          };\n\n          nest.rollup = function (f) {\n            rollup = f;\n            return nest;\n          };\n\n          return nest;\n        };\n\n        d3.set = function (array) {\n          var set = new d3_Set();\n          if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);\n          return set;\n        };\n\n        function d3_Set() {\n          this._ = Object.create(null);\n        }\n\n        d3_class(d3_Set, {\n          has: d3_map_has,\n          add: function (key) {\n            this._[d3_map_escape(key += \"\")] = true;\n            return key;\n          },\n          remove: d3_map_remove,\n          values: d3_map_keys,\n          size: d3_map_size,\n          empty: d3_map_empty,\n          forEach: function (f) {\n            for (var key in this._) f.call(this, d3_map_unescape(key));\n          }\n        });\n        d3.behavior = {};\n\n        function d3_identity(d) {\n          return d;\n        }\n\n        d3.rebind = function (target, source) {\n          var i = 1,\n              n = arguments.length,\n              method;\n\n          while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n\n          return target;\n        };\n\n        function d3_rebind(target, source, method) {\n          return function () {\n            var value = method.apply(source, arguments);\n            return value === source ? target : value;\n          };\n        }\n\n        function d3_vendorSymbol(object, name) {\n          if (name in object) return name;\n          name = name.charAt(0).toUpperCase() + name.slice(1);\n\n          for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n            var prefixName = d3_vendorPrefixes[i] + name;\n            if (prefixName in object) return prefixName;\n          }\n        }\n\n        var d3_vendorPrefixes = [\"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\"];\n\n        function d3_noop() {}\n\n        d3.dispatch = function () {\n          var dispatch = new d3_dispatch(),\n              i = -1,\n              n = arguments.length;\n\n          while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n\n          return dispatch;\n        };\n\n        function d3_dispatch() {}\n\n        d3_dispatch.prototype.on = function (type, listener) {\n          var i = type.indexOf(\".\"),\n              name = \"\";\n\n          if (i >= 0) {\n            name = type.slice(i + 1);\n            type = type.slice(0, i);\n          }\n\n          if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n\n          if (arguments.length === 2) {\n            if (listener == null) for (type in this) {\n              if (this.hasOwnProperty(type)) this[type].on(name, null);\n            }\n            return this;\n          }\n        };\n\n        function d3_dispatch_event(dispatch) {\n          var listeners = [],\n              listenerByName = new d3_Map();\n\n          function event() {\n            var z = listeners,\n                i = -1,\n                n = z.length,\n                l;\n\n            while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n\n            return dispatch;\n          }\n\n          event.on = function (name, listener) {\n            var l = listenerByName.get(name),\n                i;\n            if (arguments.length < 2) return l && l.on;\n\n            if (l) {\n              l.on = null;\n              listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n              listenerByName.remove(name);\n            }\n\n            if (listener) listeners.push(listenerByName.set(name, {\n              on: listener\n            }));\n            return dispatch;\n          };\n\n          return event;\n        }\n\n        d3.event = null;\n\n        function d3_eventPreventDefault() {\n          d3.event.preventDefault();\n        }\n\n        function d3_eventSource() {\n          var e = d3.event,\n              s;\n\n          while (s = e.sourceEvent) e = s;\n\n          return e;\n        }\n\n        function d3_eventDispatch(target) {\n          var dispatch = new d3_dispatch(),\n              i = 0,\n              n = arguments.length;\n\n          while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n\n          dispatch.of = function (thiz, argumentz) {\n            return function (e1) {\n              try {\n                var e0 = e1.sourceEvent = d3.event;\n                e1.target = target;\n                d3.event = e1;\n                dispatch[e1.type].apply(thiz, argumentz);\n              } finally {\n                d3.event = e0;\n              }\n            };\n          };\n\n          return dispatch;\n        }\n\n        d3.requote = function (s) {\n          return s.replace(d3_requote_re, \"\\\\$&\");\n        };\n\n        var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n        var d3_subclass = {}.__proto__ ? function (object, prototype) {\n          object.__proto__ = prototype;\n        } : function (object, prototype) {\n          for (var property in prototype) object[property] = prototype[property];\n        };\n\n        function d3_selection(groups) {\n          d3_subclass(groups, d3_selectionPrototype);\n          return groups;\n        }\n\n        var d3_select = function (s, n) {\n          return n.querySelector(s);\n        },\n            d3_selectAll = function (s, n) {\n          return n.querySelectorAll(s);\n        },\n            d3_selectMatches = function (n, s) {\n          var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n\n          d3_selectMatches = function (n, s) {\n            return d3_selectMatcher.call(n, s);\n          };\n\n          return d3_selectMatches(n, s);\n        };\n\n        if (typeof Sizzle === \"function\") {\n          d3_select = function (s, n) {\n            return Sizzle(s, n)[0] || null;\n          };\n\n          d3_selectAll = Sizzle;\n          d3_selectMatches = Sizzle.matchesSelector;\n        }\n\n        d3.selection = function () {\n          return d3.select(d3_document.documentElement);\n        };\n\n        var d3_selectionPrototype = d3.selection.prototype = [];\n\n        d3_selectionPrototype.select = function (selector) {\n          var subgroups = [],\n              subgroup,\n              subnode,\n              group,\n              node;\n          selector = d3_selection_selector(selector);\n\n          for (var j = -1, m = this.length; ++j < m;) {\n            subgroups.push(subgroup = []);\n            subgroup.parentNode = (group = this[j]).parentNode;\n\n            for (var i = -1, n = group.length; ++i < n;) {\n              if (node = group[i]) {\n                subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n                if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n              } else {\n                subgroup.push(null);\n              }\n            }\n          }\n\n          return d3_selection(subgroups);\n        };\n\n        function d3_selection_selector(selector) {\n          return typeof selector === \"function\" ? selector : function () {\n            return d3_select(selector, this);\n          };\n        }\n\n        d3_selectionPrototype.selectAll = function (selector) {\n          var subgroups = [],\n              subgroup,\n              node;\n          selector = d3_selection_selectorAll(selector);\n\n          for (var j = -1, m = this.length; ++j < m;) {\n            for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n              if (node = group[i]) {\n                subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n                subgroup.parentNode = node;\n              }\n            }\n          }\n\n          return d3_selection(subgroups);\n        };\n\n        function d3_selection_selectorAll(selector) {\n          return typeof selector === \"function\" ? selector : function () {\n            return d3_selectAll(selector, this);\n          };\n        }\n\n        var d3_nsXhtml = \"http://www.w3.org/1999/xhtml\";\n        var d3_nsPrefix = {\n          svg: \"http://www.w3.org/2000/svg\",\n          xhtml: d3_nsXhtml,\n          xlink: \"http://www.w3.org/1999/xlink\",\n          xml: \"http://www.w3.org/XML/1998/namespace\",\n          xmlns: \"http://www.w3.org/2000/xmlns/\"\n        };\n        d3.ns = {\n          prefix: d3_nsPrefix,\n          qualify: function (name) {\n            var i = name.indexOf(\":\"),\n                prefix = name;\n            if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n            return d3_nsPrefix.hasOwnProperty(prefix) ? {\n              space: d3_nsPrefix[prefix],\n              local: name\n            } : name;\n          }\n        };\n\n        d3_selectionPrototype.attr = function (name, value) {\n          if (arguments.length < 2) {\n            if (typeof name === \"string\") {\n              var node = this.node();\n              name = d3.ns.qualify(name);\n              return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n            }\n\n            for (value in name) this.each(d3_selection_attr(value, name[value]));\n\n            return this;\n          }\n\n          return this.each(d3_selection_attr(name, value));\n        };\n\n        function d3_selection_attr(name, value) {\n          name = d3.ns.qualify(name);\n\n          function attrNull() {\n            this.removeAttribute(name);\n          }\n\n          function attrNullNS() {\n            this.removeAttributeNS(name.space, name.local);\n          }\n\n          function attrConstant() {\n            this.setAttribute(name, value);\n          }\n\n          function attrConstantNS() {\n            this.setAttributeNS(name.space, name.local, value);\n          }\n\n          function attrFunction() {\n            var x = value.apply(this, arguments);\n            if (x == null) this.removeAttribute(name);else this.setAttribute(name, x);\n          }\n\n          function attrFunctionNS() {\n            var x = value.apply(this, arguments);\n            if (x == null) this.removeAttributeNS(name.space, name.local);else this.setAttributeNS(name.space, name.local, x);\n          }\n\n          return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n        }\n\n        function d3_collapse(s) {\n          return s.trim().replace(/\\s+/g, \" \");\n        }\n\n        d3_selectionPrototype.classed = function (name, value) {\n          if (arguments.length < 2) {\n            if (typeof name === \"string\") {\n              var node = this.node(),\n                  n = (name = d3_selection_classes(name)).length,\n                  i = -1;\n\n              if (value = node.classList) {\n                while (++i < n) if (!value.contains(name[i])) return false;\n              } else {\n                value = node.getAttribute(\"class\");\n\n                while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n              }\n\n              return true;\n            }\n\n            for (value in name) this.each(d3_selection_classed(value, name[value]));\n\n            return this;\n          }\n\n          return this.each(d3_selection_classed(name, value));\n        };\n\n        function d3_selection_classedRe(name) {\n          return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n        }\n\n        function d3_selection_classes(name) {\n          return (name + \"\").trim().split(/^|\\s+/);\n        }\n\n        function d3_selection_classed(name, value) {\n          name = d3_selection_classes(name).map(d3_selection_classedName);\n          var n = name.length;\n\n          function classedConstant() {\n            var i = -1;\n\n            while (++i < n) name[i](this, value);\n          }\n\n          function classedFunction() {\n            var i = -1,\n                x = value.apply(this, arguments);\n\n            while (++i < n) name[i](this, x);\n          }\n\n          return typeof value === \"function\" ? classedFunction : classedConstant;\n        }\n\n        function d3_selection_classedName(name) {\n          var re = d3_selection_classedRe(name);\n          return function (node, value) {\n            if (c = node.classList) return value ? c.add(name) : c.remove(name);\n            var c = node.getAttribute(\"class\") || \"\";\n\n            if (value) {\n              re.lastIndex = 0;\n              if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n            } else {\n              node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n            }\n          };\n        }\n\n        d3_selectionPrototype.style = function (name, value, priority) {\n          var n = arguments.length;\n\n          if (n < 3) {\n            if (typeof name !== \"string\") {\n              if (n < 2) value = \"\";\n\n              for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n\n              return this;\n            }\n\n            if (n < 2) {\n              var node = this.node();\n              return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n            }\n\n            priority = \"\";\n          }\n\n          return this.each(d3_selection_style(name, value, priority));\n        };\n\n        function d3_selection_style(name, value, priority) {\n          function styleNull() {\n            this.style.removeProperty(name);\n          }\n\n          function styleConstant() {\n            this.style.setProperty(name, value, priority);\n          }\n\n          function styleFunction() {\n            var x = value.apply(this, arguments);\n            if (x == null) this.style.removeProperty(name);else this.style.setProperty(name, x, priority);\n          }\n\n          return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\n        }\n\n        d3_selectionPrototype.property = function (name, value) {\n          if (arguments.length < 2) {\n            if (typeof name === \"string\") return this.node()[name];\n\n            for (value in name) this.each(d3_selection_property(value, name[value]));\n\n            return this;\n          }\n\n          return this.each(d3_selection_property(name, value));\n        };\n\n        function d3_selection_property(name, value) {\n          function propertyNull() {\n            delete this[name];\n          }\n\n          function propertyConstant() {\n            this[name] = value;\n          }\n\n          function propertyFunction() {\n            var x = value.apply(this, arguments);\n            if (x == null) delete this[name];else this[name] = x;\n          }\n\n          return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\n        }\n\n        d3_selectionPrototype.text = function (value) {\n          return arguments.length ? this.each(typeof value === \"function\" ? function () {\n            var v = value.apply(this, arguments);\n            this.textContent = v == null ? \"\" : v;\n          } : value == null ? function () {\n            this.textContent = \"\";\n          } : function () {\n            this.textContent = value;\n          }) : this.node().textContent;\n        };\n\n        d3_selectionPrototype.html = function (value) {\n          return arguments.length ? this.each(typeof value === \"function\" ? function () {\n            var v = value.apply(this, arguments);\n            this.innerHTML = v == null ? \"\" : v;\n          } : value == null ? function () {\n            this.innerHTML = \"\";\n          } : function () {\n            this.innerHTML = value;\n          }) : this.node().innerHTML;\n        };\n\n        d3_selectionPrototype.append = function (name) {\n          name = d3_selection_creator(name);\n          return this.select(function () {\n            return this.appendChild(name.apply(this, arguments));\n          });\n        };\n\n        function d3_selection_creator(name) {\n          function create() {\n            var document = this.ownerDocument,\n                namespace = this.namespaceURI;\n            return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);\n          }\n\n          function createNS() {\n            return this.ownerDocument.createElementNS(name.space, name.local);\n          }\n\n          return typeof name === \"function\" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;\n        }\n\n        d3_selectionPrototype.insert = function (name, before) {\n          name = d3_selection_creator(name);\n          before = d3_selection_selector(before);\n          return this.select(function () {\n            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n          });\n        };\n\n        d3_selectionPrototype.remove = function () {\n          return this.each(d3_selectionRemove);\n        };\n\n        function d3_selectionRemove() {\n          var parent = this.parentNode;\n          if (parent) parent.removeChild(this);\n        }\n\n        d3_selectionPrototype.data = function (value, key) {\n          var i = -1,\n              n = this.length,\n              group,\n              node;\n\n          if (!arguments.length) {\n            value = new Array(n = (group = this[0]).length);\n\n            while (++i < n) {\n              if (node = group[i]) {\n                value[i] = node.__data__;\n              }\n            }\n\n            return value;\n          }\n\n          function bind(group, groupData) {\n            var i,\n                n = group.length,\n                m = groupData.length,\n                n0 = Math.min(n, m),\n                updateNodes = new Array(m),\n                enterNodes = new Array(m),\n                exitNodes = new Array(n),\n                node,\n                nodeData;\n\n            if (key) {\n              var nodeByKeyValue = new d3_Map(),\n                  keyValues = new Array(n),\n                  keyValue;\n\n              for (i = -1; ++i < n;) {\n                if (node = group[i]) {\n                  if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {\n                    exitNodes[i] = node;\n                  } else {\n                    nodeByKeyValue.set(keyValue, node);\n                  }\n\n                  keyValues[i] = keyValue;\n                }\n              }\n\n              for (i = -1; ++i < m;) {\n                if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n                  enterNodes[i] = d3_selection_dataNode(nodeData);\n                } else if (node !== true) {\n                  updateNodes[i] = node;\n                  node.__data__ = nodeData;\n                }\n\n                nodeByKeyValue.set(keyValue, true);\n              }\n\n              for (i = -1; ++i < n;) {\n                if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {\n                  exitNodes[i] = group[i];\n                }\n              }\n            } else {\n              for (i = -1; ++i < n0;) {\n                node = group[i];\n                nodeData = groupData[i];\n\n                if (node) {\n                  node.__data__ = nodeData;\n                  updateNodes[i] = node;\n                } else {\n                  enterNodes[i] = d3_selection_dataNode(nodeData);\n                }\n              }\n\n              for (; i < m; ++i) {\n                enterNodes[i] = d3_selection_dataNode(groupData[i]);\n              }\n\n              for (; i < n; ++i) {\n                exitNodes[i] = group[i];\n              }\n            }\n\n            enterNodes.update = updateNodes;\n            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n            enter.push(enterNodes);\n            update.push(updateNodes);\n            exit.push(exitNodes);\n          }\n\n          var enter = d3_selection_enter([]),\n              update = d3_selection([]),\n              exit = d3_selection([]);\n\n          if (typeof value === \"function\") {\n            while (++i < n) {\n              bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n            }\n          } else {\n            while (++i < n) {\n              bind(group = this[i], value);\n            }\n          }\n\n          update.enter = function () {\n            return enter;\n          };\n\n          update.exit = function () {\n            return exit;\n          };\n\n          return update;\n        };\n\n        function d3_selection_dataNode(data) {\n          return {\n            __data__: data\n          };\n        }\n\n        d3_selectionPrototype.datum = function (value) {\n          return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\n        };\n\n        d3_selectionPrototype.filter = function (filter) {\n          var subgroups = [],\n              subgroup,\n              group,\n              node;\n          if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n          for (var j = 0, m = this.length; j < m; j++) {\n            subgroups.push(subgroup = []);\n            subgroup.parentNode = (group = this[j]).parentNode;\n\n            for (var i = 0, n = group.length; i < n; i++) {\n              if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n                subgroup.push(node);\n              }\n            }\n          }\n\n          return d3_selection(subgroups);\n        };\n\n        function d3_selection_filter(selector) {\n          return function () {\n            return d3_selectMatches(this, selector);\n          };\n        }\n\n        d3_selectionPrototype.order = function () {\n          for (var j = -1, m = this.length; ++j < m;) {\n            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n              if (node = group[i]) {\n                if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n                next = node;\n              }\n            }\n          }\n\n          return this;\n        };\n\n        d3_selectionPrototype.sort = function (comparator) {\n          comparator = d3_selection_sortComparator.apply(this, arguments);\n\n          for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n\n          return this.order();\n        };\n\n        function d3_selection_sortComparator(comparator) {\n          if (!arguments.length) comparator = d3_ascending;\n          return function (a, b) {\n            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n          };\n        }\n\n        d3_selectionPrototype.each = function (callback) {\n          return d3_selection_each(this, function (node, i, j) {\n            callback.call(node, node.__data__, i, j);\n          });\n        };\n\n        function d3_selection_each(groups, callback) {\n          for (var j = 0, m = groups.length; j < m; j++) {\n            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n              if (node = group[i]) callback(node, i, j);\n            }\n          }\n\n          return groups;\n        }\n\n        d3_selectionPrototype.call = function (callback) {\n          var args = d3_array(arguments);\n          callback.apply(args[0] = this, args);\n          return this;\n        };\n\n        d3_selectionPrototype.empty = function () {\n          return !this.node();\n        };\n\n        d3_selectionPrototype.node = function () {\n          for (var j = 0, m = this.length; j < m; j++) {\n            for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n              var node = group[i];\n              if (node) return node;\n            }\n          }\n\n          return null;\n        };\n\n        d3_selectionPrototype.size = function () {\n          var n = 0;\n          d3_selection_each(this, function () {\n            ++n;\n          });\n          return n;\n        };\n\n        function d3_selection_enter(selection) {\n          d3_subclass(selection, d3_selection_enterPrototype);\n          return selection;\n        }\n\n        var d3_selection_enterPrototype = [];\n        d3.selection.enter = d3_selection_enter;\n        d3.selection.enter.prototype = d3_selection_enterPrototype;\n        d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n        d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n        d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n        d3_selection_enterPrototype.call = d3_selectionPrototype.call;\n        d3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\n        d3_selection_enterPrototype.select = function (selector) {\n          var subgroups = [],\n              subgroup,\n              subnode,\n              upgroup,\n              group,\n              node;\n\n          for (var j = -1, m = this.length; ++j < m;) {\n            upgroup = (group = this[j]).update;\n            subgroups.push(subgroup = []);\n            subgroup.parentNode = group.parentNode;\n\n            for (var i = -1, n = group.length; ++i < n;) {\n              if (node = group[i]) {\n                subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n                subnode.__data__ = node.__data__;\n              } else {\n                subgroup.push(null);\n              }\n            }\n          }\n\n          return d3_selection(subgroups);\n        };\n\n        d3_selection_enterPrototype.insert = function (name, before) {\n          if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n          return d3_selectionPrototype.insert.call(this, name, before);\n        };\n\n        function d3_selection_enterInsertBefore(enter) {\n          var i0, j0;\n          return function (d, i, j) {\n            var group = enter[j].update,\n                n = group.length,\n                node;\n            if (j != j0) j0 = j, i0 = 0;\n            if (i >= i0) i0 = i + 1;\n\n            while (!(node = group[i0]) && ++i0 < n);\n\n            return node;\n          };\n        }\n\n        d3.select = function (node) {\n          var group;\n\n          if (typeof node === \"string\") {\n            group = [d3_select(node, d3_document)];\n            group.parentNode = d3_document.documentElement;\n          } else {\n            group = [node];\n            group.parentNode = d3_documentElement(node);\n          }\n\n          return d3_selection([group]);\n        };\n\n        d3.selectAll = function (nodes) {\n          var group;\n\n          if (typeof nodes === \"string\") {\n            group = d3_array(d3_selectAll(nodes, d3_document));\n            group.parentNode = d3_document.documentElement;\n          } else {\n            group = d3_array(nodes);\n            group.parentNode = null;\n          }\n\n          return d3_selection([group]);\n        };\n\n        d3_selectionPrototype.on = function (type, listener, capture) {\n          var n = arguments.length;\n\n          if (n < 3) {\n            if (typeof type !== \"string\") {\n              if (n < 2) listener = false;\n\n              for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n\n              return this;\n            }\n\n            if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n            capture = false;\n          }\n\n          return this.each(d3_selection_on(type, listener, capture));\n        };\n\n        function d3_selection_on(type, listener, capture) {\n          var name = \"__on\" + type,\n              i = type.indexOf(\".\"),\n              wrap = d3_selection_onListener;\n          if (i > 0) type = type.slice(0, i);\n          var filter = d3_selection_onFilters.get(type);\n          if (filter) type = filter, wrap = d3_selection_onFilter;\n\n          function onRemove() {\n            var l = this[name];\n\n            if (l) {\n              this.removeEventListener(type, l, l.$);\n              delete this[name];\n            }\n          }\n\n          function onAdd() {\n            var l = wrap(listener, d3_array(arguments));\n            onRemove.call(this);\n            this.addEventListener(type, this[name] = l, l.$ = capture);\n            l._ = listener;\n          }\n\n          function removeAll() {\n            var re = new RegExp(\"^__on([^.]+)\" + d3.requote(type) + \"$\"),\n                match;\n\n            for (var name in this) {\n              if (match = name.match(re)) {\n                var l = this[name];\n                this.removeEventListener(match[1], l, l.$);\n                delete this[name];\n              }\n            }\n          }\n\n          return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\n        }\n\n        var d3_selection_onFilters = d3.map({\n          mouseenter: \"mouseover\",\n          mouseleave: \"mouseout\"\n        });\n\n        if (d3_document) {\n          d3_selection_onFilters.forEach(function (k) {\n            if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n          });\n        }\n\n        function d3_selection_onListener(listener, argumentz) {\n          return function (e) {\n            var o = d3.event;\n            d3.event = e;\n            argumentz[0] = this.__data__;\n\n            try {\n              listener.apply(this, argumentz);\n            } finally {\n              d3.event = o;\n            }\n          };\n        }\n\n        function d3_selection_onFilter(listener, argumentz) {\n          var l = d3_selection_onListener(listener, argumentz);\n          return function (e) {\n            var target = this,\n                related = e.relatedTarget;\n\n            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\n              l.call(target, e);\n            }\n          };\n        }\n\n        var d3_event_dragSelect,\n            d3_event_dragId = 0;\n\n        function d3_event_dragSuppress(node) {\n          var name = \".dragsuppress-\" + ++d3_event_dragId,\n              click = \"click\" + name,\n              w = d3.select(d3_window(node)).on(\"touchmove\" + name, d3_eventPreventDefault).on(\"dragstart\" + name, d3_eventPreventDefault).on(\"selectstart\" + name, d3_eventPreventDefault);\n\n          if (d3_event_dragSelect == null) {\n            d3_event_dragSelect = \"onselectstart\" in node ? false : d3_vendorSymbol(node.style, \"userSelect\");\n          }\n\n          if (d3_event_dragSelect) {\n            var style = d3_documentElement(node).style,\n                select = style[d3_event_dragSelect];\n            style[d3_event_dragSelect] = \"none\";\n          }\n\n          return function (suppressClick) {\n            w.on(name, null);\n            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\n\n            if (suppressClick) {\n              var off = function () {\n                w.on(click, null);\n              };\n\n              w.on(click, function () {\n                d3_eventPreventDefault();\n                off();\n              }, true);\n              setTimeout(off, 0);\n            }\n          };\n        }\n\n        d3.mouse = function (container) {\n          return d3_mousePoint(container, d3_eventSource());\n        };\n\n        var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\n\n        function d3_mousePoint(container, e) {\n          if (e.changedTouches) e = e.changedTouches[0];\n          var svg = container.ownerSVGElement || container;\n\n          if (svg.createSVGPoint) {\n            var point = svg.createSVGPoint();\n\n            if (d3_mouse_bug44083 < 0) {\n              var window = d3_window(container);\n\n              if (window.scrollX || window.scrollY) {\n                svg = d3.select(\"body\").append(\"svg\").style({\n                  position: \"absolute\",\n                  top: 0,\n                  left: 0,\n                  margin: 0,\n                  padding: 0,\n                  border: \"none\"\n                }, \"important\");\n                var ctm = svg[0][0].getScreenCTM();\n                d3_mouse_bug44083 = !(ctm.f || ctm.e);\n                svg.remove();\n              }\n            }\n\n            if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY;else point.x = e.clientX, point.y = e.clientY;\n            point = point.matrixTransform(container.getScreenCTM().inverse());\n            return [point.x, point.y];\n          }\n\n          var rect = container.getBoundingClientRect();\n          return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];\n        }\n\n        d3.touch = function (container, touches, identifier) {\n          if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;\n          if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {\n            if ((touch = touches[i]).identifier === identifier) {\n              return d3_mousePoint(container, touch);\n            }\n          }\n        };\n\n        d3.behavior.drag = function () {\n          var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"),\n              origin = null,\n              mousedown = dragstart(d3_noop, d3.mouse, d3_window, \"mousemove\", \"mouseup\"),\n              touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, \"touchmove\", \"touchend\");\n\n          function drag() {\n            this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", touchstart);\n          }\n\n          function dragstart(id, position, subject, move, end) {\n            return function () {\n              var that = this,\n                  target = d3.event.target.correspondingElement || d3.event.target,\n                  parent = that.parentNode,\n                  dispatch = event.of(that, arguments),\n                  dragged = 0,\n                  dragId = id(),\n                  dragName = \".drag\" + (dragId == null ? \"\" : \"-\" + dragId),\n                  dragOffset,\n                  dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended),\n                  dragRestore = d3_event_dragSuppress(target),\n                  position0 = position(parent, dragId);\n\n              if (origin) {\n                dragOffset = origin.apply(that, arguments);\n                dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];\n              } else {\n                dragOffset = [0, 0];\n              }\n\n              dispatch({\n                type: \"dragstart\"\n              });\n\n              function moved() {\n                var position1 = position(parent, dragId),\n                    dx,\n                    dy;\n                if (!position1) return;\n                dx = position1[0] - position0[0];\n                dy = position1[1] - position0[1];\n                dragged |= dx | dy;\n                position0 = position1;\n                dispatch({\n                  type: \"drag\",\n                  x: position1[0] + dragOffset[0],\n                  y: position1[1] + dragOffset[1],\n                  dx: dx,\n                  dy: dy\n                });\n              }\n\n              function ended() {\n                if (!position(parent, dragId)) return;\n                dragSubject.on(move + dragName, null).on(end + dragName, null);\n                dragRestore(dragged);\n                dispatch({\n                  type: \"dragend\"\n                });\n              }\n            };\n          }\n\n          drag.origin = function (x) {\n            if (!arguments.length) return origin;\n            origin = x;\n            return drag;\n          };\n\n          return d3.rebind(drag, event, \"on\");\n        };\n\n        function d3_behavior_dragTouchId() {\n          return d3.event.changedTouches[0].identifier;\n        }\n\n        d3.touches = function (container, touches) {\n          if (arguments.length < 2) touches = d3_eventSource().touches;\n          return touches ? d3_array(touches).map(function (touch) {\n            var point = d3_mousePoint(container, touch);\n            point.identifier = touch.identifier;\n            return point;\n          }) : [];\n        };\n\n        var ε = 1e-6,\n            ε2 = ε * ε,\n            π = Math.PI,\n            τ = 2 * π,\n            τε = τ - ε,\n            halfπ = π / 2,\n            d3_radians = π / 180,\n            d3_degrees = 180 / π;\n\n        function d3_sgn(x) {\n          return x > 0 ? 1 : x < 0 ? -1 : 0;\n        }\n\n        function d3_cross2d(a, b, c) {\n          return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n        }\n\n        function d3_acos(x) {\n          return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\n        }\n\n        function d3_asin(x) {\n          return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\n        }\n\n        function d3_sinh(x) {\n          return ((x = Math.exp(x)) - 1 / x) / 2;\n        }\n\n        function d3_cosh(x) {\n          return ((x = Math.exp(x)) + 1 / x) / 2;\n        }\n\n        function d3_tanh(x) {\n          return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n        }\n\n        function d3_haversin(x) {\n          return (x = Math.sin(x / 2)) * x;\n        }\n\n        var ρ = Math.SQRT2,\n            ρ2 = 2,\n            ρ4 = 4;\n\n        d3.interpolateZoom = function (p0, p1) {\n          var ux0 = p0[0],\n              uy0 = p0[1],\n              w0 = p0[2],\n              ux1 = p1[0],\n              uy1 = p1[1],\n              w1 = p1[2],\n              dx = ux1 - ux0,\n              dy = uy1 - uy0,\n              d2 = dx * dx + dy * dy,\n              i,\n              S;\n\n          if (d2 < ε2) {\n            S = Math.log(w1 / w0) / ρ;\n\n            i = function (t) {\n              return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S)];\n            };\n          } else {\n            var d1 = Math.sqrt(d2),\n                b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1),\n                b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1),\n                r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),\n                r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n            S = (r1 - r0) / ρ;\n\n            i = function (t) {\n              var s = t * S,\n                  coshr0 = d3_cosh(r0),\n                  u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));\n              return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0)];\n            };\n          }\n\n          i.duration = S * 1e3;\n          return i;\n        };\n\n        d3.behavior.zoom = function () {\n          var view = {\n            x: 0,\n            y: 0,\n            k: 1\n          },\n              translate0,\n              center0,\n              center,\n              size = [960, 500],\n              scaleExtent = d3_behavior_zoomInfinity,\n              duration = 250,\n              zooming = 0,\n              mousedown = \"mousedown.zoom\",\n              mousemove = \"mousemove.zoom\",\n              mouseup = \"mouseup.zoom\",\n              mousewheelTimer,\n              touchstart = \"touchstart.zoom\",\n              touchtime,\n              event = d3_eventDispatch(zoom, \"zoomstart\", \"zoom\", \"zoomend\"),\n              x0,\n              x1,\n              y0,\n              y1;\n\n          if (!d3_behavior_zoomWheel) {\n            d3_behavior_zoomWheel = \"onwheel\" in d3_document ? (d3_behavior_zoomDelta = function () {\n              return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\n            }, \"wheel\") : \"onmousewheel\" in d3_document ? (d3_behavior_zoomDelta = function () {\n              return d3.event.wheelDelta;\n            }, \"mousewheel\") : (d3_behavior_zoomDelta = function () {\n              return -d3.event.detail;\n            }, \"MozMousePixelScroll\");\n          }\n\n          function zoom(g) {\n            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + \".zoom\", mousewheeled).on(\"dblclick.zoom\", dblclicked).on(touchstart, touchstarted);\n          }\n\n          zoom.event = function (g) {\n            g.each(function () {\n              var dispatch = event.of(this, arguments),\n                  view1 = view;\n\n              if (d3_transitionInheritId) {\n                d3.select(this).transition().each(\"start.zoom\", function () {\n                  view = this.__chart__ || {\n                    x: 0,\n                    y: 0,\n                    k: 1\n                  };\n                  zoomstarted(dispatch);\n                }).tween(\"zoom:zoom\", function () {\n                  var dx = size[0],\n                      dy = size[1],\n                      cx = center0 ? center0[0] : dx / 2,\n                      cy = center0 ? center0[1] : dy / 2,\n                      i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);\n                  return function (t) {\n                    var l = i(t),\n                        k = dx / l[2];\n                    this.__chart__ = view = {\n                      x: cx - l[0] * k,\n                      y: cy - l[1] * k,\n                      k: k\n                    };\n                    zoomed(dispatch);\n                  };\n                }).each(\"interrupt.zoom\", function () {\n                  zoomended(dispatch);\n                }).each(\"end.zoom\", function () {\n                  zoomended(dispatch);\n                });\n              } else {\n                this.__chart__ = view;\n                zoomstarted(dispatch);\n                zoomed(dispatch);\n                zoomended(dispatch);\n              }\n            });\n          };\n\n          zoom.translate = function (_) {\n            if (!arguments.length) return [view.x, view.y];\n            view = {\n              x: +_[0],\n              y: +_[1],\n              k: view.k\n            };\n            rescale();\n            return zoom;\n          };\n\n          zoom.scale = function (_) {\n            if (!arguments.length) return view.k;\n            view = {\n              x: view.x,\n              y: view.y,\n              k: null\n            };\n            scaleTo(+_);\n            rescale();\n            return zoom;\n          };\n\n          zoom.scaleExtent = function (_) {\n            if (!arguments.length) return scaleExtent;\n            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];\n            return zoom;\n          };\n\n          zoom.center = function (_) {\n            if (!arguments.length) return center;\n            center = _ && [+_[0], +_[1]];\n            return zoom;\n          };\n\n          zoom.size = function (_) {\n            if (!arguments.length) return size;\n            size = _ && [+_[0], +_[1]];\n            return zoom;\n          };\n\n          zoom.duration = function (_) {\n            if (!arguments.length) return duration;\n            duration = +_;\n            return zoom;\n          };\n\n          zoom.x = function (z) {\n            if (!arguments.length) return x1;\n            x1 = z;\n            x0 = z.copy();\n            view = {\n              x: 0,\n              y: 0,\n              k: 1\n            };\n            return zoom;\n          };\n\n          zoom.y = function (z) {\n            if (!arguments.length) return y1;\n            y1 = z;\n            y0 = z.copy();\n            view = {\n              x: 0,\n              y: 0,\n              k: 1\n            };\n            return zoom;\n          };\n\n          function location(p) {\n            return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];\n          }\n\n          function point(l) {\n            return [l[0] * view.k + view.x, l[1] * view.k + view.y];\n          }\n\n          function scaleTo(s) {\n            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n          }\n\n          function translateTo(p, l) {\n            l = point(l);\n            view.x += p[0] - l[0];\n            view.y += p[1] - l[1];\n          }\n\n          function zoomTo(that, p, l, k) {\n            that.__chart__ = {\n              x: view.x,\n              y: view.y,\n              k: view.k\n            };\n            scaleTo(Math.pow(2, k));\n            translateTo(center0 = p, l);\n            that = d3.select(that);\n            if (duration > 0) that = that.transition().duration(duration);\n            that.call(zoom.event);\n          }\n\n          function rescale() {\n            if (x1) x1.domain(x0.range().map(function (x) {\n              return (x - view.x) / view.k;\n            }).map(x0.invert));\n            if (y1) y1.domain(y0.range().map(function (y) {\n              return (y - view.y) / view.k;\n            }).map(y0.invert));\n          }\n\n          function zoomstarted(dispatch) {\n            if (!zooming++) dispatch({\n              type: \"zoomstart\"\n            });\n          }\n\n          function zoomed(dispatch) {\n            rescale();\n            dispatch({\n              type: \"zoom\",\n              scale: view.k,\n              translate: [view.x, view.y]\n            });\n          }\n\n          function zoomended(dispatch) {\n            if (! --zooming) dispatch({\n              type: \"zoomend\"\n            }), center0 = null;\n          }\n\n          function mousedowned() {\n            var that = this,\n                dispatch = event.of(that, arguments),\n                dragged = 0,\n                subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended),\n                location0 = location(d3.mouse(that)),\n                dragRestore = d3_event_dragSuppress(that);\n            d3_selection_interrupt.call(that);\n            zoomstarted(dispatch);\n\n            function moved() {\n              dragged = 1;\n              translateTo(d3.mouse(that), location0);\n              zoomed(dispatch);\n            }\n\n            function ended() {\n              subject.on(mousemove, null).on(mouseup, null);\n              dragRestore(dragged);\n              zoomended(dispatch);\n            }\n          }\n\n          function touchstarted() {\n            var that = this,\n                dispatch = event.of(that, arguments),\n                locations0 = {},\n                distance0 = 0,\n                scale0,\n                zoomName = \".zoom-\" + d3.event.changedTouches[0].identifier,\n                touchmove = \"touchmove\" + zoomName,\n                touchend = \"touchend\" + zoomName,\n                targets = [],\n                subject = d3.select(that),\n                dragRestore = d3_event_dragSuppress(that);\n            started();\n            zoomstarted(dispatch);\n            subject.on(mousedown, null).on(touchstart, started);\n\n            function relocate() {\n              var touches = d3.touches(that);\n              scale0 = view.k;\n              touches.forEach(function (t) {\n                if (t.identifier in locations0) locations0[t.identifier] = location(t);\n              });\n              return touches;\n            }\n\n            function started() {\n              var target = d3.event.target;\n              d3.select(target).on(touchmove, moved).on(touchend, ended);\n              targets.push(target);\n              var changed = d3.event.changedTouches;\n\n              for (var i = 0, n = changed.length; i < n; ++i) {\n                locations0[changed[i].identifier] = null;\n              }\n\n              var touches = relocate(),\n                  now = Date.now();\n\n              if (touches.length === 1) {\n                if (now - touchtime < 500) {\n                  var p = touches[0];\n                  zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);\n                  d3_eventPreventDefault();\n                }\n\n                touchtime = now;\n              } else if (touches.length > 1) {\n                var p = touches[0],\n                    q = touches[1],\n                    dx = p[0] - q[0],\n                    dy = p[1] - q[1];\n                distance0 = dx * dx + dy * dy;\n              }\n            }\n\n            function moved() {\n              var touches = d3.touches(that),\n                  p0,\n                  l0,\n                  p1,\n                  l1;\n              d3_selection_interrupt.call(that);\n\n              for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {\n                p1 = touches[i];\n\n                if (l1 = locations0[p1.identifier]) {\n                  if (l0) break;\n                  p0 = p1, l0 = l1;\n                }\n              }\n\n              if (l1) {\n                var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1,\n                    scale1 = distance0 && Math.sqrt(distance1 / distance0);\n                p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n                l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n                scaleTo(scale1 * scale0);\n              }\n\n              touchtime = null;\n              translateTo(p0, l0);\n              zoomed(dispatch);\n            }\n\n            function ended() {\n              if (d3.event.touches.length) {\n                var changed = d3.event.changedTouches;\n\n                for (var i = 0, n = changed.length; i < n; ++i) {\n                  delete locations0[changed[i].identifier];\n                }\n\n                for (var identifier in locations0) {\n                  return void relocate();\n                }\n              }\n\n              d3.selectAll(targets).on(zoomName, null);\n              subject.on(mousedown, mousedowned).on(touchstart, touchstarted);\n              dragRestore();\n              zoomended(dispatch);\n            }\n          }\n\n          function mousewheeled() {\n            var dispatch = event.of(this, arguments);\n            if (mousewheelTimer) clearTimeout(mousewheelTimer);else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);\n            mousewheelTimer = setTimeout(function () {\n              mousewheelTimer = null;\n              zoomended(dispatch);\n            }, 50);\n            d3_eventPreventDefault();\n            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);\n            translateTo(center0, translate0);\n            zoomed(dispatch);\n          }\n\n          function dblclicked() {\n            var p = d3.mouse(this),\n                k = Math.log(view.k) / Math.LN2;\n            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);\n          }\n\n          return d3.rebind(zoom, event, \"on\");\n        };\n\n        var d3_behavior_zoomInfinity = [0, Infinity],\n            d3_behavior_zoomDelta,\n            d3_behavior_zoomWheel;\n        d3.color = d3_color;\n\n        function d3_color() {}\n\n        d3_color.prototype.toString = function () {\n          return this.rgb() + \"\";\n        };\n\n        d3.hsl = d3_hsl;\n\n        function d3_hsl(h, s, l) {\n          return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\n        }\n\n        var d3_hslPrototype = d3_hsl.prototype = new d3_color();\n\n        d3_hslPrototype.brighter = function (k) {\n          k = Math.pow(.7, arguments.length ? k : 1);\n          return new d3_hsl(this.h, this.s, this.l / k);\n        };\n\n        d3_hslPrototype.darker = function (k) {\n          k = Math.pow(.7, arguments.length ? k : 1);\n          return new d3_hsl(this.h, this.s, k * this.l);\n        };\n\n        d3_hslPrototype.rgb = function () {\n          return d3_hsl_rgb(this.h, this.s, this.l);\n        };\n\n        function d3_hsl_rgb(h, s, l) {\n          var m1, m2;\n          h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n          s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n          l = l < 0 ? 0 : l > 1 ? 1 : l;\n          m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n          m1 = 2 * l - m2;\n\n          function v(h) {\n            if (h > 360) h -= 360;else if (h < 0) h += 360;\n            if (h < 60) return m1 + (m2 - m1) * h / 60;\n            if (h < 180) return m2;\n            if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n            return m1;\n          }\n\n          function vv(h) {\n            return Math.round(v(h) * 255);\n          }\n\n          return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n        }\n\n        d3.hcl = d3_hcl;\n\n        function d3_hcl(h, c, l) {\n          return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\n        }\n\n        var d3_hclPrototype = d3_hcl.prototype = new d3_color();\n\n        d3_hclPrototype.brighter = function (k) {\n          return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n        };\n\n        d3_hclPrototype.darker = function (k) {\n          return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n        };\n\n        d3_hclPrototype.rgb = function () {\n          return d3_hcl_lab(this.h, this.c, this.l).rgb();\n        };\n\n        function d3_hcl_lab(h, c, l) {\n          if (isNaN(h)) h = 0;\n          if (isNaN(c)) c = 0;\n          return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n        }\n\n        d3.lab = d3_lab;\n\n        function d3_lab(l, a, b) {\n          return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n        }\n\n        var d3_lab_K = 18;\n        var d3_lab_X = .95047,\n            d3_lab_Y = 1,\n            d3_lab_Z = 1.08883;\n        var d3_labPrototype = d3_lab.prototype = new d3_color();\n\n        d3_labPrototype.brighter = function (k) {\n          return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n        };\n\n        d3_labPrototype.darker = function (k) {\n          return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n        };\n\n        d3_labPrototype.rgb = function () {\n          return d3_lab_rgb(this.l, this.a, this.b);\n        };\n\n        function d3_lab_rgb(l, a, b) {\n          var y = (l + 16) / 116,\n              x = y + a / 500,\n              z = y - b / 200;\n          x = d3_lab_xyz(x) * d3_lab_X;\n          y = d3_lab_xyz(y) * d3_lab_Y;\n          z = d3_lab_xyz(z) * d3_lab_Z;\n          return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\n        }\n\n        function d3_lab_hcl(l, a, b) {\n          return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\n        }\n\n        function d3_lab_xyz(x) {\n          return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n        }\n\n        function d3_xyz_lab(x) {\n          return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n        }\n\n        function d3_xyz_rgb(r) {\n          return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n        }\n\n        d3.rgb = d3_rgb;\n\n        function d3_rgb(r, g, b) {\n          return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\n        }\n\n        function d3_rgbNumber(value) {\n          return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n        }\n\n        function d3_rgbString(value) {\n          return d3_rgbNumber(value) + \"\";\n        }\n\n        var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\n\n        d3_rgbPrototype.brighter = function (k) {\n          k = Math.pow(.7, arguments.length ? k : 1);\n          var r = this.r,\n              g = this.g,\n              b = this.b,\n              i = 30;\n          if (!r && !g && !b) return new d3_rgb(i, i, i);\n          if (r && r < i) r = i;\n          if (g && g < i) g = i;\n          if (b && b < i) b = i;\n          return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n        };\n\n        d3_rgbPrototype.darker = function (k) {\n          k = Math.pow(.7, arguments.length ? k : 1);\n          return new d3_rgb(k * this.r, k * this.g, k * this.b);\n        };\n\n        d3_rgbPrototype.hsl = function () {\n          return d3_rgb_hsl(this.r, this.g, this.b);\n        };\n\n        d3_rgbPrototype.toString = function () {\n          return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n        };\n\n        function d3_rgb_hex(v) {\n          return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n        }\n\n        function d3_rgb_parse(format, rgb, hsl) {\n          var r = 0,\n              g = 0,\n              b = 0,\n              m1,\n              m2,\n              color;\n          m1 = /([a-z]+)\\((.*)\\)/.exec(format = format.toLowerCase());\n\n          if (m1) {\n            m2 = m1[2].split(\",\");\n\n            switch (m1[1]) {\n              case \"hsl\":\n                {\n                  return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n                }\n\n              case \"rgb\":\n                {\n                  return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n                }\n            }\n          }\n\n          if (color = d3_rgb_names.get(format)) {\n            return rgb(color.r, color.g, color.b);\n          }\n\n          if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.slice(1), 16))) {\n            if (format.length === 4) {\n              r = (color & 3840) >> 4;\n              r = r >> 4 | r;\n              g = color & 240;\n              g = g >> 4 | g;\n              b = color & 15;\n              b = b << 4 | b;\n            } else if (format.length === 7) {\n              r = (color & 16711680) >> 16;\n              g = (color & 65280) >> 8;\n              b = color & 255;\n            }\n          }\n\n          return rgb(r, g, b);\n        }\n\n        function d3_rgb_hsl(r, g, b) {\n          var min = Math.min(r /= 255, g /= 255, b /= 255),\n              max = Math.max(r, g, b),\n              d = max - min,\n              h,\n              s,\n              l = (max + min) / 2;\n\n          if (d) {\n            s = l < .5 ? d / (max + min) : d / (2 - max - min);\n            if (r == max) h = (g - b) / d + (g < b ? 6 : 0);else if (g == max) h = (b - r) / d + 2;else h = (r - g) / d + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n\n          return new d3_hsl(h, s, l);\n        }\n\n        function d3_rgb_lab(r, g, b) {\n          r = d3_rgb_xyz(r);\n          g = d3_rgb_xyz(g);\n          b = d3_rgb_xyz(b);\n          var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),\n              y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),\n              z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n          return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n        }\n\n        function d3_rgb_xyz(r) {\n          return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n        }\n\n        function d3_rgb_parseNumber(c) {\n          var f = parseFloat(c);\n          return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n        }\n\n        var d3_rgb_names = d3.map({\n          aliceblue: 15792383,\n          antiquewhite: 16444375,\n          aqua: 65535,\n          aquamarine: 8388564,\n          azure: 15794175,\n          beige: 16119260,\n          bisque: 16770244,\n          black: 0,\n          blanchedalmond: 16772045,\n          blue: 255,\n          blueviolet: 9055202,\n          brown: 10824234,\n          burlywood: 14596231,\n          cadetblue: 6266528,\n          chartreuse: 8388352,\n          chocolate: 13789470,\n          coral: 16744272,\n          cornflowerblue: 6591981,\n          cornsilk: 16775388,\n          crimson: 14423100,\n          cyan: 65535,\n          darkblue: 139,\n          darkcyan: 35723,\n          darkgoldenrod: 12092939,\n          darkgray: 11119017,\n          darkgreen: 25600,\n          darkgrey: 11119017,\n          darkkhaki: 12433259,\n          darkmagenta: 9109643,\n          darkolivegreen: 5597999,\n          darkorange: 16747520,\n          darkorchid: 10040012,\n          darkred: 9109504,\n          darksalmon: 15308410,\n          darkseagreen: 9419919,\n          darkslateblue: 4734347,\n          darkslategray: 3100495,\n          darkslategrey: 3100495,\n          darkturquoise: 52945,\n          darkviolet: 9699539,\n          deeppink: 16716947,\n          deepskyblue: 49151,\n          dimgray: 6908265,\n          dimgrey: 6908265,\n          dodgerblue: 2003199,\n          firebrick: 11674146,\n          floralwhite: 16775920,\n          forestgreen: 2263842,\n          fuchsia: 16711935,\n          gainsboro: 14474460,\n          ghostwhite: 16316671,\n          gold: 16766720,\n          goldenrod: 14329120,\n          gray: 8421504,\n          green: 32768,\n          greenyellow: 11403055,\n          grey: 8421504,\n          honeydew: 15794160,\n          hotpink: 16738740,\n          indianred: 13458524,\n          indigo: 4915330,\n          ivory: 16777200,\n          khaki: 15787660,\n          lavender: 15132410,\n          lavenderblush: 16773365,\n          lawngreen: 8190976,\n          lemonchiffon: 16775885,\n          lightblue: 11393254,\n          lightcoral: 15761536,\n          lightcyan: 14745599,\n          lightgoldenrodyellow: 16448210,\n          lightgray: 13882323,\n          lightgreen: 9498256,\n          lightgrey: 13882323,\n          lightpink: 16758465,\n          lightsalmon: 16752762,\n          lightseagreen: 2142890,\n          lightskyblue: 8900346,\n          lightslategray: 7833753,\n          lightslategrey: 7833753,\n          lightsteelblue: 11584734,\n          lightyellow: 16777184,\n          lime: 65280,\n          limegreen: 3329330,\n          linen: 16445670,\n          magenta: 16711935,\n          maroon: 8388608,\n          mediumaquamarine: 6737322,\n          mediumblue: 205,\n          mediumorchid: 12211667,\n          mediumpurple: 9662683,\n          mediumseagreen: 3978097,\n          mediumslateblue: 8087790,\n          mediumspringgreen: 64154,\n          mediumturquoise: 4772300,\n          mediumvioletred: 13047173,\n          midnightblue: 1644912,\n          mintcream: 16121850,\n          mistyrose: 16770273,\n          moccasin: 16770229,\n          navajowhite: 16768685,\n          navy: 128,\n          oldlace: 16643558,\n          olive: 8421376,\n          olivedrab: 7048739,\n          orange: 16753920,\n          orangered: 16729344,\n          orchid: 14315734,\n          palegoldenrod: 15657130,\n          palegreen: 10025880,\n          paleturquoise: 11529966,\n          palevioletred: 14381203,\n          papayawhip: 16773077,\n          peachpuff: 16767673,\n          peru: 13468991,\n          pink: 16761035,\n          plum: 14524637,\n          powderblue: 11591910,\n          purple: 8388736,\n          rebeccapurple: 6697881,\n          red: 16711680,\n          rosybrown: 12357519,\n          royalblue: 4286945,\n          saddlebrown: 9127187,\n          salmon: 16416882,\n          sandybrown: 16032864,\n          seagreen: 3050327,\n          seashell: 16774638,\n          sienna: 10506797,\n          silver: 12632256,\n          skyblue: 8900331,\n          slateblue: 6970061,\n          slategray: 7372944,\n          slategrey: 7372944,\n          snow: 16775930,\n          springgreen: 65407,\n          steelblue: 4620980,\n          tan: 13808780,\n          teal: 32896,\n          thistle: 14204888,\n          tomato: 16737095,\n          turquoise: 4251856,\n          violet: 15631086,\n          wheat: 16113331,\n          white: 16777215,\n          whitesmoke: 16119285,\n          yellow: 16776960,\n          yellowgreen: 10145074\n        });\n        d3_rgb_names.forEach(function (key, value) {\n          d3_rgb_names.set(key, d3_rgbNumber(value));\n        });\n\n        function d3_functor(v) {\n          return typeof v === \"function\" ? v : function () {\n            return v;\n          };\n        }\n\n        d3.functor = d3_functor;\n        d3.xhr = d3_xhrType(d3_identity);\n\n        function d3_xhrType(response) {\n          return function (url, mimeType, callback) {\n            if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, mimeType = null;\n            return d3_xhr(url, mimeType, response, callback);\n          };\n        }\n\n        function d3_xhr(url, mimeType, response, callback) {\n          var xhr = {},\n              dispatch = d3.dispatch(\"beforesend\", \"progress\", \"load\", \"error\"),\n              headers = {},\n              request = new XMLHttpRequest(),\n              responseType = null;\n          if (this.XDomainRequest && !(\"withCredentials\" in request) && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n          \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {\n            request.readyState > 3 && respond();\n          };\n\n          function respond() {\n            var status = request.status,\n                result;\n\n            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n              try {\n                result = response.call(xhr, request);\n              } catch (e) {\n                dispatch.error.call(xhr, e);\n                return;\n              }\n\n              dispatch.load.call(xhr, result);\n            } else {\n              dispatch.error.call(xhr, request);\n            }\n          }\n\n          request.onprogress = function (event) {\n            var o = d3.event;\n            d3.event = event;\n\n            try {\n              dispatch.progress.call(xhr, request);\n            } finally {\n              d3.event = o;\n            }\n          };\n\n          xhr.header = function (name, value) {\n            name = (name + \"\").toLowerCase();\n            if (arguments.length < 2) return headers[name];\n            if (value == null) delete headers[name];else headers[name] = value + \"\";\n            return xhr;\n          };\n\n          xhr.mimeType = function (value) {\n            if (!arguments.length) return mimeType;\n            mimeType = value == null ? null : value + \"\";\n            return xhr;\n          };\n\n          xhr.responseType = function (value) {\n            if (!arguments.length) return responseType;\n            responseType = value;\n            return xhr;\n          };\n\n          xhr.response = function (value) {\n            response = value;\n            return xhr;\n          };\n\n          [\"get\", \"post\"].forEach(function (method) {\n            xhr[method] = function () {\n              return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));\n            };\n          });\n\n          xhr.send = function (method, data, callback) {\n            if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\n            request.open(method, url, true);\n            if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\n            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\n            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n            if (responseType != null) request.responseType = responseType;\n            if (callback != null) xhr.on(\"error\", callback).on(\"load\", function (request) {\n              callback(null, request);\n            });\n            dispatch.beforesend.call(xhr, request);\n            request.send(data == null ? null : data);\n            return xhr;\n          };\n\n          xhr.abort = function () {\n            request.abort();\n            return xhr;\n          };\n\n          d3.rebind(xhr, dispatch, \"on\");\n          return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n        }\n\n        function d3_xhr_fixCallback(callback) {\n          return callback.length === 1 ? function (error, request) {\n            callback(error == null ? request : null);\n          } : callback;\n        }\n\n        function d3_xhrHasResponse(request) {\n          var type = request.responseType;\n          return type && type !== \"text\" ? request.response : request.responseText;\n        }\n\n        d3.dsv = function (delimiter, mimeType) {\n          var reFormat = new RegExp('[\"' + delimiter + \"\\n]\"),\n              delimiterCode = delimiter.charCodeAt(0);\n\n          function dsv(url, row, callback) {\n            if (arguments.length < 3) callback = row, row = null;\n            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);\n\n            xhr.row = function (_) {\n              return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;\n            };\n\n            return xhr;\n          }\n\n          function response(request) {\n            return dsv.parse(request.responseText);\n          }\n\n          function typedResponse(f) {\n            return function (request) {\n              return dsv.parse(request.responseText, f);\n            };\n          }\n\n          dsv.parse = function (text, f) {\n            var o;\n            return dsv.parseRows(text, function (row, i) {\n              if (o) return o(row, i - 1);\n              var a = new Function(\"d\", \"return {\" + row.map(function (name, i) {\n                return JSON.stringify(name) + \": d[\" + i + \"]\";\n              }).join(\",\") + \"}\");\n              o = f ? function (row, i) {\n                return f(a(row), i);\n              } : a;\n            });\n          };\n\n          dsv.parseRows = function (text, f) {\n            var EOL = {},\n                EOF = {},\n                rows = [],\n                N = text.length,\n                I = 0,\n                n = 0,\n                t,\n                eol;\n\n            function token() {\n              if (I >= N) return EOF;\n              if (eol) return eol = false, EOL;\n              var j = I;\n\n              if (text.charCodeAt(j) === 34) {\n                var i = j;\n\n                while (i++ < N) {\n                  if (text.charCodeAt(i) === 34) {\n                    if (text.charCodeAt(i + 1) !== 34) break;\n                    ++i;\n                  }\n                }\n\n                I = i + 2;\n                var c = text.charCodeAt(i + 1);\n\n                if (c === 13) {\n                  eol = true;\n                  if (text.charCodeAt(i + 2) === 10) ++I;\n                } else if (c === 10) {\n                  eol = true;\n                }\n\n                return text.slice(j + 1, i).replace(/\"\"/g, '\"');\n              }\n\n              while (I < N) {\n                var c = text.charCodeAt(I++),\n                    k = 1;\n                if (c === 10) eol = true;else if (c === 13) {\n                  eol = true;\n                  if (text.charCodeAt(I) === 10) ++I, ++k;\n                } else if (c !== delimiterCode) continue;\n                return text.slice(j, I - k);\n              }\n\n              return text.slice(j);\n            }\n\n            while ((t = token()) !== EOF) {\n              var a = [];\n\n              while (t !== EOL && t !== EOF) {\n                a.push(t);\n                t = token();\n              }\n\n              if (f && (a = f(a, n++)) == null) continue;\n              rows.push(a);\n            }\n\n            return rows;\n          };\n\n          dsv.format = function (rows) {\n            if (Array.isArray(rows[0])) return dsv.formatRows(rows);\n            var fieldSet = new d3_Set(),\n                fields = [];\n            rows.forEach(function (row) {\n              for (var field in row) {\n                if (!fieldSet.has(field)) {\n                  fields.push(fieldSet.add(field));\n                }\n              }\n            });\n            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {\n              return fields.map(function (field) {\n                return formatValue(row[field]);\n              }).join(delimiter);\n            })).join(\"\\n\");\n          };\n\n          dsv.formatRows = function (rows) {\n            return rows.map(formatRow).join(\"\\n\");\n          };\n\n          function formatRow(row) {\n            return row.map(formatValue).join(delimiter);\n          }\n\n          function formatValue(text) {\n            return reFormat.test(text) ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"' : text;\n          }\n\n          return dsv;\n        };\n\n        d3.csv = d3.dsv(\",\", \"text/csv\");\n        d3.tsv = d3.dsv(\"\t\", \"text/tab-separated-values\");\n\n        var d3_timer_queueHead,\n            d3_timer_queueTail,\n            d3_timer_interval,\n            d3_timer_timeout,\n            d3_timer_frame = this[d3_vendorSymbol(this, \"requestAnimationFrame\")] || function (callback) {\n          setTimeout(callback, 17);\n        };\n\n        d3.timer = function () {\n          d3_timer.apply(this, arguments);\n        };\n\n        function d3_timer(callback, delay, then) {\n          var n = arguments.length;\n          if (n < 2) delay = 0;\n          if (n < 3) then = Date.now();\n          var time = then + delay,\n              timer = {\n            c: callback,\n            t: time,\n            n: null\n          };\n          if (d3_timer_queueTail) d3_timer_queueTail.n = timer;else d3_timer_queueHead = timer;\n          d3_timer_queueTail = timer;\n\n          if (!d3_timer_interval) {\n            d3_timer_timeout = clearTimeout(d3_timer_timeout);\n            d3_timer_interval = 1;\n            d3_timer_frame(d3_timer_step);\n          }\n\n          return timer;\n        }\n\n        function d3_timer_step() {\n          var now = d3_timer_mark(),\n              delay = d3_timer_sweep() - now;\n\n          if (delay > 24) {\n            if (isFinite(delay)) {\n              clearTimeout(d3_timer_timeout);\n              d3_timer_timeout = setTimeout(d3_timer_step, delay);\n            }\n\n            d3_timer_interval = 0;\n          } else {\n            d3_timer_interval = 1;\n            d3_timer_frame(d3_timer_step);\n          }\n        }\n\n        d3.timer.flush = function () {\n          d3_timer_mark();\n          d3_timer_sweep();\n        };\n\n        function d3_timer_mark() {\n          var now = Date.now(),\n              timer = d3_timer_queueHead;\n\n          while (timer) {\n            if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;\n            timer = timer.n;\n          }\n\n          return now;\n        }\n\n        function d3_timer_sweep() {\n          var t0,\n              t1 = d3_timer_queueHead,\n              time = Infinity;\n\n          while (t1) {\n            if (t1.c) {\n              if (t1.t < time) time = t1.t;\n              t1 = (t0 = t1).n;\n            } else {\n              t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\n            }\n          }\n\n          d3_timer_queueTail = t0;\n          return time;\n        }\n\n        function d3_format_precision(x, p) {\n          return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\n        }\n\n        d3.round = function (x, n) {\n          return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n        };\n\n        var d3_formatPrefixes = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"].map(d3_formatPrefix);\n\n        d3.formatPrefix = function (value, precision) {\n          var i = 0;\n\n          if (value = +value) {\n            if (value < 0) value *= -1;\n            if (precision) value = d3.round(value, d3_format_precision(value, precision));\n            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\n          }\n\n          return d3_formatPrefixes[8 + i / 3];\n        };\n\n        function d3_formatPrefix(d, i) {\n          var k = Math.pow(10, abs(8 - i) * 3);\n          return {\n            scale: i > 8 ? function (d) {\n              return d / k;\n            } : function (d) {\n              return d * k;\n            },\n            symbol: d\n          };\n        }\n\n        function d3_locale_numberFormat(locale) {\n          var locale_decimal = locale.decimal,\n              locale_thousands = locale.thousands,\n              locale_grouping = locale.grouping,\n              locale_currency = locale.currency,\n              formatGroup = locale_grouping && locale_thousands ? function (value, width) {\n            var i = value.length,\n                t = [],\n                j = 0,\n                g = locale_grouping[0],\n                length = 0;\n\n            while (i > 0 && g > 0) {\n              if (length + g + 1 > width) g = Math.max(1, width - length);\n              t.push(value.substring(i -= g, i + g));\n              if ((length += g + 1) > width) break;\n              g = locale_grouping[j = (j + 1) % locale_grouping.length];\n            }\n\n            return t.reverse().join(locale_thousands);\n          } : d3_identity;\n          return function (specifier) {\n            var match = d3_format_re.exec(specifier),\n                fill = match[1] || \" \",\n                align = match[2] || \">\",\n                sign = match[3] || \"-\",\n                symbol = match[4] || \"\",\n                zfill = match[5],\n                width = +match[6],\n                comma = match[7],\n                precision = match[8],\n                type = match[9],\n                scale = 1,\n                prefix = \"\",\n                suffix = \"\",\n                integer = false,\n                exponent = true;\n            if (precision) precision = +precision.substring(1);\n\n            if (zfill || fill === \"0\" && align === \"=\") {\n              zfill = fill = \"0\";\n              align = \"=\";\n            }\n\n            switch (type) {\n              case \"n\":\n                comma = true;\n                type = \"g\";\n                break;\n\n              case \"%\":\n                scale = 100;\n                suffix = \"%\";\n                type = \"f\";\n                break;\n\n              case \"p\":\n                scale = 100;\n                suffix = \"%\";\n                type = \"r\";\n                break;\n\n              case \"b\":\n              case \"o\":\n              case \"x\":\n              case \"X\":\n                if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n\n              case \"c\":\n                exponent = false;\n\n              case \"d\":\n                integer = true;\n                precision = 0;\n                break;\n\n              case \"s\":\n                scale = -1;\n                type = \"r\";\n                break;\n            }\n\n            if (symbol === \"$\") prefix = locale_currency[0], suffix = locale_currency[1];\n            if (type == \"r\" && !precision) type = \"g\";\n\n            if (precision != null) {\n              if (type == \"g\") precision = Math.max(1, Math.min(21, precision));else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n            }\n\n            type = d3_format_types.get(type) || d3_format_typeDefault;\n            var zcomma = zfill && comma;\n            return function (value) {\n              var fullSuffix = suffix;\n              if (integer && value % 1) return \"\";\n              var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign === \"-\" ? \"\" : sign;\n\n              if (scale < 0) {\n                var unit = d3.formatPrefix(value, precision);\n                value = unit.scale(value);\n                fullSuffix = unit.symbol + suffix;\n              } else {\n                value *= scale;\n              }\n\n              value = type(value, precision);\n              var i = value.lastIndexOf(\".\"),\n                  before,\n                  after;\n\n              if (i < 0) {\n                var j = exponent ? value.lastIndexOf(\"e\") : -1;\n                if (j < 0) before = value, after = \"\";else before = value.substring(0, j), after = value.substring(j);\n              } else {\n                before = value.substring(0, i);\n                after = locale_decimal + value.substring(i + 1);\n              }\n\n              if (!zfill && comma) before = formatGroup(before, Infinity);\n              var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length),\n                  padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n              if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);\n              negative += prefix;\n              value = before + after;\n              return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n            };\n          };\n        }\n\n        var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n        var d3_format_types = d3.map({\n          b: function (x) {\n            return x.toString(2);\n          },\n          c: function (x) {\n            return String.fromCharCode(x);\n          },\n          o: function (x) {\n            return x.toString(8);\n          },\n          x: function (x) {\n            return x.toString(16);\n          },\n          X: function (x) {\n            return x.toString(16).toUpperCase();\n          },\n          g: function (x, p) {\n            return x.toPrecision(p);\n          },\n          e: function (x, p) {\n            return x.toExponential(p);\n          },\n          f: function (x, p) {\n            return x.toFixed(p);\n          },\n          r: function (x, p) {\n            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\n          }\n        });\n\n        function d3_format_typeDefault(x) {\n          return x + \"\";\n        }\n\n        var d3_time = d3.time = {},\n            d3_date = Date;\n\n        function d3_date_utc() {\n          this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n        }\n\n        d3_date_utc.prototype = {\n          getDate: function () {\n            return this._.getUTCDate();\n          },\n          getDay: function () {\n            return this._.getUTCDay();\n          },\n          getFullYear: function () {\n            return this._.getUTCFullYear();\n          },\n          getHours: function () {\n            return this._.getUTCHours();\n          },\n          getMilliseconds: function () {\n            return this._.getUTCMilliseconds();\n          },\n          getMinutes: function () {\n            return this._.getUTCMinutes();\n          },\n          getMonth: function () {\n            return this._.getUTCMonth();\n          },\n          getSeconds: function () {\n            return this._.getUTCSeconds();\n          },\n          getTime: function () {\n            return this._.getTime();\n          },\n          getTimezoneOffset: function () {\n            return 0;\n          },\n          valueOf: function () {\n            return this._.valueOf();\n          },\n          setDate: function () {\n            d3_time_prototype.setUTCDate.apply(this._, arguments);\n          },\n          setDay: function () {\n            d3_time_prototype.setUTCDay.apply(this._, arguments);\n          },\n          setFullYear: function () {\n            d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n          },\n          setHours: function () {\n            d3_time_prototype.setUTCHours.apply(this._, arguments);\n          },\n          setMilliseconds: function () {\n            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n          },\n          setMinutes: function () {\n            d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n          },\n          setMonth: function () {\n            d3_time_prototype.setUTCMonth.apply(this._, arguments);\n          },\n          setSeconds: function () {\n            d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n          },\n          setTime: function () {\n            d3_time_prototype.setTime.apply(this._, arguments);\n          }\n        };\n        var d3_time_prototype = Date.prototype;\n\n        function d3_time_interval(local, step, number) {\n          function round(date) {\n            var d0 = local(date),\n                d1 = offset(d0, 1);\n            return date - d0 < d1 - date ? d0 : d1;\n          }\n\n          function ceil(date) {\n            step(date = local(new d3_date(date - 1)), 1);\n            return date;\n          }\n\n          function offset(date, k) {\n            step(date = new d3_date(+date), k);\n            return date;\n          }\n\n          function range(t0, t1, dt) {\n            var time = ceil(t0),\n                times = [];\n\n            if (dt > 1) {\n              while (time < t1) {\n                if (!(number(time) % dt)) times.push(new Date(+time));\n                step(time, 1);\n              }\n            } else {\n              while (time < t1) times.push(new Date(+time)), step(time, 1);\n            }\n\n            return times;\n          }\n\n          function range_utc(t0, t1, dt) {\n            try {\n              d3_date = d3_date_utc;\n              var utc = new d3_date_utc();\n              utc._ = t0;\n              return range(utc, t1, dt);\n            } finally {\n              d3_date = Date;\n            }\n          }\n\n          local.floor = local;\n          local.round = round;\n          local.ceil = ceil;\n          local.offset = offset;\n          local.range = range;\n          var utc = local.utc = d3_time_interval_utc(local);\n          utc.floor = utc;\n          utc.round = d3_time_interval_utc(round);\n          utc.ceil = d3_time_interval_utc(ceil);\n          utc.offset = d3_time_interval_utc(offset);\n          utc.range = range_utc;\n          return local;\n        }\n\n        function d3_time_interval_utc(method) {\n          return function (date, k) {\n            try {\n              d3_date = d3_date_utc;\n              var utc = new d3_date_utc();\n              utc._ = date;\n              return method(utc, k)._;\n            } finally {\n              d3_date = Date;\n            }\n          };\n        }\n\n        d3_time.year = d3_time_interval(function (date) {\n          date = d3_time.day(date);\n          date.setMonth(0, 1);\n          return date;\n        }, function (date, offset) {\n          date.setFullYear(date.getFullYear() + offset);\n        }, function (date) {\n          return date.getFullYear();\n        });\n        d3_time.years = d3_time.year.range;\n        d3_time.years.utc = d3_time.year.utc.range;\n        d3_time.day = d3_time_interval(function (date) {\n          var day = new d3_date(2e3, 0);\n          day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n          return day;\n        }, function (date, offset) {\n          date.setDate(date.getDate() + offset);\n        }, function (date) {\n          return date.getDate() - 1;\n        });\n        d3_time.days = d3_time.day.range;\n        d3_time.days.utc = d3_time.day.utc.range;\n\n        d3_time.dayOfYear = function (date) {\n          var year = d3_time.year(date);\n          return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n        };\n\n        [\"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\"].forEach(function (day, i) {\n          i = 7 - i;\n          var interval = d3_time[day] = d3_time_interval(function (date) {\n            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n            return date;\n          }, function (date, offset) {\n            date.setDate(date.getDate() + Math.floor(offset) * 7);\n          }, function (date) {\n            var day = d3_time.year(date).getDay();\n            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n          });\n          d3_time[day + \"s\"] = interval.range;\n          d3_time[day + \"s\"].utc = interval.utc.range;\n\n          d3_time[day + \"OfYear\"] = function (date) {\n            var day = d3_time.year(date).getDay();\n            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\n          };\n        });\n        d3_time.week = d3_time.sunday;\n        d3_time.weeks = d3_time.sunday.range;\n        d3_time.weeks.utc = d3_time.sunday.utc.range;\n        d3_time.weekOfYear = d3_time.sundayOfYear;\n\n        function d3_locale_timeFormat(locale) {\n          var locale_dateTime = locale.dateTime,\n              locale_date = locale.date,\n              locale_time = locale.time,\n              locale_periods = locale.periods,\n              locale_days = locale.days,\n              locale_shortDays = locale.shortDays,\n              locale_months = locale.months,\n              locale_shortMonths = locale.shortMonths;\n\n          function d3_time_format(template) {\n            var n = template.length;\n\n            function format(date) {\n              var string = [],\n                  i = -1,\n                  j = 0,\n                  c,\n                  p,\n                  f;\n\n              while (++i < n) {\n                if (template.charCodeAt(i) === 37) {\n                  string.push(template.slice(j, i));\n                  if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n                  if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\n                  string.push(c);\n                  j = i + 1;\n                }\n              }\n\n              string.push(template.slice(j, i));\n              return string.join(\"\");\n            }\n\n            format.parse = function (string) {\n              var d = {\n                y: 1900,\n                m: 0,\n                d: 1,\n                H: 0,\n                M: 0,\n                S: 0,\n                L: 0,\n                Z: null\n              },\n                  i = d3_time_parse(d, template, string, 0);\n              if (i != string.length) return null;\n              if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n              var localZ = d.Z != null && d3_date !== d3_date_utc,\n                  date = new (localZ ? d3_date_utc : d3_date)();\n              if (\"j\" in d) date.setFullYear(d.y, 0, d.j);else if (\"W\" in d || \"U\" in d) {\n                if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n                date.setFullYear(d.y, 0, 1);\n                date.setFullYear(d.y, 0, \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\n              } else date.setFullYear(d.y, d.m, d.d);\n              date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);\n              return localZ ? date._ : date;\n            };\n\n            format.toString = function () {\n              return template;\n            };\n\n            return format;\n          }\n\n          function d3_time_parse(date, template, string, j) {\n            var c,\n                p,\n                t,\n                i = 0,\n                n = template.length,\n                m = string.length;\n\n            while (i < n) {\n              if (j >= m) return -1;\n              c = template.charCodeAt(i++);\n\n              if (c === 37) {\n                t = template.charAt(i++);\n                p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\n                if (!p || (j = p(date, string, j)) < 0) return -1;\n              } else if (c != string.charCodeAt(j++)) {\n                return -1;\n              }\n            }\n\n            return j;\n          }\n\n          d3_time_format.utc = function (template) {\n            var local = d3_time_format(template);\n\n            function format(date) {\n              try {\n                d3_date = d3_date_utc;\n                var utc = new d3_date();\n                utc._ = date;\n                return local(utc);\n              } finally {\n                d3_date = Date;\n              }\n            }\n\n            format.parse = function (string) {\n              try {\n                d3_date = d3_date_utc;\n                var date = local.parse(string);\n                return date && date._;\n              } finally {\n                d3_date = Date;\n              }\n            };\n\n            format.toString = local.toString;\n            return format;\n          };\n\n          d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\n          var d3_time_periodLookup = d3.map(),\n              d3_time_dayRe = d3_time_formatRe(locale_days),\n              d3_time_dayLookup = d3_time_formatLookup(locale_days),\n              d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays),\n              d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays),\n              d3_time_monthRe = d3_time_formatRe(locale_months),\n              d3_time_monthLookup = d3_time_formatLookup(locale_months),\n              d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths),\n              d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\n          locale_periods.forEach(function (p, i) {\n            d3_time_periodLookup.set(p.toLowerCase(), i);\n          });\n          var d3_time_formats = {\n            a: function (d) {\n              return locale_shortDays[d.getDay()];\n            },\n            A: function (d) {\n              return locale_days[d.getDay()];\n            },\n            b: function (d) {\n              return locale_shortMonths[d.getMonth()];\n            },\n            B: function (d) {\n              return locale_months[d.getMonth()];\n            },\n            c: d3_time_format(locale_dateTime),\n            d: function (d, p) {\n              return d3_time_formatPad(d.getDate(), p, 2);\n            },\n            e: function (d, p) {\n              return d3_time_formatPad(d.getDate(), p, 2);\n            },\n            H: function (d, p) {\n              return d3_time_formatPad(d.getHours(), p, 2);\n            },\n            I: function (d, p) {\n              return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n            },\n            j: function (d, p) {\n              return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\n            },\n            L: function (d, p) {\n              return d3_time_formatPad(d.getMilliseconds(), p, 3);\n            },\n            m: function (d, p) {\n              return d3_time_formatPad(d.getMonth() + 1, p, 2);\n            },\n            M: function (d, p) {\n              return d3_time_formatPad(d.getMinutes(), p, 2);\n            },\n            p: function (d) {\n              return locale_periods[+(d.getHours() >= 12)];\n            },\n            S: function (d, p) {\n              return d3_time_formatPad(d.getSeconds(), p, 2);\n            },\n            U: function (d, p) {\n              return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\n            },\n            w: function (d) {\n              return d.getDay();\n            },\n            W: function (d, p) {\n              return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\n            },\n            x: d3_time_format(locale_date),\n            X: d3_time_format(locale_time),\n            y: function (d, p) {\n              return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n            },\n            Y: function (d, p) {\n              return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\n            },\n            Z: d3_time_zone,\n            \"%\": function () {\n              return \"%\";\n            }\n          };\n          var d3_time_parsers = {\n            a: d3_time_parseWeekdayAbbrev,\n            A: d3_time_parseWeekday,\n            b: d3_time_parseMonthAbbrev,\n            B: d3_time_parseMonth,\n            c: d3_time_parseLocaleFull,\n            d: d3_time_parseDay,\n            e: d3_time_parseDay,\n            H: d3_time_parseHour24,\n            I: d3_time_parseHour24,\n            j: d3_time_parseDayOfYear,\n            L: d3_time_parseMilliseconds,\n            m: d3_time_parseMonthNumber,\n            M: d3_time_parseMinutes,\n            p: d3_time_parseAmPm,\n            S: d3_time_parseSeconds,\n            U: d3_time_parseWeekNumberSunday,\n            w: d3_time_parseWeekdayNumber,\n            W: d3_time_parseWeekNumberMonday,\n            x: d3_time_parseLocaleDate,\n            X: d3_time_parseLocaleTime,\n            y: d3_time_parseYear,\n            Y: d3_time_parseFullYear,\n            Z: d3_time_parseZone,\n            \"%\": d3_time_parseLiteralPercent\n          };\n\n          function d3_time_parseWeekdayAbbrev(date, string, i) {\n            d3_time_dayAbbrevRe.lastIndex = 0;\n            var n = d3_time_dayAbbrevRe.exec(string.slice(i));\n            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n          }\n\n          function d3_time_parseWeekday(date, string, i) {\n            d3_time_dayRe.lastIndex = 0;\n            var n = d3_time_dayRe.exec(string.slice(i));\n            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n          }\n\n          function d3_time_parseMonthAbbrev(date, string, i) {\n            d3_time_monthAbbrevRe.lastIndex = 0;\n            var n = d3_time_monthAbbrevRe.exec(string.slice(i));\n            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n          }\n\n          function d3_time_parseMonth(date, string, i) {\n            d3_time_monthRe.lastIndex = 0;\n            var n = d3_time_monthRe.exec(string.slice(i));\n            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n          }\n\n          function d3_time_parseLocaleFull(date, string, i) {\n            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n          }\n\n          function d3_time_parseLocaleDate(date, string, i) {\n            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n          }\n\n          function d3_time_parseLocaleTime(date, string, i) {\n            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n          }\n\n          function d3_time_parseAmPm(date, string, i) {\n            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());\n            return n == null ? -1 : (date.p = n, i);\n          }\n\n          return d3_time_format;\n        }\n\n        var d3_time_formatPads = {\n          \"-\": \"\",\n          _: \" \",\n          \"0\": \"0\"\n        },\n            d3_time_numberRe = /^\\s*\\d+/,\n            d3_time_percentRe = /^%/;\n\n        function d3_time_formatPad(value, fill, width) {\n          var sign = value < 0 ? \"-\" : \"\",\n              string = (sign ? -value : value) + \"\",\n              length = string.length;\n          return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n        }\n\n        function d3_time_formatRe(names) {\n          return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n        }\n\n        function d3_time_formatLookup(names) {\n          var map = new d3_Map(),\n              i = -1,\n              n = names.length;\n\n          while (++i < n) map.set(names[i].toLowerCase(), i);\n\n          return map;\n        }\n\n        function d3_time_parseWeekdayNumber(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 1));\n          return n ? (date.w = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseWeekNumberSunday(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i));\n          return n ? (date.U = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseWeekNumberMonday(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i));\n          return n ? (date.W = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseFullYear(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 4));\n          return n ? (date.y = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseYear(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n          return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\n        }\n\n        function d3_time_parseZone(date, string, i) {\n          return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;\n        }\n\n        function d3_time_expandYear(d) {\n          return d + (d > 68 ? 1900 : 2e3);\n        }\n\n        function d3_time_parseMonthNumber(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n          return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\n        }\n\n        function d3_time_parseDay(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n          return n ? (date.d = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseDayOfYear(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n          return n ? (date.j = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseHour24(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n          return n ? (date.H = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseMinutes(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n          return n ? (date.M = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseSeconds(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n          return n ? (date.S = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_parseMilliseconds(date, string, i) {\n          d3_time_numberRe.lastIndex = 0;\n          var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n          return n ? (date.L = +n[0], i + n[0].length) : -1;\n        }\n\n        function d3_time_zone(d) {\n          var z = d.getTimezoneOffset(),\n              zs = z > 0 ? \"-\" : \"+\",\n              zh = abs(z) / 60 | 0,\n              zm = abs(z) % 60;\n          return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\n        }\n\n        function d3_time_parseLiteralPercent(date, string, i) {\n          d3_time_percentRe.lastIndex = 0;\n          var n = d3_time_percentRe.exec(string.slice(i, i + 1));\n          return n ? i + n[0].length : -1;\n        }\n\n        function d3_time_formatMulti(formats) {\n          var n = formats.length,\n              i = -1;\n\n          while (++i < n) formats[i][0] = this(formats[i][0]);\n\n          return function (date) {\n            var i = 0,\n                f = formats[i];\n\n            while (!f[1](date)) f = formats[++i];\n\n            return f[0](date);\n          };\n        }\n\n        d3.locale = function (locale) {\n          return {\n            numberFormat: d3_locale_numberFormat(locale),\n            timeFormat: d3_locale_timeFormat(locale)\n          };\n        };\n\n        var d3_locale_enUS = d3.locale({\n          decimal: \".\",\n          thousands: \",\",\n          grouping: [3],\n          currency: [\"$\", \"\"],\n          dateTime: \"%a %b %e %X %Y\",\n          date: \"%m/%d/%Y\",\n          time: \"%H:%M:%S\",\n          periods: [\"AM\", \"PM\"],\n          days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n          shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n          months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n          shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n        });\n        d3.format = d3_locale_enUS.numberFormat;\n        d3.geo = {};\n\n        function d3_adder() {}\n\n        d3_adder.prototype = {\n          s: 0,\n          t: 0,\n          add: function (y) {\n            d3_adderSum(y, this.t, d3_adderTemp);\n            d3_adderSum(d3_adderTemp.s, this.s, this);\n            if (this.s) this.t += d3_adderTemp.t;else this.s = d3_adderTemp.t;\n          },\n          reset: function () {\n            this.s = this.t = 0;\n          },\n          valueOf: function () {\n            return this.s;\n          }\n        };\n        var d3_adderTemp = new d3_adder();\n\n        function d3_adderSum(a, b, o) {\n          var x = o.s = a + b,\n              bv = x - a,\n              av = x - bv;\n          o.t = a - av + (b - bv);\n        }\n\n        d3.geo.stream = function (object, listener) {\n          if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n            d3_geo_streamObjectType[object.type](object, listener);\n          } else {\n            d3_geo_streamGeometry(object, listener);\n          }\n        };\n\n        function d3_geo_streamGeometry(geometry, listener) {\n          if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n            d3_geo_streamGeometryType[geometry.type](geometry, listener);\n          }\n        }\n\n        var d3_geo_streamObjectType = {\n          Feature: function (feature, listener) {\n            d3_geo_streamGeometry(feature.geometry, listener);\n          },\n          FeatureCollection: function (object, listener) {\n            var features = object.features,\n                i = -1,\n                n = features.length;\n\n            while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\n          }\n        };\n        var d3_geo_streamGeometryType = {\n          Sphere: function (object, listener) {\n            listener.sphere();\n          },\n          Point: function (object, listener) {\n            object = object.coordinates;\n            listener.point(object[0], object[1], object[2]);\n          },\n          MultiPoint: function (object, listener) {\n            var coordinates = object.coordinates,\n                i = -1,\n                n = coordinates.length;\n\n            while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);\n          },\n          LineString: function (object, listener) {\n            d3_geo_streamLine(object.coordinates, listener, 0);\n          },\n          MultiLineString: function (object, listener) {\n            var coordinates = object.coordinates,\n                i = -1,\n                n = coordinates.length;\n\n            while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\n          },\n          Polygon: function (object, listener) {\n            d3_geo_streamPolygon(object.coordinates, listener);\n          },\n          MultiPolygon: function (object, listener) {\n            var coordinates = object.coordinates,\n                i = -1,\n                n = coordinates.length;\n\n            while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\n          },\n          GeometryCollection: function (object, listener) {\n            var geometries = object.geometries,\n                i = -1,\n                n = geometries.length;\n\n            while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\n          }\n        };\n\n        function d3_geo_streamLine(coordinates, listener, closed) {\n          var i = -1,\n              n = coordinates.length - closed,\n              coordinate;\n          listener.lineStart();\n\n          while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\n\n          listener.lineEnd();\n        }\n\n        function d3_geo_streamPolygon(coordinates, listener) {\n          var i = -1,\n              n = coordinates.length;\n          listener.polygonStart();\n\n          while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\n\n          listener.polygonEnd();\n        }\n\n        d3.geo.area = function (object) {\n          d3_geo_areaSum = 0;\n          d3.geo.stream(object, d3_geo_area);\n          return d3_geo_areaSum;\n        };\n\n        var d3_geo_areaSum,\n            d3_geo_areaRingSum = new d3_adder();\n        var d3_geo_area = {\n          sphere: function () {\n            d3_geo_areaSum += 4 * π;\n          },\n          point: d3_noop,\n          lineStart: d3_noop,\n          lineEnd: d3_noop,\n          polygonStart: function () {\n            d3_geo_areaRingSum.reset();\n            d3_geo_area.lineStart = d3_geo_areaRingStart;\n          },\n          polygonEnd: function () {\n            var area = 2 * d3_geo_areaRingSum;\n            d3_geo_areaSum += area < 0 ? 4 * π + area : area;\n            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n          }\n        };\n\n        function d3_geo_areaRingStart() {\n          var λ00, φ00, λ0, cosφ0, sinφ0;\n\n          d3_geo_area.point = function (λ, φ) {\n            d3_geo_area.point = nextPoint;\n            λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);\n          };\n\n          function nextPoint(λ, φ) {\n            λ *= d3_radians;\n            φ = φ * d3_radians / 2 + π / 4;\n            var dλ = λ - λ0,\n                sdλ = dλ >= 0 ? 1 : -1,\n                adλ = sdλ * dλ,\n                cosφ = Math.cos(φ),\n                sinφ = Math.sin(φ),\n                k = sinφ0 * sinφ,\n                u = cosφ0 * cosφ + k * Math.cos(adλ),\n                v = k * sdλ * Math.sin(adλ);\n            d3_geo_areaRingSum.add(Math.atan2(v, u));\n            λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;\n          }\n\n          d3_geo_area.lineEnd = function () {\n            nextPoint(λ00, φ00);\n          };\n        }\n\n        function d3_geo_cartesian(spherical) {\n          var λ = spherical[0],\n              φ = spherical[1],\n              cosφ = Math.cos(φ);\n          return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];\n        }\n\n        function d3_geo_cartesianDot(a, b) {\n          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n        }\n\n        function d3_geo_cartesianCross(a, b) {\n          return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n        }\n\n        function d3_geo_cartesianAdd(a, b) {\n          a[0] += b[0];\n          a[1] += b[1];\n          a[2] += b[2];\n        }\n\n        function d3_geo_cartesianScale(vector, k) {\n          return [vector[0] * k, vector[1] * k, vector[2] * k];\n        }\n\n        function d3_geo_cartesianNormalize(d) {\n          var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n          d[0] /= l;\n          d[1] /= l;\n          d[2] /= l;\n        }\n\n        function d3_geo_spherical(cartesian) {\n          return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];\n        }\n\n        function d3_geo_sphericalEqual(a, b) {\n          return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;\n        }\n\n        d3.geo.bounds = function () {\n          var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;\n          var bound = {\n            point: point,\n            lineStart: lineStart,\n            lineEnd: lineEnd,\n            polygonStart: function () {\n              bound.point = ringPoint;\n              bound.lineStart = ringStart;\n              bound.lineEnd = ringEnd;\n              dλSum = 0;\n              d3_geo_area.polygonStart();\n            },\n            polygonEnd: function () {\n              d3_geo_area.polygonEnd();\n              bound.point = point;\n              bound.lineStart = lineStart;\n              bound.lineEnd = lineEnd;\n              if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);else if (dλSum > ε) φ1 = 90;else if (dλSum < -ε) φ0 = -90;\n              range[0] = λ0, range[1] = λ1;\n            }\n          };\n\n          function point(λ, φ) {\n            ranges.push(range = [λ0 = λ, λ1 = λ]);\n            if (φ < φ0) φ0 = φ;\n            if (φ > φ1) φ1 = φ;\n          }\n\n          function linePoint(λ, φ) {\n            var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);\n\n            if (p0) {\n              var normal = d3_geo_cartesianCross(p0, p),\n                  equatorial = [normal[1], -normal[0], 0],\n                  inflection = d3_geo_cartesianCross(equatorial, normal);\n              d3_geo_cartesianNormalize(inflection);\n              inflection = d3_geo_spherical(inflection);\n              var dλ = λ - λ_,\n                  s = dλ > 0 ? 1 : -1,\n                  λi = inflection[0] * d3_degrees * s,\n                  antimeridian = abs(dλ) > 180;\n\n              if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n                var φi = inflection[1] * d3_degrees;\n                if (φi > φ1) φ1 = φi;\n              } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n                var φi = -inflection[1] * d3_degrees;\n                if (φi < φ0) φ0 = φi;\n              } else {\n                if (φ < φ0) φ0 = φ;\n                if (φ > φ1) φ1 = φ;\n              }\n\n              if (antimeridian) {\n                if (λ < λ_) {\n                  if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n                } else {\n                  if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n                }\n              } else {\n                if (λ1 >= λ0) {\n                  if (λ < λ0) λ0 = λ;\n                  if (λ > λ1) λ1 = λ;\n                } else {\n                  if (λ > λ_) {\n                    if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n                  } else {\n                    if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n                  }\n                }\n              }\n            } else {\n              point(λ, φ);\n            }\n\n            p0 = p, λ_ = λ;\n          }\n\n          function lineStart() {\n            bound.point = linePoint;\n          }\n\n          function lineEnd() {\n            range[0] = λ0, range[1] = λ1;\n            bound.point = point;\n            p0 = null;\n          }\n\n          function ringPoint(λ, φ) {\n            if (p0) {\n              var dλ = λ - λ_;\n              dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;\n            } else λ__ = λ, φ__ = φ;\n\n            d3_geo_area.point(λ, φ);\n            linePoint(λ, φ);\n          }\n\n          function ringStart() {\n            d3_geo_area.lineStart();\n          }\n\n          function ringEnd() {\n            ringPoint(λ__, φ__);\n            d3_geo_area.lineEnd();\n            if (abs(dλSum) > ε) λ0 = -(λ1 = 180);\n            range[0] = λ0, range[1] = λ1;\n            p0 = null;\n          }\n\n          function angle(λ0, λ1) {\n            return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;\n          }\n\n          function compareRanges(a, b) {\n            return a[0] - b[0];\n          }\n\n          function withinRange(x, range) {\n            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n          }\n\n          return function (feature) {\n            φ1 = λ1 = -(λ0 = φ0 = Infinity);\n            ranges = [];\n            d3.geo.stream(feature, bound);\n            var n = ranges.length;\n\n            if (n) {\n              ranges.sort(compareRanges);\n\n              for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {\n                b = ranges[i];\n\n                if (withinRange(b[0], a) || withinRange(b[1], a)) {\n                  if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n                  if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n                } else {\n                  merged.push(a = b);\n                }\n              }\n\n              var best = -Infinity,\n                  dλ;\n\n              for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\n                b = merged[i];\n                if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];\n              }\n            }\n\n            ranges = range = null;\n            return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];\n          };\n        }();\n\n        d3.geo.centroid = function (object) {\n          d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n          d3.geo.stream(object, d3_geo_centroid);\n          var x = d3_geo_centroidX2,\n              y = d3_geo_centroidY2,\n              z = d3_geo_centroidZ2,\n              m = x * x + y * y + z * z;\n\n          if (m < ε2) {\n            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\n            if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\n            m = x * x + y * y + z * z;\n            if (m < ε2) return [NaN, NaN];\n          }\n\n          return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];\n        };\n\n        var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\n        var d3_geo_centroid = {\n          sphere: d3_noop,\n          point: d3_geo_centroidPoint,\n          lineStart: d3_geo_centroidLineStart,\n          lineEnd: d3_geo_centroidLineEnd,\n          polygonStart: function () {\n            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n          },\n          polygonEnd: function () {\n            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n          }\n        };\n\n        function d3_geo_centroidPoint(λ, φ) {\n          λ *= d3_radians;\n          var cosφ = Math.cos(φ *= d3_radians);\n          d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));\n        }\n\n        function d3_geo_centroidPointXYZ(x, y, z) {\n          ++d3_geo_centroidW0;\n          d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\n          d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\n          d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\n        }\n\n        function d3_geo_centroidLineStart() {\n          var x0, y0, z0;\n\n          d3_geo_centroid.point = function (λ, φ) {\n            λ *= d3_radians;\n            var cosφ = Math.cos(φ *= d3_radians);\n            x0 = cosφ * Math.cos(λ);\n            y0 = cosφ * Math.sin(λ);\n            z0 = Math.sin(φ);\n            d3_geo_centroid.point = nextPoint;\n            d3_geo_centroidPointXYZ(x0, y0, z0);\n          };\n\n          function nextPoint(λ, φ) {\n            λ *= d3_radians;\n            var cosφ = Math.cos(φ *= d3_radians),\n                x = cosφ * Math.cos(λ),\n                y = cosφ * Math.sin(λ),\n                z = Math.sin(φ),\n                w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n            d3_geo_centroidW1 += w;\n            d3_geo_centroidX1 += w * (x0 + (x0 = x));\n            d3_geo_centroidY1 += w * (y0 + (y0 = y));\n            d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n            d3_geo_centroidPointXYZ(x0, y0, z0);\n          }\n        }\n\n        function d3_geo_centroidLineEnd() {\n          d3_geo_centroid.point = d3_geo_centroidPoint;\n        }\n\n        function d3_geo_centroidRingStart() {\n          var λ00, φ00, x0, y0, z0;\n\n          d3_geo_centroid.point = function (λ, φ) {\n            λ00 = λ, φ00 = φ;\n            d3_geo_centroid.point = nextPoint;\n            λ *= d3_radians;\n            var cosφ = Math.cos(φ *= d3_radians);\n            x0 = cosφ * Math.cos(λ);\n            y0 = cosφ * Math.sin(λ);\n            z0 = Math.sin(φ);\n            d3_geo_centroidPointXYZ(x0, y0, z0);\n          };\n\n          d3_geo_centroid.lineEnd = function () {\n            nextPoint(λ00, φ00);\n            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n            d3_geo_centroid.point = d3_geo_centroidPoint;\n          };\n\n          function nextPoint(λ, φ) {\n            λ *= d3_radians;\n            var cosφ = Math.cos(φ *= d3_radians),\n                x = cosφ * Math.cos(λ),\n                y = cosφ * Math.sin(λ),\n                z = Math.sin(φ),\n                cx = y0 * z - z0 * y,\n                cy = z0 * x - x0 * z,\n                cz = x0 * y - y0 * x,\n                m = Math.sqrt(cx * cx + cy * cy + cz * cz),\n                u = x0 * x + y0 * y + z0 * z,\n                v = m && -d3_acos(u) / m,\n                w = Math.atan2(m, u);\n            d3_geo_centroidX2 += v * cx;\n            d3_geo_centroidY2 += v * cy;\n            d3_geo_centroidZ2 += v * cz;\n            d3_geo_centroidW1 += w;\n            d3_geo_centroidX1 += w * (x0 + (x0 = x));\n            d3_geo_centroidY1 += w * (y0 + (y0 = y));\n            d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n            d3_geo_centroidPointXYZ(x0, y0, z0);\n          }\n        }\n\n        function d3_geo_compose(a, b) {\n          function compose(x, y) {\n            return x = a(x, y), b(x[0], x[1]);\n          }\n\n          if (a.invert && b.invert) compose.invert = function (x, y) {\n            return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n          };\n          return compose;\n        }\n\n        function d3_true() {\n          return true;\n        }\n\n        function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\n          var subject = [],\n              clip = [];\n          segments.forEach(function (segment) {\n            if ((n = segment.length - 1) <= 0) return;\n            var n,\n                p0 = segment[0],\n                p1 = segment[n];\n\n            if (d3_geo_sphericalEqual(p0, p1)) {\n              listener.lineStart();\n\n              for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);\n\n              listener.lineEnd();\n              return;\n            }\n\n            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true),\n                b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\n            a.o = b;\n            subject.push(a);\n            clip.push(b);\n            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\n            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\n            a.o = b;\n            subject.push(a);\n            clip.push(b);\n          });\n          clip.sort(compare);\n          d3_geo_clipPolygonLinkCircular(subject);\n          d3_geo_clipPolygonLinkCircular(clip);\n          if (!subject.length) return;\n\n          for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\n            clip[i].e = entry = !entry;\n          }\n\n          var start = subject[0],\n              points,\n              point;\n\n          while (1) {\n            var current = start,\n                isSubject = true;\n\n            while (current.v) if ((current = current.n) === start) return;\n\n            points = current.z;\n            listener.lineStart();\n\n            do {\n              current.v = current.o.v = true;\n\n              if (current.e) {\n                if (isSubject) {\n                  for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);\n                } else {\n                  interpolate(current.x, current.n.x, 1, listener);\n                }\n\n                current = current.n;\n              } else {\n                if (isSubject) {\n                  points = current.p.z;\n\n                  for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);\n                } else {\n                  interpolate(current.x, current.p.x, -1, listener);\n                }\n\n                current = current.p;\n              }\n\n              current = current.o;\n              points = current.z;\n              isSubject = !isSubject;\n            } while (!current.v);\n\n            listener.lineEnd();\n          }\n        }\n\n        function d3_geo_clipPolygonLinkCircular(array) {\n          if (!(n = array.length)) return;\n          var n,\n              i = 0,\n              a = array[0],\n              b;\n\n          while (++i < n) {\n            a.n = b = array[i];\n            b.p = a;\n            a = b;\n          }\n\n          a.n = b = array[0];\n          b.p = a;\n        }\n\n        function d3_geo_clipPolygonIntersection(point, points, other, entry) {\n          this.x = point;\n          this.z = points;\n          this.o = other;\n          this.e = entry;\n          this.v = false;\n          this.n = this.p = null;\n        }\n\n        function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\n          return function (rotate, listener) {\n            var line = clipLine(listener),\n                rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\n            var clip = {\n              point: point,\n              lineStart: lineStart,\n              lineEnd: lineEnd,\n              polygonStart: function () {\n                clip.point = pointRing;\n                clip.lineStart = ringStart;\n                clip.lineEnd = ringEnd;\n                segments = [];\n                polygon = [];\n              },\n              polygonEnd: function () {\n                clip.point = point;\n                clip.lineStart = lineStart;\n                clip.lineEnd = lineEnd;\n                segments = d3.merge(segments);\n                var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\n\n                if (segments.length) {\n                  if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n                  d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\n                } else if (clipStartInside) {\n                  if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n                  listener.lineStart();\n                  interpolate(null, null, 1, listener);\n                  listener.lineEnd();\n                }\n\n                if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\n                segments = polygon = null;\n              },\n              sphere: function () {\n                listener.polygonStart();\n                listener.lineStart();\n                interpolate(null, null, 1, listener);\n                listener.lineEnd();\n                listener.polygonEnd();\n              }\n            };\n\n            function point(λ, φ) {\n              var point = rotate(λ, φ);\n              if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);\n            }\n\n            function pointLine(λ, φ) {\n              var point = rotate(λ, φ);\n              line.point(point[0], point[1]);\n            }\n\n            function lineStart() {\n              clip.point = pointLine;\n              line.lineStart();\n            }\n\n            function lineEnd() {\n              clip.point = point;\n              line.lineEnd();\n            }\n\n            var segments;\n            var buffer = d3_geo_clipBufferListener(),\n                ringListener = clipLine(buffer),\n                polygonStarted = false,\n                polygon,\n                ring;\n\n            function pointRing(λ, φ) {\n              ring.push([λ, φ]);\n              var point = rotate(λ, φ);\n              ringListener.point(point[0], point[1]);\n            }\n\n            function ringStart() {\n              ringListener.lineStart();\n              ring = [];\n            }\n\n            function ringEnd() {\n              pointRing(ring[0][0], ring[0][1]);\n              ringListener.lineEnd();\n              var clean = ringListener.clean(),\n                  ringSegments = buffer.buffer(),\n                  segment,\n                  n = ringSegments.length;\n              ring.pop();\n              polygon.push(ring);\n              ring = null;\n              if (!n) return;\n\n              if (clean & 1) {\n                segment = ringSegments[0];\n                var n = segment.length - 1,\n                    i = -1,\n                    point;\n\n                if (n > 0) {\n                  if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n                  listener.lineStart();\n\n                  while (++i < n) listener.point((point = segment[i])[0], point[1]);\n\n                  listener.lineEnd();\n                }\n\n                return;\n              }\n\n              if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n              segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n            }\n\n            return clip;\n          };\n        }\n\n        function d3_geo_clipSegmentLength1(segment) {\n          return segment.length > 1;\n        }\n\n        function d3_geo_clipBufferListener() {\n          var lines = [],\n              line;\n          return {\n            lineStart: function () {\n              lines.push(line = []);\n            },\n            point: function (λ, φ) {\n              line.push([λ, φ]);\n            },\n            lineEnd: d3_noop,\n            buffer: function () {\n              var buffer = lines;\n              lines = [];\n              line = null;\n              return buffer;\n            },\n            rejoin: function () {\n              if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n            }\n          };\n        }\n\n        function d3_geo_clipSort(a, b) {\n          return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);\n        }\n\n        var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]);\n\n        function d3_geo_clipAntimeridianLine(listener) {\n          var λ0 = NaN,\n              φ0 = NaN,\n              sλ0 = NaN,\n              clean;\n          return {\n            lineStart: function () {\n              listener.lineStart();\n              clean = 1;\n            },\n            point: function (λ1, φ1) {\n              var sλ1 = λ1 > 0 ? π : -π,\n                  dλ = abs(λ1 - λ0);\n\n              if (abs(dλ - π) < ε) {\n                listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);\n                listener.point(sλ0, φ0);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(sλ1, φ0);\n                listener.point(λ1, φ0);\n                clean = 0;\n              } else if (sλ0 !== sλ1 && dλ >= π) {\n                if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\n                if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\n                φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\n                listener.point(sλ0, φ0);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(sλ1, φ0);\n                clean = 0;\n              }\n\n              listener.point(λ0 = λ1, φ0 = φ1);\n              sλ0 = sλ1;\n            },\n            lineEnd: function () {\n              listener.lineEnd();\n              λ0 = φ0 = NaN;\n            },\n            clean: function () {\n              return 2 - clean;\n            }\n          };\n        }\n\n        function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\n          var cosφ0,\n              cosφ1,\n              sinλ0_λ1 = Math.sin(λ0 - λ1);\n          return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\n        }\n\n        function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n          var φ;\n\n          if (from == null) {\n            φ = direction * halfπ;\n            listener.point(-π, φ);\n            listener.point(0, φ);\n            listener.point(π, φ);\n            listener.point(π, 0);\n            listener.point(π, -φ);\n            listener.point(0, -φ);\n            listener.point(-π, -φ);\n            listener.point(-π, 0);\n            listener.point(-π, φ);\n          } else if (abs(from[0] - to[0]) > ε) {\n            var s = from[0] < to[0] ? π : -π;\n            φ = direction * s / 2;\n            listener.point(-s, φ);\n            listener.point(0, φ);\n            listener.point(s, φ);\n          } else {\n            listener.point(to[0], to[1]);\n          }\n        }\n\n        function d3_geo_pointInPolygon(point, polygon) {\n          var meridian = point[0],\n              parallel = point[1],\n              meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],\n              polarAngle = 0,\n              winding = 0;\n          d3_geo_areaRingSum.reset();\n\n          for (var i = 0, n = polygon.length; i < n; ++i) {\n            var ring = polygon[i],\n                m = ring.length;\n            if (!m) continue;\n            var point0 = ring[0],\n                λ0 = point0[0],\n                φ0 = point0[1] / 2 + π / 4,\n                sinφ0 = Math.sin(φ0),\n                cosφ0 = Math.cos(φ0),\n                j = 1;\n\n            while (true) {\n              if (j === m) j = 0;\n              point = ring[j];\n              var λ = point[0],\n                  φ = point[1] / 2 + π / 4,\n                  sinφ = Math.sin(φ),\n                  cosφ = Math.cos(φ),\n                  dλ = λ - λ0,\n                  sdλ = dλ >= 0 ? 1 : -1,\n                  adλ = sdλ * dλ,\n                  antimeridian = adλ > π,\n                  k = sinφ0 * sinφ;\n              d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));\n              polarAngle += antimeridian ? dλ + sdλ * τ : dλ;\n\n              if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {\n                var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\n                d3_geo_cartesianNormalize(arc);\n                var intersection = d3_geo_cartesianCross(meridianNormal, arc);\n                d3_geo_cartesianNormalize(intersection);\n                var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);\n\n                if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {\n                  winding += antimeridian ^ dλ >= 0 ? 1 : -1;\n                }\n              }\n\n              if (!j++) break;\n              λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;\n            }\n          }\n\n          return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;\n        }\n\n        function d3_geo_clipCircle(radius) {\n          var cr = Math.cos(radius),\n              smallRadius = cr > 0,\n              notHemisphere = abs(cr) > ε,\n              interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\n          return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);\n\n          function visible(λ, φ) {\n            return Math.cos(λ) * Math.cos(φ) > cr;\n          }\n\n          function clipLine(listener) {\n            var point0, c0, v0, v00, clean;\n            return {\n              lineStart: function () {\n                v00 = v0 = false;\n                clean = 1;\n              },\n              point: function (λ, φ) {\n                var point1 = [λ, φ],\n                    point2,\n                    v = visible(λ, φ),\n                    c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;\n                if (!point0 && (v00 = v0 = v)) listener.lineStart();\n\n                if (v !== v0) {\n                  point2 = intersect(point0, point1);\n\n                  if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n                    point1[0] += ε;\n                    point1[1] += ε;\n                    v = visible(point1[0], point1[1]);\n                  }\n                }\n\n                if (v !== v0) {\n                  clean = 0;\n\n                  if (v) {\n                    listener.lineStart();\n                    point2 = intersect(point1, point0);\n                    listener.point(point2[0], point2[1]);\n                  } else {\n                    point2 = intersect(point0, point1);\n                    listener.point(point2[0], point2[1]);\n                    listener.lineEnd();\n                  }\n\n                  point0 = point2;\n                } else if (notHemisphere && point0 && smallRadius ^ v) {\n                  var t;\n\n                  if (!(c & c0) && (t = intersect(point1, point0, true))) {\n                    clean = 0;\n\n                    if (smallRadius) {\n                      listener.lineStart();\n                      listener.point(t[0][0], t[0][1]);\n                      listener.point(t[1][0], t[1][1]);\n                      listener.lineEnd();\n                    } else {\n                      listener.point(t[1][0], t[1][1]);\n                      listener.lineEnd();\n                      listener.lineStart();\n                      listener.point(t[0][0], t[0][1]);\n                    }\n                  }\n                }\n\n                if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\n                  listener.point(point1[0], point1[1]);\n                }\n\n                point0 = point1, v0 = v, c0 = c;\n              },\n              lineEnd: function () {\n                if (v0) listener.lineEnd();\n                point0 = null;\n              },\n              clean: function () {\n                return clean | (v00 && v0) << 1;\n              }\n            };\n          }\n\n          function intersect(a, b, two) {\n            var pa = d3_geo_cartesian(a),\n                pb = d3_geo_cartesian(b);\n            var n1 = [1, 0, 0],\n                n2 = d3_geo_cartesianCross(pa, pb),\n                n2n2 = d3_geo_cartesianDot(n2, n2),\n                n1n2 = n2[0],\n                determinant = n2n2 - n1n2 * n1n2;\n            if (!determinant) return !two && a;\n            var c1 = cr * n2n2 / determinant,\n                c2 = -cr * n1n2 / determinant,\n                n1xn2 = d3_geo_cartesianCross(n1, n2),\n                A = d3_geo_cartesianScale(n1, c1),\n                B = d3_geo_cartesianScale(n2, c2);\n            d3_geo_cartesianAdd(A, B);\n            var u = n1xn2,\n                w = d3_geo_cartesianDot(A, u),\n                uu = d3_geo_cartesianDot(u, u),\n                t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\n            if (t2 < 0) return;\n            var t = Math.sqrt(t2),\n                q = d3_geo_cartesianScale(u, (-w - t) / uu);\n            d3_geo_cartesianAdd(q, A);\n            q = d3_geo_spherical(q);\n            if (!two) return q;\n            var λ0 = a[0],\n                λ1 = b[0],\n                φ0 = a[1],\n                φ1 = b[1],\n                z;\n            if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;\n            var δλ = λ1 - λ0,\n                polar = abs(δλ - π) < ε,\n                meridian = polar || δλ < ε;\n            if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;\n\n            if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {\n              var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\n              d3_geo_cartesianAdd(q1, A);\n              return [q, d3_geo_spherical(q1)];\n            }\n          }\n\n          function code(λ, φ) {\n            var r = smallRadius ? radius : π - radius,\n                code = 0;\n            if (λ < -r) code |= 1;else if (λ > r) code |= 2;\n            if (φ < -r) code |= 4;else if (φ > r) code |= 8;\n            return code;\n          }\n        }\n\n        function d3_geom_clipLine(x0, y0, x1, y1) {\n          return function (line) {\n            var a = line.a,\n                b = line.b,\n                ax = a.x,\n                ay = a.y,\n                bx = b.x,\n                by = b.y,\n                t0 = 0,\n                t1 = 1,\n                dx = bx - ax,\n                dy = by - ay,\n                r;\n            r = x0 - ax;\n            if (!dx && r > 0) return;\n            r /= dx;\n\n            if (dx < 0) {\n              if (r < t0) return;\n              if (r < t1) t1 = r;\n            } else if (dx > 0) {\n              if (r > t1) return;\n              if (r > t0) t0 = r;\n            }\n\n            r = x1 - ax;\n            if (!dx && r < 0) return;\n            r /= dx;\n\n            if (dx < 0) {\n              if (r > t1) return;\n              if (r > t0) t0 = r;\n            } else if (dx > 0) {\n              if (r < t0) return;\n              if (r < t1) t1 = r;\n            }\n\n            r = y0 - ay;\n            if (!dy && r > 0) return;\n            r /= dy;\n\n            if (dy < 0) {\n              if (r < t0) return;\n              if (r < t1) t1 = r;\n            } else if (dy > 0) {\n              if (r > t1) return;\n              if (r > t0) t0 = r;\n            }\n\n            r = y1 - ay;\n            if (!dy && r < 0) return;\n            r /= dy;\n\n            if (dy < 0) {\n              if (r > t1) return;\n              if (r > t0) t0 = r;\n            } else if (dy > 0) {\n              if (r < t0) return;\n              if (r < t1) t1 = r;\n            }\n\n            if (t0 > 0) line.a = {\n              x: ax + t0 * dx,\n              y: ay + t0 * dy\n            };\n            if (t1 < 1) line.b = {\n              x: ax + t1 * dx,\n              y: ay + t1 * dy\n            };\n            return line;\n          };\n        }\n\n        var d3_geo_clipExtentMAX = 1e9;\n\n        d3.geo.clipExtent = function () {\n          var x0,\n              y0,\n              x1,\n              y1,\n              stream,\n              clip,\n              clipExtent = {\n            stream: function (output) {\n              if (stream) stream.valid = false;\n              stream = clip(output);\n              stream.valid = true;\n              return stream;\n            },\n            extent: function (_) {\n              if (!arguments.length) return [[x0, y0], [x1, y1]];\n              clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\n              if (stream) stream.valid = false, stream = null;\n              return clipExtent;\n            }\n          };\n          return clipExtent.extent([[0, 0], [960, 500]]);\n        };\n\n        function d3_geo_clipExtent(x0, y0, x1, y1) {\n          return function (listener) {\n            var listener_ = listener,\n                bufferListener = d3_geo_clipBufferListener(),\n                clipLine = d3_geom_clipLine(x0, y0, x1, y1),\n                segments,\n                polygon,\n                ring;\n            var clip = {\n              point: point,\n              lineStart: lineStart,\n              lineEnd: lineEnd,\n              polygonStart: function () {\n                listener = bufferListener;\n                segments = [];\n                polygon = [];\n                clean = true;\n              },\n              polygonEnd: function () {\n                listener = listener_;\n                segments = d3.merge(segments);\n                var clipStartInside = insidePolygon([x0, y1]),\n                    inside = clean && clipStartInside,\n                    visible = segments.length;\n\n                if (inside || visible) {\n                  listener.polygonStart();\n\n                  if (inside) {\n                    listener.lineStart();\n                    interpolate(null, null, 1, listener);\n                    listener.lineEnd();\n                  }\n\n                  if (visible) {\n                    d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\n                  }\n\n                  listener.polygonEnd();\n                }\n\n                segments = polygon = ring = null;\n              }\n            };\n\n            function insidePolygon(p) {\n              var wn = 0,\n                  n = polygon.length,\n                  y = p[1];\n\n              for (var i = 0; i < n; ++i) {\n                for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\n                  b = v[j];\n\n                  if (a[1] <= y) {\n                    if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\n                  } else {\n                    if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\n                  }\n\n                  a = b;\n                }\n              }\n\n              return wn !== 0;\n            }\n\n            function interpolate(from, to, direction, listener) {\n              var a = 0,\n                  a1 = 0;\n\n              if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\n                do {\n                  listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n                } while ((a = (a + direction + 4) % 4) !== a1);\n              } else {\n                listener.point(to[0], to[1]);\n              }\n            }\n\n            function pointVisible(x, y) {\n              return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n            }\n\n            function point(x, y) {\n              if (pointVisible(x, y)) listener.point(x, y);\n            }\n\n            var x__, y__, v__, x_, y_, v_, first, clean;\n\n            function lineStart() {\n              clip.point = linePoint;\n              if (polygon) polygon.push(ring = []);\n              first = true;\n              v_ = false;\n              x_ = y_ = NaN;\n            }\n\n            function lineEnd() {\n              if (segments) {\n                linePoint(x__, y__);\n                if (v__ && v_) bufferListener.rejoin();\n                segments.push(bufferListener.buffer());\n              }\n\n              clip.point = point;\n              if (v_) listener.lineEnd();\n            }\n\n            function linePoint(x, y) {\n              x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\n              y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\n              var v = pointVisible(x, y);\n              if (polygon) ring.push([x, y]);\n\n              if (first) {\n                x__ = x, y__ = y, v__ = v;\n                first = false;\n\n                if (v) {\n                  listener.lineStart();\n                  listener.point(x, y);\n                }\n              } else {\n                if (v && v_) listener.point(x, y);else {\n                  var l = {\n                    a: {\n                      x: x_,\n                      y: y_\n                    },\n                    b: {\n                      x: x,\n                      y: y\n                    }\n                  };\n\n                  if (clipLine(l)) {\n                    if (!v_) {\n                      listener.lineStart();\n                      listener.point(l.a.x, l.a.y);\n                    }\n\n                    listener.point(l.b.x, l.b.y);\n                    if (!v) listener.lineEnd();\n                    clean = false;\n                  } else if (v) {\n                    listener.lineStart();\n                    listener.point(x, y);\n                    clean = false;\n                  }\n                }\n              }\n\n              x_ = x, y_ = y, v_ = v;\n            }\n\n            return clip;\n          };\n\n          function corner(p, direction) {\n            return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n          }\n\n          function compare(a, b) {\n            return comparePoints(a.x, b.x);\n          }\n\n          function comparePoints(a, b) {\n            var ca = corner(a, 1),\n                cb = corner(b, 1);\n            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n          }\n        }\n\n        function d3_geo_conic(projectAt) {\n          var φ0 = 0,\n              φ1 = π / 3,\n              m = d3_geo_projectionMutator(projectAt),\n              p = m(φ0, φ1);\n\n          p.parallels = function (_) {\n            if (!arguments.length) return [φ0 / π * 180, φ1 / π * 180];\n            return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);\n          };\n\n          return p;\n        }\n\n        function d3_geo_conicEqualArea(φ0, φ1) {\n          var sinφ0 = Math.sin(φ0),\n              n = (sinφ0 + Math.sin(φ1)) / 2,\n              C = 1 + sinφ0 * (2 * n - sinφ0),\n              ρ0 = Math.sqrt(C) / n;\n\n          function forward(λ, φ) {\n            var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\n            return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];\n          }\n\n          forward.invert = function (x, y) {\n            var ρ0_y = ρ0 - y;\n            return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];\n          };\n\n          return forward;\n        }\n\n        (d3.geo.conicEqualArea = function () {\n          return d3_geo_conic(d3_geo_conicEqualArea);\n        }).raw = d3_geo_conicEqualArea;\n\n        d3.geo.albers = function () {\n          return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);\n        };\n\n        d3.geo.albersUsa = function () {\n          var lower48 = d3.geo.albers();\n          var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);\n          var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);\n          var point,\n              pointStream = {\n            point: function (x, y) {\n              point = [x, y];\n            }\n          },\n              lower48Point,\n              alaskaPoint,\n              hawaiiPoint;\n\n          function albersUsa(coordinates) {\n            var x = coordinates[0],\n                y = coordinates[1];\n            point = null;\n            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);\n            return point;\n          }\n\n          albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(),\n                t = lower48.translate(),\n                x = (coordinates[0] - t[0]) / k,\n                y = (coordinates[1] - t[1]) / k;\n            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\n          };\n\n          albersUsa.stream = function (stream) {\n            var lower48Stream = lower48.stream(stream),\n                alaskaStream = alaska.stream(stream),\n                hawaiiStream = hawaii.stream(stream);\n            return {\n              point: function (x, y) {\n                lower48Stream.point(x, y);\n                alaskaStream.point(x, y);\n                hawaiiStream.point(x, y);\n              },\n              sphere: function () {\n                lower48Stream.sphere();\n                alaskaStream.sphere();\n                hawaiiStream.sphere();\n              },\n              lineStart: function () {\n                lower48Stream.lineStart();\n                alaskaStream.lineStart();\n                hawaiiStream.lineStart();\n              },\n              lineEnd: function () {\n                lower48Stream.lineEnd();\n                alaskaStream.lineEnd();\n                hawaiiStream.lineEnd();\n              },\n              polygonStart: function () {\n                lower48Stream.polygonStart();\n                alaskaStream.polygonStart();\n                hawaiiStream.polygonStart();\n              },\n              polygonEnd: function () {\n                lower48Stream.polygonEnd();\n                alaskaStream.polygonEnd();\n                hawaiiStream.polygonEnd();\n              }\n            };\n          };\n\n          albersUsa.precision = function (_) {\n            if (!arguments.length) return lower48.precision();\n            lower48.precision(_);\n            alaska.precision(_);\n            hawaii.precision(_);\n            return albersUsa;\n          };\n\n          albersUsa.scale = function (_) {\n            if (!arguments.length) return lower48.scale();\n            lower48.scale(_);\n            alaska.scale(_ * .35);\n            hawaii.scale(_);\n            return albersUsa.translate(lower48.translate());\n          };\n\n          albersUsa.translate = function (_) {\n            if (!arguments.length) return lower48.translate();\n            var k = lower48.scale(),\n                x = +_[0],\n                y = +_[1];\n            lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;\n            alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .12 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;\n            hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;\n            return albersUsa;\n          };\n\n          return albersUsa.scale(1070);\n        };\n\n        var d3_geo_pathAreaSum,\n            d3_geo_pathAreaPolygon,\n            d3_geo_pathArea = {\n          point: d3_noop,\n          lineStart: d3_noop,\n          lineEnd: d3_noop,\n          polygonStart: function () {\n            d3_geo_pathAreaPolygon = 0;\n            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n          },\n          polygonEnd: function () {\n            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n            d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\n          }\n        };\n\n        function d3_geo_pathAreaRingStart() {\n          var x00, y00, x0, y0;\n\n          d3_geo_pathArea.point = function (x, y) {\n            d3_geo_pathArea.point = nextPoint;\n            x00 = x0 = x, y00 = y0 = y;\n          };\n\n          function nextPoint(x, y) {\n            d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n            x0 = x, y0 = y;\n          }\n\n          d3_geo_pathArea.lineEnd = function () {\n            nextPoint(x00, y00);\n          };\n        }\n\n        var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\n        var d3_geo_pathBounds = {\n          point: d3_geo_pathBoundsPoint,\n          lineStart: d3_noop,\n          lineEnd: d3_noop,\n          polygonStart: d3_noop,\n          polygonEnd: d3_noop\n        };\n\n        function d3_geo_pathBoundsPoint(x, y) {\n          if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\n          if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\n          if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\n          if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\n        }\n\n        function d3_geo_pathBuffer() {\n          var pointCircle = d3_geo_pathBufferCircle(4.5),\n              buffer = [];\n          var stream = {\n            point: point,\n            lineStart: function () {\n              stream.point = pointLineStart;\n            },\n            lineEnd: lineEnd,\n            polygonStart: function () {\n              stream.lineEnd = lineEndPolygon;\n            },\n            polygonEnd: function () {\n              stream.lineEnd = lineEnd;\n              stream.point = point;\n            },\n            pointRadius: function (_) {\n              pointCircle = d3_geo_pathBufferCircle(_);\n              return stream;\n            },\n            result: function () {\n              if (buffer.length) {\n                var result = buffer.join(\"\");\n                buffer = [];\n                return result;\n              }\n            }\n          };\n\n          function point(x, y) {\n            buffer.push(\"M\", x, \",\", y, pointCircle);\n          }\n\n          function pointLineStart(x, y) {\n            buffer.push(\"M\", x, \",\", y);\n            stream.point = pointLine;\n          }\n\n          function pointLine(x, y) {\n            buffer.push(\"L\", x, \",\", y);\n          }\n\n          function lineEnd() {\n            stream.point = point;\n          }\n\n          function lineEndPolygon() {\n            buffer.push(\"Z\");\n          }\n\n          return stream;\n        }\n\n        function d3_geo_pathBufferCircle(radius) {\n          return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius + \"z\";\n        }\n\n        var d3_geo_pathCentroid = {\n          point: d3_geo_pathCentroidPoint,\n          lineStart: d3_geo_pathCentroidLineStart,\n          lineEnd: d3_geo_pathCentroidLineEnd,\n          polygonStart: function () {\n            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n          },\n          polygonEnd: function () {\n            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n          }\n        };\n\n        function d3_geo_pathCentroidPoint(x, y) {\n          d3_geo_centroidX0 += x;\n          d3_geo_centroidY0 += y;\n          ++d3_geo_centroidZ0;\n        }\n\n        function d3_geo_pathCentroidLineStart() {\n          var x0, y0;\n\n          d3_geo_pathCentroid.point = function (x, y) {\n            d3_geo_pathCentroid.point = nextPoint;\n            d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n          };\n\n          function nextPoint(x, y) {\n            var dx = x - x0,\n                dy = y - y0,\n                z = Math.sqrt(dx * dx + dy * dy);\n            d3_geo_centroidX1 += z * (x0 + x) / 2;\n            d3_geo_centroidY1 += z * (y0 + y) / 2;\n            d3_geo_centroidZ1 += z;\n            d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n          }\n        }\n\n        function d3_geo_pathCentroidLineEnd() {\n          d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n        }\n\n        function d3_geo_pathCentroidRingStart() {\n          var x00, y00, x0, y0;\n\n          d3_geo_pathCentroid.point = function (x, y) {\n            d3_geo_pathCentroid.point = nextPoint;\n            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\n          };\n\n          function nextPoint(x, y) {\n            var dx = x - x0,\n                dy = y - y0,\n                z = Math.sqrt(dx * dx + dy * dy);\n            d3_geo_centroidX1 += z * (x0 + x) / 2;\n            d3_geo_centroidY1 += z * (y0 + y) / 2;\n            d3_geo_centroidZ1 += z;\n            z = y0 * x - x0 * y;\n            d3_geo_centroidX2 += z * (x0 + x);\n            d3_geo_centroidY2 += z * (y0 + y);\n            d3_geo_centroidZ2 += z * 3;\n            d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n          }\n\n          d3_geo_pathCentroid.lineEnd = function () {\n            nextPoint(x00, y00);\n          };\n        }\n\n        function d3_geo_pathContext(context) {\n          var pointRadius = 4.5;\n          var stream = {\n            point: point,\n            lineStart: function () {\n              stream.point = pointLineStart;\n            },\n            lineEnd: lineEnd,\n            polygonStart: function () {\n              stream.lineEnd = lineEndPolygon;\n            },\n            polygonEnd: function () {\n              stream.lineEnd = lineEnd;\n              stream.point = point;\n            },\n            pointRadius: function (_) {\n              pointRadius = _;\n              return stream;\n            },\n            result: d3_noop\n          };\n\n          function point(x, y) {\n            context.moveTo(x + pointRadius, y);\n            context.arc(x, y, pointRadius, 0, τ);\n          }\n\n          function pointLineStart(x, y) {\n            context.moveTo(x, y);\n            stream.point = pointLine;\n          }\n\n          function pointLine(x, y) {\n            context.lineTo(x, y);\n          }\n\n          function lineEnd() {\n            stream.point = point;\n          }\n\n          function lineEndPolygon() {\n            context.closePath();\n          }\n\n          return stream;\n        }\n\n        function d3_geo_resample(project) {\n          var δ2 = .5,\n              cosMinDistance = Math.cos(30 * d3_radians),\n              maxDepth = 16;\n\n          function resample(stream) {\n            return (maxDepth ? resampleRecursive : resampleNone)(stream);\n          }\n\n          function resampleNone(stream) {\n            return d3_geo_transformPoint(stream, function (x, y) {\n              x = project(x, y);\n              stream.point(x[0], x[1]);\n            });\n          }\n\n          function resampleRecursive(stream) {\n            var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;\n            var resample = {\n              point: point,\n              lineStart: lineStart,\n              lineEnd: lineEnd,\n              polygonStart: function () {\n                stream.polygonStart();\n                resample.lineStart = ringStart;\n              },\n              polygonEnd: function () {\n                stream.polygonEnd();\n                resample.lineStart = lineStart;\n              }\n            };\n\n            function point(x, y) {\n              x = project(x, y);\n              stream.point(x[0], x[1]);\n            }\n\n            function lineStart() {\n              x0 = NaN;\n              resample.point = linePoint;\n              stream.lineStart();\n            }\n\n            function linePoint(λ, φ) {\n              var c = d3_geo_cartesian([λ, φ]),\n                  p = project(λ, φ);\n              resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n              stream.point(x0, y0);\n            }\n\n            function lineEnd() {\n              resample.point = point;\n              stream.lineEnd();\n            }\n\n            function ringStart() {\n              lineStart();\n              resample.point = ringPoint;\n              resample.lineEnd = ringEnd;\n            }\n\n            function ringPoint(λ, φ) {\n              linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n              resample.point = linePoint;\n            }\n\n            function ringEnd() {\n              resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\n              resample.lineEnd = lineEnd;\n              lineEnd();\n            }\n\n            return resample;\n          }\n\n          function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\n            var dx = x1 - x0,\n                dy = y1 - y0,\n                d2 = dx * dx + dy * dy;\n\n            if (d2 > 4 * δ2 && depth--) {\n              var a = a0 + a1,\n                  b = b0 + b1,\n                  c = c0 + c1,\n                  m = Math.sqrt(a * a + b * b + c * c),\n                  φ2 = Math.asin(c /= m),\n                  λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),\n                  p = project(λ2, φ2),\n                  x2 = p[0],\n                  y2 = p[1],\n                  dx2 = x2 - x0,\n                  dy2 = y2 - y0,\n                  dz = dy * dx2 - dx * dy2;\n\n              if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n                resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\n                stream.point(x2, y2);\n                resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\n              }\n            }\n          }\n\n          resample.precision = function (_) {\n            if (!arguments.length) return Math.sqrt(δ2);\n            maxDepth = (δ2 = _ * _) > 0 && 16;\n            return resample;\n          };\n\n          return resample;\n        }\n\n        d3.geo.path = function () {\n          var pointRadius = 4.5,\n              projection,\n              context,\n              projectStream,\n              contextStream,\n              cacheStream;\n\n          function path(object) {\n            if (object) {\n              if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n              if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\n              d3.geo.stream(object, cacheStream);\n            }\n\n            return contextStream.result();\n          }\n\n          path.area = function (object) {\n            d3_geo_pathAreaSum = 0;\n            d3.geo.stream(object, projectStream(d3_geo_pathArea));\n            return d3_geo_pathAreaSum;\n          };\n\n          path.centroid = function (object) {\n            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n            return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];\n          };\n\n          path.bounds = function (object) {\n            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\n            d3.geo.stream(object, projectStream(d3_geo_pathBounds));\n            return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];\n          };\n\n          path.projection = function (_) {\n            if (!arguments.length) return projection;\n            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n            return reset();\n          };\n\n          path.context = function (_) {\n            if (!arguments.length) return context;\n            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n            if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n            return reset();\n          };\n\n          path.pointRadius = function (_) {\n            if (!arguments.length) return pointRadius;\n            pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n            return path;\n          };\n\n          function reset() {\n            cacheStream = null;\n            return path;\n          }\n\n          return path.projection(d3.geo.albersUsa()).context(null);\n        };\n\n        function d3_geo_pathProjectStream(project) {\n          var resample = d3_geo_resample(function (x, y) {\n            return project([x * d3_degrees, y * d3_degrees]);\n          });\n          return function (stream) {\n            return d3_geo_projectionRadians(resample(stream));\n          };\n        }\n\n        d3.geo.transform = function (methods) {\n          return {\n            stream: function (stream) {\n              var transform = new d3_geo_transform(stream);\n\n              for (var k in methods) transform[k] = methods[k];\n\n              return transform;\n            }\n          };\n        };\n\n        function d3_geo_transform(stream) {\n          this.stream = stream;\n        }\n\n        d3_geo_transform.prototype = {\n          point: function (x, y) {\n            this.stream.point(x, y);\n          },\n          sphere: function () {\n            this.stream.sphere();\n          },\n          lineStart: function () {\n            this.stream.lineStart();\n          },\n          lineEnd: function () {\n            this.stream.lineEnd();\n          },\n          polygonStart: function () {\n            this.stream.polygonStart();\n          },\n          polygonEnd: function () {\n            this.stream.polygonEnd();\n          }\n        };\n\n        function d3_geo_transformPoint(stream, point) {\n          return {\n            point: point,\n            sphere: function () {\n              stream.sphere();\n            },\n            lineStart: function () {\n              stream.lineStart();\n            },\n            lineEnd: function () {\n              stream.lineEnd();\n            },\n            polygonStart: function () {\n              stream.polygonStart();\n            },\n            polygonEnd: function () {\n              stream.polygonEnd();\n            }\n          };\n        }\n\n        d3.geo.projection = d3_geo_projection;\n        d3.geo.projectionMutator = d3_geo_projectionMutator;\n\n        function d3_geo_projection(project) {\n          return d3_geo_projectionMutator(function () {\n            return project;\n          })();\n        }\n\n        function d3_geo_projectionMutator(projectAt) {\n          var project,\n              rotate,\n              projectRotate,\n              projectResample = d3_geo_resample(function (x, y) {\n            x = project(x, y);\n            return [x[0] * k + δx, δy - x[1] * k];\n          }),\n              k = 150,\n              x = 480,\n              y = 250,\n              λ = 0,\n              φ = 0,\n              δλ = 0,\n              δφ = 0,\n              δγ = 0,\n              δx,\n              δy,\n              preclip = d3_geo_clipAntimeridian,\n              postclip = d3_identity,\n              clipAngle = null,\n              clipExtent = null,\n              stream;\n\n          function projection(point) {\n            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n            return [point[0] * k + δx, δy - point[1] * k];\n          }\n\n          function invert(point) {\n            point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\n            return point && [point[0] * d3_degrees, point[1] * d3_degrees];\n          }\n\n          projection.stream = function (output) {\n            if (stream) stream.valid = false;\n            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\n            stream.valid = true;\n            return stream;\n          };\n\n          projection.clipAngle = function (_) {\n            if (!arguments.length) return clipAngle;\n            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\n            return invalidate();\n          };\n\n          projection.clipExtent = function (_) {\n            if (!arguments.length) return clipExtent;\n            clipExtent = _;\n            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\n            return invalidate();\n          };\n\n          projection.scale = function (_) {\n            if (!arguments.length) return k;\n            k = +_;\n            return reset();\n          };\n\n          projection.translate = function (_) {\n            if (!arguments.length) return [x, y];\n            x = +_[0];\n            y = +_[1];\n            return reset();\n          };\n\n          projection.center = function (_) {\n            if (!arguments.length) return [λ * d3_degrees, φ * d3_degrees];\n            λ = _[0] % 360 * d3_radians;\n            φ = _[1] % 360 * d3_radians;\n            return reset();\n          };\n\n          projection.rotate = function (_) {\n            if (!arguments.length) return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];\n            δλ = _[0] % 360 * d3_radians;\n            δφ = _[1] % 360 * d3_radians;\n            δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n            return reset();\n          };\n\n          d3.rebind(projection, projectResample, \"precision\");\n\n          function reset() {\n            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\n            var center = project(λ, φ);\n            δx = x - center[0] * k;\n            δy = y + center[1] * k;\n            return invalidate();\n          }\n\n          function invalidate() {\n            if (stream) stream.valid = false, stream = null;\n            return projection;\n          }\n\n          return function () {\n            project = projectAt.apply(this, arguments);\n            projection.invert = project.invert && invert;\n            return reset();\n          };\n        }\n\n        function d3_geo_projectionRadians(stream) {\n          return d3_geo_transformPoint(stream, function (x, y) {\n            stream.point(x * d3_radians, y * d3_radians);\n          });\n        }\n\n        function d3_geo_equirectangular(λ, φ) {\n          return [λ, φ];\n        }\n\n        (d3.geo.equirectangular = function () {\n          return d3_geo_projection(d3_geo_equirectangular);\n        }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n\n        d3.geo.rotation = function (rotate) {\n          rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\n\n          function forward(coordinates) {\n            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n          }\n\n          forward.invert = function (coordinates) {\n            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n          };\n\n          return forward;\n        };\n\n        function d3_geo_identityRotation(λ, φ) {\n          return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];\n        }\n\n        d3_geo_identityRotation.invert = d3_geo_equirectangular;\n\n        function d3_geo_rotation(δλ, δφ, δγ) {\n          return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;\n        }\n\n        function d3_geo_forwardRotationλ(δλ) {\n          return function (λ, φ) {\n            return λ += δλ, [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];\n          };\n        }\n\n        function d3_geo_rotationλ(δλ) {\n          var rotation = d3_geo_forwardRotationλ(δλ);\n          rotation.invert = d3_geo_forwardRotationλ(-δλ);\n          return rotation;\n        }\n\n        function d3_geo_rotationφγ(δφ, δγ) {\n          var cosδφ = Math.cos(δφ),\n              sinδφ = Math.sin(δφ),\n              cosδγ = Math.cos(δγ),\n              sinδγ = Math.sin(δγ);\n\n          function rotation(λ, φ) {\n            var cosφ = Math.cos(φ),\n                x = Math.cos(λ) * cosφ,\n                y = Math.sin(λ) * cosφ,\n                z = Math.sin(φ),\n                k = z * cosδφ + x * sinδφ;\n            return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];\n          }\n\n          rotation.invert = function (λ, φ) {\n            var cosφ = Math.cos(φ),\n                x = Math.cos(λ) * cosφ,\n                y = Math.sin(λ) * cosφ,\n                z = Math.sin(φ),\n                k = z * cosδγ - y * sinδγ;\n            return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];\n          };\n\n          return rotation;\n        }\n\n        d3.geo.circle = function () {\n          var origin = [0, 0],\n              angle,\n              precision = 6,\n              interpolate;\n\n          function circle() {\n            var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin,\n                rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,\n                ring = [];\n            interpolate(null, null, 1, {\n              point: function (x, y) {\n                ring.push(x = rotate(x, y));\n                x[0] *= d3_degrees, x[1] *= d3_degrees;\n              }\n            });\n            return {\n              type: \"Polygon\",\n              coordinates: [ring]\n            };\n          }\n\n          circle.origin = function (x) {\n            if (!arguments.length) return origin;\n            origin = x;\n            return circle;\n          };\n\n          circle.angle = function (x) {\n            if (!arguments.length) return angle;\n            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n            return circle;\n          };\n\n          circle.precision = function (_) {\n            if (!arguments.length) return precision;\n            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n            return circle;\n          };\n\n          return circle.angle(90);\n        };\n\n        function d3_geo_circleInterpolate(radius, precision) {\n          var cr = Math.cos(radius),\n              sr = Math.sin(radius);\n          return function (from, to, direction, listener) {\n            var step = direction * precision;\n\n            if (from != null) {\n              from = d3_geo_circleAngle(cr, from);\n              to = d3_geo_circleAngle(cr, to);\n              if (direction > 0 ? from < to : from > to) from += direction * τ;\n            } else {\n              from = radius + direction * τ;\n              to = radius - .5 * step;\n            }\n\n            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\n              listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);\n            }\n          };\n        }\n\n        function d3_geo_circleAngle(cr, point) {\n          var a = d3_geo_cartesian(point);\n          a[0] -= cr;\n          d3_geo_cartesianNormalize(a);\n          var angle = d3_acos(-a[1]);\n          return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\n        }\n\n        d3.geo.distance = function (a, b) {\n          var Δλ = (b[0] - a[0]) * d3_radians,\n              φ0 = a[1] * d3_radians,\n              φ1 = b[1] * d3_radians,\n              sinΔλ = Math.sin(Δλ),\n              cosΔλ = Math.cos(Δλ),\n              sinφ0 = Math.sin(φ0),\n              cosφ0 = Math.cos(φ0),\n              sinφ1 = Math.sin(φ1),\n              cosφ1 = Math.cos(φ1),\n              t;\n          return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);\n        };\n\n        d3.geo.graticule = function () {\n          var x1,\n              x0,\n              X1,\n              X0,\n              y1,\n              y0,\n              Y1,\n              Y0,\n              dx = 10,\n              dy = dx,\n              DX = 90,\n              DY = 360,\n              x,\n              y,\n              X,\n              Y,\n              precision = 2.5;\n\n          function graticule() {\n            return {\n              type: \"MultiLineString\",\n              coordinates: lines()\n            };\n          }\n\n          function lines() {\n            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {\n              return abs(x % DX) > ε;\n            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {\n              return abs(y % DY) > ε;\n            }).map(y));\n          }\n\n          graticule.lines = function () {\n            return lines().map(function (coordinates) {\n              return {\n                type: \"LineString\",\n                coordinates: coordinates\n              };\n            });\n          };\n\n          graticule.outline = function () {\n            return {\n              type: \"Polygon\",\n              coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]\n            };\n          };\n\n          graticule.extent = function (_) {\n            if (!arguments.length) return graticule.minorExtent();\n            return graticule.majorExtent(_).minorExtent(_);\n          };\n\n          graticule.majorExtent = function (_) {\n            if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n            X0 = +_[0][0], X1 = +_[1][0];\n            Y0 = +_[0][1], Y1 = +_[1][1];\n            if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n            if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n            return graticule.precision(precision);\n          };\n\n          graticule.minorExtent = function (_) {\n            if (!arguments.length) return [[x0, y0], [x1, y1]];\n            x0 = +_[0][0], x1 = +_[1][0];\n            y0 = +_[0][1], y1 = +_[1][1];\n            if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n            if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n            return graticule.precision(precision);\n          };\n\n          graticule.step = function (_) {\n            if (!arguments.length) return graticule.minorStep();\n            return graticule.majorStep(_).minorStep(_);\n          };\n\n          graticule.majorStep = function (_) {\n            if (!arguments.length) return [DX, DY];\n            DX = +_[0], DY = +_[1];\n            return graticule;\n          };\n\n          graticule.minorStep = function (_) {\n            if (!arguments.length) return [dx, dy];\n            dx = +_[0], dy = +_[1];\n            return graticule;\n          };\n\n          graticule.precision = function (_) {\n            if (!arguments.length) return precision;\n            precision = +_;\n            x = d3_geo_graticuleX(y0, y1, 90);\n            y = d3_geo_graticuleY(x0, x1, precision);\n            X = d3_geo_graticuleX(Y0, Y1, 90);\n            Y = d3_geo_graticuleY(X0, X1, precision);\n            return graticule;\n          };\n\n          return graticule.majorExtent([[-180, -90 + ε], [180, 90 - ε]]).minorExtent([[-180, -80 - ε], [180, 80 + ε]]);\n        };\n\n        function d3_geo_graticuleX(y0, y1, dy) {\n          var y = d3.range(y0, y1 - ε, dy).concat(y1);\n          return function (x) {\n            return y.map(function (y) {\n              return [x, y];\n            });\n          };\n        }\n\n        function d3_geo_graticuleY(x0, x1, dx) {\n          var x = d3.range(x0, x1 - ε, dx).concat(x1);\n          return function (y) {\n            return x.map(function (x) {\n              return [x, y];\n            });\n          };\n        }\n\n        function d3_source(d) {\n          return d.source;\n        }\n\n        function d3_target(d) {\n          return d.target;\n        }\n\n        d3.geo.greatArc = function () {\n          var source = d3_source,\n              source_,\n              target = d3_target,\n              target_;\n\n          function greatArc() {\n            return {\n              type: \"LineString\",\n              coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]\n            };\n          }\n\n          greatArc.distance = function () {\n            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));\n          };\n\n          greatArc.source = function (_) {\n            if (!arguments.length) return source;\n            source = _, source_ = typeof _ === \"function\" ? null : _;\n            return greatArc;\n          };\n\n          greatArc.target = function (_) {\n            if (!arguments.length) return target;\n            target = _, target_ = typeof _ === \"function\" ? null : _;\n            return greatArc;\n          };\n\n          greatArc.precision = function () {\n            return arguments.length ? greatArc : 0;\n          };\n\n          return greatArc;\n        };\n\n        d3.geo.interpolate = function (source, target) {\n          return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\n        };\n\n        function d3_geo_interpolate(x0, y0, x1, y1) {\n          var cy0 = Math.cos(y0),\n              sy0 = Math.sin(y0),\n              cy1 = Math.cos(y1),\n              sy1 = Math.sin(y1),\n              kx0 = cy0 * Math.cos(x0),\n              ky0 = cy0 * Math.sin(x0),\n              kx1 = cy1 * Math.cos(x1),\n              ky1 = cy1 * Math.sin(x1),\n              d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))),\n              k = 1 / Math.sin(d);\n          var interpolate = d ? function (t) {\n            var B = Math.sin(t *= d) * k,\n                A = Math.sin(d - t) * k,\n                x = A * kx0 + B * kx1,\n                y = A * ky0 + B * ky1,\n                z = A * sy0 + B * sy1;\n            return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];\n          } : function () {\n            return [x0 * d3_degrees, y0 * d3_degrees];\n          };\n          interpolate.distance = d;\n          return interpolate;\n        }\n\n        d3.geo.length = function (object) {\n          d3_geo_lengthSum = 0;\n          d3.geo.stream(object, d3_geo_length);\n          return d3_geo_lengthSum;\n        };\n\n        var d3_geo_lengthSum;\n        var d3_geo_length = {\n          sphere: d3_noop,\n          point: d3_noop,\n          lineStart: d3_geo_lengthLineStart,\n          lineEnd: d3_noop,\n          polygonStart: d3_noop,\n          polygonEnd: d3_noop\n        };\n\n        function d3_geo_lengthLineStart() {\n          var λ0, sinφ0, cosφ0;\n\n          d3_geo_length.point = function (λ, φ) {\n            λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);\n            d3_geo_length.point = nextPoint;\n          };\n\n          d3_geo_length.lineEnd = function () {\n            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\n          };\n\n          function nextPoint(λ, φ) {\n            var sinφ = Math.sin(φ *= d3_radians),\n                cosφ = Math.cos(φ),\n                t = abs((λ *= d3_radians) - λ0),\n                cosΔλ = Math.cos(t);\n            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);\n            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;\n          }\n        }\n\n        function d3_geo_azimuthal(scale, angle) {\n          function azimuthal(λ, φ) {\n            var cosλ = Math.cos(λ),\n                cosφ = Math.cos(φ),\n                k = scale(cosλ * cosφ);\n            return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];\n          }\n\n          azimuthal.invert = function (x, y) {\n            var ρ = Math.sqrt(x * x + y * y),\n                c = angle(ρ),\n                sinc = Math.sin(c),\n                cosc = Math.cos(c);\n            return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];\n          };\n\n          return azimuthal;\n        }\n\n        var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (cosλcosφ) {\n          return Math.sqrt(2 / (1 + cosλcosφ));\n        }, function (ρ) {\n          return 2 * Math.asin(ρ / 2);\n        });\n        (d3.geo.azimuthalEqualArea = function () {\n          return d3_geo_projection(d3_geo_azimuthalEqualArea);\n        }).raw = d3_geo_azimuthalEqualArea;\n        var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (cosλcosφ) {\n          var c = Math.acos(cosλcosφ);\n          return c && c / Math.sin(c);\n        }, d3_identity);\n        (d3.geo.azimuthalEquidistant = function () {\n          return d3_geo_projection(d3_geo_azimuthalEquidistant);\n        }).raw = d3_geo_azimuthalEquidistant;\n\n        function d3_geo_conicConformal(φ0, φ1) {\n          var cosφ0 = Math.cos(φ0),\n              t = function (φ) {\n            return Math.tan(π / 4 + φ / 2);\n          },\n              n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)),\n              F = cosφ0 * Math.pow(t(φ0), n) / n;\n\n          if (!n) return d3_geo_mercator;\n\n          function forward(λ, φ) {\n            if (F > 0) {\n              if (φ < -halfπ + ε) φ = -halfπ + ε;\n            } else {\n              if (φ > halfπ - ε) φ = halfπ - ε;\n            }\n\n            var ρ = F / Math.pow(t(φ), n);\n            return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];\n          }\n\n          forward.invert = function (x, y) {\n            var ρ0_y = F - y,\n                ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);\n            return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ];\n          };\n\n          return forward;\n        }\n\n        (d3.geo.conicConformal = function () {\n          return d3_geo_conic(d3_geo_conicConformal);\n        }).raw = d3_geo_conicConformal;\n\n        function d3_geo_conicEquidistant(φ0, φ1) {\n          var cosφ0 = Math.cos(φ0),\n              n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0),\n              G = cosφ0 / n + φ0;\n          if (abs(n) < ε) return d3_geo_equirectangular;\n\n          function forward(λ, φ) {\n            var ρ = G - φ;\n            return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];\n          }\n\n          forward.invert = function (x, y) {\n            var ρ0_y = G - y;\n            return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];\n          };\n\n          return forward;\n        }\n\n        (d3.geo.conicEquidistant = function () {\n          return d3_geo_conic(d3_geo_conicEquidistant);\n        }).raw = d3_geo_conicEquidistant;\n        var d3_geo_gnomonic = d3_geo_azimuthal(function (cosλcosφ) {\n          return 1 / cosλcosφ;\n        }, Math.atan);\n        (d3.geo.gnomonic = function () {\n          return d3_geo_projection(d3_geo_gnomonic);\n        }).raw = d3_geo_gnomonic;\n\n        function d3_geo_mercator(λ, φ) {\n          return [λ, Math.log(Math.tan(π / 4 + φ / 2))];\n        }\n\n        d3_geo_mercator.invert = function (x, y) {\n          return [x, 2 * Math.atan(Math.exp(y)) - halfπ];\n        };\n\n        function d3_geo_mercatorProjection(project) {\n          var m = d3_geo_projection(project),\n              scale = m.scale,\n              translate = m.translate,\n              clipExtent = m.clipExtent,\n              clipAuto;\n\n          m.scale = function () {\n            var v = scale.apply(m, arguments);\n            return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n          };\n\n          m.translate = function () {\n            var v = translate.apply(m, arguments);\n            return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n          };\n\n          m.clipExtent = function (_) {\n            var v = clipExtent.apply(m, arguments);\n\n            if (v === m) {\n              if (clipAuto = _ == null) {\n                var k = π * scale(),\n                    t = translate();\n                clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);\n              }\n            } else if (clipAuto) {\n              v = null;\n            }\n\n            return v;\n          };\n\n          return m.clipExtent(null);\n        }\n\n        (d3.geo.mercator = function () {\n          return d3_geo_mercatorProjection(d3_geo_mercator);\n        }).raw = d3_geo_mercator;\n        var d3_geo_orthographic = d3_geo_azimuthal(function () {\n          return 1;\n        }, Math.asin);\n        (d3.geo.orthographic = function () {\n          return d3_geo_projection(d3_geo_orthographic);\n        }).raw = d3_geo_orthographic;\n        var d3_geo_stereographic = d3_geo_azimuthal(function (cosλcosφ) {\n          return 1 / (1 + cosλcosφ);\n        }, function (ρ) {\n          return 2 * Math.atan(ρ);\n        });\n        (d3.geo.stereographic = function () {\n          return d3_geo_projection(d3_geo_stereographic);\n        }).raw = d3_geo_stereographic;\n\n        function d3_geo_transverseMercator(λ, φ) {\n          return [Math.log(Math.tan(π / 4 + φ / 2)), -λ];\n        }\n\n        d3_geo_transverseMercator.invert = function (x, y) {\n          return [-y, 2 * Math.atan(Math.exp(x)) - halfπ];\n        };\n\n        (d3.geo.transverseMercator = function () {\n          var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator),\n              center = projection.center,\n              rotate = projection.rotate;\n\n          projection.center = function (_) {\n            return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n          };\n\n          projection.rotate = function (_) {\n            return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n          };\n\n          return rotate([0, 0, 90]);\n        }).raw = d3_geo_transverseMercator;\n        d3.geom = {};\n\n        function d3_geom_pointX(d) {\n          return d[0];\n        }\n\n        function d3_geom_pointY(d) {\n          return d[1];\n        }\n\n        d3.geom.hull = function (vertices) {\n          var x = d3_geom_pointX,\n              y = d3_geom_pointY;\n          if (arguments.length) return hull(vertices);\n\n          function hull(data) {\n            if (data.length < 3) return [];\n            var fx = d3_functor(x),\n                fy = d3_functor(y),\n                i,\n                n = data.length,\n                points = [],\n                flippedPoints = [];\n\n            for (i = 0; i < n; i++) {\n              points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);\n            }\n\n            points.sort(d3_geom_hullOrder);\n\n            for (i = 0; i < n; i++) flippedPoints.push([points[i][0], -points[i][1]]);\n\n            var upper = d3_geom_hullUpper(points),\n                lower = d3_geom_hullUpper(flippedPoints);\n            var skipLeft = lower[0] === upper[0],\n                skipRight = lower[lower.length - 1] === upper[upper.length - 1],\n                polygon = [];\n\n            for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);\n\n            for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);\n\n            return polygon;\n          }\n\n          hull.x = function (_) {\n            return arguments.length ? (x = _, hull) : x;\n          };\n\n          hull.y = function (_) {\n            return arguments.length ? (y = _, hull) : y;\n          };\n\n          return hull;\n        };\n\n        function d3_geom_hullUpper(points) {\n          var n = points.length,\n              hull = [0, 1],\n              hs = 2;\n\n          for (var i = 2; i < n; i++) {\n            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;\n\n            hull[hs++] = i;\n          }\n\n          return hull.slice(0, hs);\n        }\n\n        function d3_geom_hullOrder(a, b) {\n          return a[0] - b[0] || a[1] - b[1];\n        }\n\n        d3.geom.polygon = function (coordinates) {\n          d3_subclass(coordinates, d3_geom_polygonPrototype);\n          return coordinates;\n        };\n\n        var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\n\n        d3_geom_polygonPrototype.area = function () {\n          var i = -1,\n              n = this.length,\n              a,\n              b = this[n - 1],\n              area = 0;\n\n          while (++i < n) {\n            a = b;\n            b = this[i];\n            area += a[1] * b[0] - a[0] * b[1];\n          }\n\n          return area * .5;\n        };\n\n        d3_geom_polygonPrototype.centroid = function (k) {\n          var i = -1,\n              n = this.length,\n              x = 0,\n              y = 0,\n              a,\n              b = this[n - 1],\n              c;\n          if (!arguments.length) k = -1 / (6 * this.area());\n\n          while (++i < n) {\n            a = b;\n            b = this[i];\n            c = a[0] * b[1] - b[0] * a[1];\n            x += (a[0] + b[0]) * c;\n            y += (a[1] + b[1]) * c;\n          }\n\n          return [x * k, y * k];\n        };\n\n        d3_geom_polygonPrototype.clip = function (subject) {\n          var input,\n              closed = d3_geom_polygonClosed(subject),\n              i = -1,\n              n = this.length - d3_geom_polygonClosed(this),\n              j,\n              m,\n              a = this[n - 1],\n              b,\n              c,\n              d;\n\n          while (++i < n) {\n            input = subject.slice();\n            subject.length = 0;\n            b = this[i];\n            c = input[(m = input.length - closed) - 1];\n            j = -1;\n\n            while (++j < m) {\n              d = input[j];\n\n              if (d3_geom_polygonInside(d, a, b)) {\n                if (!d3_geom_polygonInside(c, a, b)) {\n                  subject.push(d3_geom_polygonIntersect(c, d, a, b));\n                }\n\n                subject.push(d);\n              } else if (d3_geom_polygonInside(c, a, b)) {\n                subject.push(d3_geom_polygonIntersect(c, d, a, b));\n              }\n\n              c = d;\n            }\n\n            if (closed) subject.push(subject[0]);\n            a = b;\n          }\n\n          return subject;\n        };\n\n        function d3_geom_polygonInside(p, a, b) {\n          return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n        }\n\n        function d3_geom_polygonIntersect(c, d, a, b) {\n          var x1 = c[0],\n              x3 = a[0],\n              x21 = d[0] - x1,\n              x43 = b[0] - x3,\n              y1 = c[1],\n              y3 = a[1],\n              y21 = d[1] - y1,\n              y43 = b[1] - y3,\n              ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n          return [x1 + ua * x21, y1 + ua * y21];\n        }\n\n        function d3_geom_polygonClosed(coordinates) {\n          var a = coordinates[0],\n              b = coordinates[coordinates.length - 1];\n          return !(a[0] - b[0] || a[1] - b[1]);\n        }\n\n        var d3_geom_voronoiEdges,\n            d3_geom_voronoiCells,\n            d3_geom_voronoiBeaches,\n            d3_geom_voronoiBeachPool = [],\n            d3_geom_voronoiFirstCircle,\n            d3_geom_voronoiCircles,\n            d3_geom_voronoiCirclePool = [];\n\n        function d3_geom_voronoiBeach() {\n          d3_geom_voronoiRedBlackNode(this);\n          this.edge = this.site = this.circle = null;\n        }\n\n        function d3_geom_voronoiCreateBeach(site) {\n          var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\n          beach.site = site;\n          return beach;\n        }\n\n        function d3_geom_voronoiDetachBeach(beach) {\n          d3_geom_voronoiDetachCircle(beach);\n          d3_geom_voronoiBeaches.remove(beach);\n          d3_geom_voronoiBeachPool.push(beach);\n          d3_geom_voronoiRedBlackNode(beach);\n        }\n\n        function d3_geom_voronoiRemoveBeach(beach) {\n          var circle = beach.circle,\n              x = circle.x,\n              y = circle.cy,\n              vertex = {\n            x: x,\n            y: y\n          },\n              previous = beach.P,\n              next = beach.N,\n              disappearing = [beach];\n          d3_geom_voronoiDetachBeach(beach);\n          var lArc = previous;\n\n          while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {\n            previous = lArc.P;\n            disappearing.unshift(lArc);\n            d3_geom_voronoiDetachBeach(lArc);\n            lArc = previous;\n          }\n\n          disappearing.unshift(lArc);\n          d3_geom_voronoiDetachCircle(lArc);\n          var rArc = next;\n\n          while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {\n            next = rArc.N;\n            disappearing.push(rArc);\n            d3_geom_voronoiDetachBeach(rArc);\n            rArc = next;\n          }\n\n          disappearing.push(rArc);\n          d3_geom_voronoiDetachCircle(rArc);\n          var nArcs = disappearing.length,\n              iArc;\n\n          for (iArc = 1; iArc < nArcs; ++iArc) {\n            rArc = disappearing[iArc];\n            lArc = disappearing[iArc - 1];\n            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n          }\n\n          lArc = disappearing[0];\n          rArc = disappearing[nArcs - 1];\n          rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);\n          d3_geom_voronoiAttachCircle(lArc);\n          d3_geom_voronoiAttachCircle(rArc);\n        }\n\n        function d3_geom_voronoiAddBeach(site) {\n          var x = site.x,\n              directrix = site.y,\n              lArc,\n              rArc,\n              dxl,\n              dxr,\n              node = d3_geom_voronoiBeaches._;\n\n          while (node) {\n            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;\n            if (dxl > ε) node = node.L;else {\n              dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);\n\n              if (dxr > ε) {\n                if (!node.R) {\n                  lArc = node;\n                  break;\n                }\n\n                node = node.R;\n              } else {\n                if (dxl > -ε) {\n                  lArc = node.P;\n                  rArc = node;\n                } else if (dxr > -ε) {\n                  lArc = node;\n                  rArc = node.N;\n                } else {\n                  lArc = rArc = node;\n                }\n\n                break;\n              }\n            }\n          }\n\n          var newArc = d3_geom_voronoiCreateBeach(site);\n          d3_geom_voronoiBeaches.insert(lArc, newArc);\n          if (!lArc && !rArc) return;\n\n          if (lArc === rArc) {\n            d3_geom_voronoiDetachCircle(lArc);\n            rArc = d3_geom_voronoiCreateBeach(lArc.site);\n            d3_geom_voronoiBeaches.insert(newArc, rArc);\n            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n            d3_geom_voronoiAttachCircle(lArc);\n            d3_geom_voronoiAttachCircle(rArc);\n            return;\n          }\n\n          if (!rArc) {\n            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n            return;\n          }\n\n          d3_geom_voronoiDetachCircle(lArc);\n          d3_geom_voronoiDetachCircle(rArc);\n          var lSite = lArc.site,\n              ax = lSite.x,\n              ay = lSite.y,\n              bx = site.x - ax,\n              by = site.y - ay,\n              rSite = rArc.site,\n              cx = rSite.x - ax,\n              cy = rSite.y - ay,\n              d = 2 * (bx * cy - by * cx),\n              hb = bx * bx + by * by,\n              hc = cx * cx + cy * cy,\n              vertex = {\n            x: (cy * hb - by * hc) / d + ax,\n            y: (bx * hc - cx * hb) / d + ay\n          };\n          d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);\n          newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);\n          rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);\n          d3_geom_voronoiAttachCircle(lArc);\n          d3_geom_voronoiAttachCircle(rArc);\n        }\n\n        function d3_geom_voronoiLeftBreakPoint(arc, directrix) {\n          var site = arc.site,\n              rfocx = site.x,\n              rfocy = site.y,\n              pby2 = rfocy - directrix;\n          if (!pby2) return rfocx;\n          var lArc = arc.P;\n          if (!lArc) return -Infinity;\n          site = lArc.site;\n          var lfocx = site.x,\n              lfocy = site.y,\n              plby2 = lfocy - directrix;\n          if (!plby2) return lfocx;\n          var hl = lfocx - rfocx,\n              aby2 = 1 / pby2 - 1 / plby2,\n              b = hl / plby2;\n          if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n          return (rfocx + lfocx) / 2;\n        }\n\n        function d3_geom_voronoiRightBreakPoint(arc, directrix) {\n          var rArc = arc.N;\n          if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);\n          var site = arc.site;\n          return site.y === directrix ? site.x : Infinity;\n        }\n\n        function d3_geom_voronoiCell(site) {\n          this.site = site;\n          this.edges = [];\n        }\n\n        d3_geom_voronoiCell.prototype.prepare = function () {\n          var halfEdges = this.edges,\n              iHalfEdge = halfEdges.length,\n              edge;\n\n          while (iHalfEdge--) {\n            edge = halfEdges[iHalfEdge].edge;\n            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n          }\n\n          halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n          return halfEdges.length;\n        };\n\n        function d3_geom_voronoiCloseCells(extent) {\n          var x0 = extent[0][0],\n              x1 = extent[1][0],\n              y0 = extent[0][1],\n              y1 = extent[1][1],\n              x2,\n              y2,\n              x3,\n              y3,\n              cells = d3_geom_voronoiCells,\n              iCell = cells.length,\n              cell,\n              iHalfEdge,\n              halfEdges,\n              nHalfEdges,\n              start,\n              end;\n\n          while (iCell--) {\n            cell = cells[iCell];\n            if (!cell || !cell.prepare()) continue;\n            halfEdges = cell.edges;\n            nHalfEdges = halfEdges.length;\n            iHalfEdge = 0;\n\n            while (iHalfEdge < nHalfEdges) {\n              end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n              start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n\n              if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\n                halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {\n                  x: x0,\n                  y: abs(x2 - x0) < ε ? y2 : y1\n                } : abs(y3 - y1) < ε && x1 - x3 > ε ? {\n                  x: abs(y2 - y1) < ε ? x2 : x1,\n                  y: y1\n                } : abs(x3 - x1) < ε && y3 - y0 > ε ? {\n                  x: x1,\n                  y: abs(x2 - x1) < ε ? y2 : y0\n                } : abs(y3 - y0) < ε && x3 - x0 > ε ? {\n                  x: abs(y2 - y0) < ε ? x2 : x0,\n                  y: y0\n                } : null), cell.site, null));\n                ++nHalfEdges;\n              }\n            }\n          }\n        }\n\n        function d3_geom_voronoiHalfEdgeOrder(a, b) {\n          return b.angle - a.angle;\n        }\n\n        function d3_geom_voronoiCircle() {\n          d3_geom_voronoiRedBlackNode(this);\n          this.x = this.y = this.arc = this.site = this.cy = null;\n        }\n\n        function d3_geom_voronoiAttachCircle(arc) {\n          var lArc = arc.P,\n              rArc = arc.N;\n          if (!lArc || !rArc) return;\n          var lSite = lArc.site,\n              cSite = arc.site,\n              rSite = rArc.site;\n          if (lSite === rSite) return;\n          var bx = cSite.x,\n              by = cSite.y,\n              ax = lSite.x - bx,\n              ay = lSite.y - by,\n              cx = rSite.x - bx,\n              cy = rSite.y - by;\n          var d = 2 * (ax * cy - ay * cx);\n          if (d >= -ε2) return;\n          var ha = ax * ax + ay * ay,\n              hc = cx * cx + cy * cy,\n              x = (cy * ha - ay * hc) / d,\n              y = (ax * hc - cx * ha) / d,\n              cy = y + by;\n          var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\n          circle.arc = arc;\n          circle.site = cSite;\n          circle.x = x + bx;\n          circle.y = cy + Math.sqrt(x * x + y * y);\n          circle.cy = cy;\n          arc.circle = circle;\n          var before = null,\n              node = d3_geom_voronoiCircles._;\n\n          while (node) {\n            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\n              if (node.L) node = node.L;else {\n                before = node.P;\n                break;\n              }\n            } else {\n              if (node.R) node = node.R;else {\n                before = node;\n                break;\n              }\n            }\n          }\n\n          d3_geom_voronoiCircles.insert(before, circle);\n          if (!before) d3_geom_voronoiFirstCircle = circle;\n        }\n\n        function d3_geom_voronoiDetachCircle(arc) {\n          var circle = arc.circle;\n\n          if (circle) {\n            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;\n            d3_geom_voronoiCircles.remove(circle);\n            d3_geom_voronoiCirclePool.push(circle);\n            d3_geom_voronoiRedBlackNode(circle);\n            arc.circle = null;\n          }\n        }\n\n        function d3_geom_voronoiClipEdges(extent) {\n          var edges = d3_geom_voronoiEdges,\n              clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]),\n              i = edges.length,\n              e;\n\n          while (i--) {\n            e = edges[i];\n\n            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {\n              e.a = e.b = null;\n              edges.splice(i, 1);\n            }\n          }\n        }\n\n        function d3_geom_voronoiConnectEdge(edge, extent) {\n          var vb = edge.b;\n          if (vb) return true;\n          var va = edge.a,\n              x0 = extent[0][0],\n              x1 = extent[1][0],\n              y0 = extent[0][1],\n              y1 = extent[1][1],\n              lSite = edge.l,\n              rSite = edge.r,\n              lx = lSite.x,\n              ly = lSite.y,\n              rx = rSite.x,\n              ry = rSite.y,\n              fx = (lx + rx) / 2,\n              fy = (ly + ry) / 2,\n              fm,\n              fb;\n\n          if (ry === ly) {\n            if (fx < x0 || fx >= x1) return;\n\n            if (lx > rx) {\n              if (!va) va = {\n                x: fx,\n                y: y0\n              };else if (va.y >= y1) return;\n              vb = {\n                x: fx,\n                y: y1\n              };\n            } else {\n              if (!va) va = {\n                x: fx,\n                y: y1\n              };else if (va.y < y0) return;\n              vb = {\n                x: fx,\n                y: y0\n              };\n            }\n          } else {\n            fm = (lx - rx) / (ry - ly);\n            fb = fy - fm * fx;\n\n            if (fm < -1 || fm > 1) {\n              if (lx > rx) {\n                if (!va) va = {\n                  x: (y0 - fb) / fm,\n                  y: y0\n                };else if (va.y >= y1) return;\n                vb = {\n                  x: (y1 - fb) / fm,\n                  y: y1\n                };\n              } else {\n                if (!va) va = {\n                  x: (y1 - fb) / fm,\n                  y: y1\n                };else if (va.y < y0) return;\n                vb = {\n                  x: (y0 - fb) / fm,\n                  y: y0\n                };\n              }\n            } else {\n              if (ly < ry) {\n                if (!va) va = {\n                  x: x0,\n                  y: fm * x0 + fb\n                };else if (va.x >= x1) return;\n                vb = {\n                  x: x1,\n                  y: fm * x1 + fb\n                };\n              } else {\n                if (!va) va = {\n                  x: x1,\n                  y: fm * x1 + fb\n                };else if (va.x < x0) return;\n                vb = {\n                  x: x0,\n                  y: fm * x0 + fb\n                };\n              }\n            }\n          }\n\n          edge.a = va;\n          edge.b = vb;\n          return true;\n        }\n\n        function d3_geom_voronoiEdge(lSite, rSite) {\n          this.l = lSite;\n          this.r = rSite;\n          this.a = this.b = null;\n        }\n\n        function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {\n          var edge = new d3_geom_voronoiEdge(lSite, rSite);\n          d3_geom_voronoiEdges.push(edge);\n          if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);\n          if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);\n          d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));\n          d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));\n          return edge;\n        }\n\n        function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {\n          var edge = new d3_geom_voronoiEdge(lSite, null);\n          edge.a = va;\n          edge.b = vb;\n          d3_geom_voronoiEdges.push(edge);\n          return edge;\n        }\n\n        function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {\n          if (!edge.a && !edge.b) {\n            edge.a = vertex;\n            edge.l = lSite;\n            edge.r = rSite;\n          } else if (edge.l === rSite) {\n            edge.b = vertex;\n          } else {\n            edge.a = vertex;\n          }\n        }\n\n        function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {\n          var va = edge.a,\n              vb = edge.b;\n          this.edge = edge;\n          this.site = lSite;\n          this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\n        }\n\n        d3_geom_voronoiHalfEdge.prototype = {\n          start: function () {\n            return this.edge.l === this.site ? this.edge.a : this.edge.b;\n          },\n          end: function () {\n            return this.edge.l === this.site ? this.edge.b : this.edge.a;\n          }\n        };\n\n        function d3_geom_voronoiRedBlackTree() {\n          this._ = null;\n        }\n\n        function d3_geom_voronoiRedBlackNode(node) {\n          node.U = node.C = node.L = node.R = node.P = node.N = null;\n        }\n\n        d3_geom_voronoiRedBlackTree.prototype = {\n          insert: function (after, node) {\n            var parent, grandpa, uncle;\n\n            if (after) {\n              node.P = after;\n              node.N = after.N;\n              if (after.N) after.N.P = node;\n              after.N = node;\n\n              if (after.R) {\n                after = after.R;\n\n                while (after.L) after = after.L;\n\n                after.L = node;\n              } else {\n                after.R = node;\n              }\n\n              parent = after;\n            } else if (this._) {\n              after = d3_geom_voronoiRedBlackFirst(this._);\n              node.P = null;\n              node.N = after;\n              after.P = after.L = node;\n              parent = after;\n            } else {\n              node.P = node.N = null;\n              this._ = node;\n              parent = null;\n            }\n\n            node.L = node.R = null;\n            node.U = parent;\n            node.C = true;\n            after = node;\n\n            while (parent && parent.C) {\n              grandpa = parent.U;\n\n              if (parent === grandpa.L) {\n                uncle = grandpa.R;\n\n                if (uncle && uncle.C) {\n                  parent.C = uncle.C = false;\n                  grandpa.C = true;\n                  after = grandpa;\n                } else {\n                  if (after === parent.R) {\n                    d3_geom_voronoiRedBlackRotateLeft(this, parent);\n                    after = parent;\n                    parent = after.U;\n                  }\n\n                  parent.C = false;\n                  grandpa.C = true;\n                  d3_geom_voronoiRedBlackRotateRight(this, grandpa);\n                }\n              } else {\n                uncle = grandpa.L;\n\n                if (uncle && uncle.C) {\n                  parent.C = uncle.C = false;\n                  grandpa.C = true;\n                  after = grandpa;\n                } else {\n                  if (after === parent.L) {\n                    d3_geom_voronoiRedBlackRotateRight(this, parent);\n                    after = parent;\n                    parent = after.U;\n                  }\n\n                  parent.C = false;\n                  grandpa.C = true;\n                  d3_geom_voronoiRedBlackRotateLeft(this, grandpa);\n                }\n              }\n\n              parent = after.U;\n            }\n\n            this._.C = false;\n          },\n          remove: function (node) {\n            if (node.N) node.N.P = node.P;\n            if (node.P) node.P.N = node.N;\n            node.N = node.P = null;\n            var parent = node.U,\n                sibling,\n                left = node.L,\n                right = node.R,\n                next,\n                red;\n            if (!left) next = right;else if (!right) next = left;else next = d3_geom_voronoiRedBlackFirst(right);\n\n            if (parent) {\n              if (parent.L === node) parent.L = next;else parent.R = next;\n            } else {\n              this._ = next;\n            }\n\n            if (left && right) {\n              red = next.C;\n              next.C = node.C;\n              next.L = left;\n              left.U = next;\n\n              if (next !== right) {\n                parent = next.U;\n                next.U = node.U;\n                node = next.R;\n                parent.L = node;\n                next.R = right;\n                right.U = next;\n              } else {\n                next.U = parent;\n                parent = next;\n                node = next.R;\n              }\n            } else {\n              red = node.C;\n              node = next;\n            }\n\n            if (node) node.U = parent;\n            if (red) return;\n\n            if (node && node.C) {\n              node.C = false;\n              return;\n            }\n\n            do {\n              if (node === this._) break;\n\n              if (node === parent.L) {\n                sibling = parent.R;\n\n                if (sibling.C) {\n                  sibling.C = false;\n                  parent.C = true;\n                  d3_geom_voronoiRedBlackRotateLeft(this, parent);\n                  sibling = parent.R;\n                }\n\n                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n                  if (!sibling.R || !sibling.R.C) {\n                    sibling.L.C = false;\n                    sibling.C = true;\n                    d3_geom_voronoiRedBlackRotateRight(this, sibling);\n                    sibling = parent.R;\n                  }\n\n                  sibling.C = parent.C;\n                  parent.C = sibling.R.C = false;\n                  d3_geom_voronoiRedBlackRotateLeft(this, parent);\n                  node = this._;\n                  break;\n                }\n              } else {\n                sibling = parent.L;\n\n                if (sibling.C) {\n                  sibling.C = false;\n                  parent.C = true;\n                  d3_geom_voronoiRedBlackRotateRight(this, parent);\n                  sibling = parent.L;\n                }\n\n                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n                  if (!sibling.L || !sibling.L.C) {\n                    sibling.R.C = false;\n                    sibling.C = true;\n                    d3_geom_voronoiRedBlackRotateLeft(this, sibling);\n                    sibling = parent.L;\n                  }\n\n                  sibling.C = parent.C;\n                  parent.C = sibling.L.C = false;\n                  d3_geom_voronoiRedBlackRotateRight(this, parent);\n                  node = this._;\n                  break;\n                }\n              }\n\n              sibling.C = true;\n              node = parent;\n              parent = parent.U;\n            } while (!node.C);\n\n            if (node) node.C = false;\n          }\n        };\n\n        function d3_geom_voronoiRedBlackRotateLeft(tree, node) {\n          var p = node,\n              q = node.R,\n              parent = p.U;\n\n          if (parent) {\n            if (parent.L === p) parent.L = q;else parent.R = q;\n          } else {\n            tree._ = q;\n          }\n\n          q.U = parent;\n          p.U = q;\n          p.R = q.L;\n          if (p.R) p.R.U = p;\n          q.L = p;\n        }\n\n        function d3_geom_voronoiRedBlackRotateRight(tree, node) {\n          var p = node,\n              q = node.L,\n              parent = p.U;\n\n          if (parent) {\n            if (parent.L === p) parent.L = q;else parent.R = q;\n          } else {\n            tree._ = q;\n          }\n\n          q.U = parent;\n          p.U = q;\n          p.L = q.R;\n          if (p.L) p.L.U = p;\n          q.R = p;\n        }\n\n        function d3_geom_voronoiRedBlackFirst(node) {\n          while (node.L) node = node.L;\n\n          return node;\n        }\n\n        function d3_geom_voronoi(sites, bbox) {\n          var site = sites.sort(d3_geom_voronoiVertexOrder).pop(),\n              x0,\n              y0,\n              circle;\n          d3_geom_voronoiEdges = [];\n          d3_geom_voronoiCells = new Array(sites.length);\n          d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\n          d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\n\n          while (true) {\n            circle = d3_geom_voronoiFirstCircle;\n\n            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\n              if (site.x !== x0 || site.y !== y0) {\n                d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);\n                d3_geom_voronoiAddBeach(site);\n                x0 = site.x, y0 = site.y;\n              }\n\n              site = sites.pop();\n            } else if (circle) {\n              d3_geom_voronoiRemoveBeach(circle.arc);\n            } else {\n              break;\n            }\n          }\n\n          if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);\n          var diagram = {\n            cells: d3_geom_voronoiCells,\n            edges: d3_geom_voronoiEdges\n          };\n          d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\n          return diagram;\n        }\n\n        function d3_geom_voronoiVertexOrder(a, b) {\n          return b.y - a.y || b.x - a.x;\n        }\n\n        d3.geom.voronoi = function (points) {\n          var x = d3_geom_pointX,\n              y = d3_geom_pointY,\n              fx = x,\n              fy = y,\n              clipExtent = d3_geom_voronoiClipExtent;\n          if (points) return voronoi(points);\n\n          function voronoi(data) {\n            var polygons = new Array(data.length),\n                x0 = clipExtent[0][0],\n                y0 = clipExtent[0][1],\n                x1 = clipExtent[1][0],\n                y1 = clipExtent[1][1];\n            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function (cell, i) {\n              var edges = cell.edges,\n                  site = cell.site,\n                  polygon = polygons[i] = edges.length ? edges.map(function (e) {\n                var s = e.start();\n                return [s.x, s.y];\n              }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];\n              polygon.point = data[i];\n            });\n            return polygons;\n          }\n\n          function sites(data) {\n            return data.map(function (d, i) {\n              return {\n                x: Math.round(fx(d, i) / ε) * ε,\n                y: Math.round(fy(d, i) / ε) * ε,\n                i: i\n              };\n            });\n          }\n\n          voronoi.links = function (data) {\n            return d3_geom_voronoi(sites(data)).edges.filter(function (edge) {\n              return edge.l && edge.r;\n            }).map(function (edge) {\n              return {\n                source: data[edge.l.i],\n                target: data[edge.r.i]\n              };\n            });\n          };\n\n          voronoi.triangles = function (data) {\n            var triangles = [];\n            d3_geom_voronoi(sites(data)).cells.forEach(function (cell, i) {\n              var site = cell.site,\n                  edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),\n                  j = -1,\n                  m = edges.length,\n                  e0,\n                  s0,\n                  e1 = edges[m - 1].edge,\n                  s1 = e1.l === site ? e1.r : e1.l;\n\n              while (++j < m) {\n                e0 = e1;\n                s0 = s1;\n                e1 = edges[j].edge;\n                s1 = e1.l === site ? e1.r : e1.l;\n\n                if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n                  triangles.push([data[i], data[s0.i], data[s1.i]]);\n                }\n              }\n            });\n            return triangles;\n          };\n\n          voronoi.x = function (_) {\n            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n          };\n\n          voronoi.y = function (_) {\n            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n          };\n\n          voronoi.clipExtent = function (_) {\n            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n            return voronoi;\n          };\n\n          voronoi.size = function (_) {\n            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n            return voronoi.clipExtent(_ && [[0, 0], _]);\n          };\n\n          return voronoi;\n        };\n\n        var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];\n\n        function d3_geom_voronoiTriangleArea(a, b, c) {\n          return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n        }\n\n        d3.geom.delaunay = function (vertices) {\n          return d3.geom.voronoi().triangles(vertices);\n        };\n\n        d3.geom.quadtree = function (points, x1, y1, x2, y2) {\n          var x = d3_geom_pointX,\n              y = d3_geom_pointY,\n              compat;\n\n          if (compat = arguments.length) {\n            x = d3_geom_quadtreeCompatX;\n            y = d3_geom_quadtreeCompatY;\n\n            if (compat === 3) {\n              y2 = y1;\n              x2 = x1;\n              y1 = x1 = 0;\n            }\n\n            return quadtree(points);\n          }\n\n          function quadtree(data) {\n            var d,\n                fx = d3_functor(x),\n                fy = d3_functor(y),\n                xs,\n                ys,\n                i,\n                n,\n                x1_,\n                y1_,\n                x2_,\n                y2_;\n\n            if (x1 != null) {\n              x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n            } else {\n              x2_ = y2_ = -(x1_ = y1_ = Infinity);\n              xs = [], ys = [];\n              n = data.length;\n              if (compat) for (i = 0; i < n; ++i) {\n                d = data[i];\n                if (d.x < x1_) x1_ = d.x;\n                if (d.y < y1_) y1_ = d.y;\n                if (d.x > x2_) x2_ = d.x;\n                if (d.y > y2_) y2_ = d.y;\n                xs.push(d.x);\n                ys.push(d.y);\n              } else for (i = 0; i < n; ++i) {\n                var x_ = +fx(d = data[i], i),\n                    y_ = +fy(d, i);\n                if (x_ < x1_) x1_ = x_;\n                if (y_ < y1_) y1_ = y_;\n                if (x_ > x2_) x2_ = x_;\n                if (y_ > y2_) y2_ = y_;\n                xs.push(x_);\n                ys.push(y_);\n              }\n            }\n\n            var dx = x2_ - x1_,\n                dy = y2_ - y1_;\n            if (dx > dy) y2_ = y1_ + dx;else x2_ = x1_ + dy;\n\n            function insert(n, d, x, y, x1, y1, x2, y2) {\n              if (isNaN(x) || isNaN(y)) return;\n\n              if (n.leaf) {\n                var nx = n.x,\n                    ny = n.y;\n\n                if (nx != null) {\n                  if (abs(nx - x) + abs(ny - y) < .01) {\n                    insertChild(n, d, x, y, x1, y1, x2, y2);\n                  } else {\n                    var nPoint = n.point;\n                    n.x = n.y = n.point = null;\n                    insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);\n                    insertChild(n, d, x, y, x1, y1, x2, y2);\n                  }\n                } else {\n                  n.x = x, n.y = y, n.point = d;\n                }\n              } else {\n                insertChild(n, d, x, y, x1, y1, x2, y2);\n              }\n            }\n\n            function insertChild(n, d, x, y, x1, y1, x2, y2) {\n              var xm = (x1 + x2) * .5,\n                  ym = (y1 + y2) * .5,\n                  right = x >= xm,\n                  below = y >= ym,\n                  i = below << 1 | right;\n              n.leaf = false;\n              n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n              if (right) x1 = xm;else x2 = xm;\n              if (below) y1 = ym;else y2 = ym;\n              insert(n, d, x, y, x1, y1, x2, y2);\n            }\n\n            var root = d3_geom_quadtreeNode();\n\n            root.add = function (d) {\n              insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);\n            };\n\n            root.visit = function (f) {\n              d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);\n            };\n\n            root.find = function (point) {\n              return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);\n            };\n\n            i = -1;\n\n            if (x1 == null) {\n              while (++i < n) {\n                insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);\n              }\n\n              --i;\n            } else data.forEach(root.add);\n\n            xs = ys = data = d = null;\n            return root;\n          }\n\n          quadtree.x = function (_) {\n            return arguments.length ? (x = _, quadtree) : x;\n          };\n\n          quadtree.y = function (_) {\n            return arguments.length ? (y = _, quadtree) : y;\n          };\n\n          quadtree.extent = function (_) {\n            if (!arguments.length) return x1 == null ? null : [[x1, y1], [x2, y2]];\n            if (_ == null) x1 = y1 = x2 = y2 = null;else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];\n            return quadtree;\n          };\n\n          quadtree.size = function (_) {\n            if (!arguments.length) return x1 == null ? null : [x2 - x1, y2 - y1];\n            if (_ == null) x1 = y1 = x2 = y2 = null;else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\n            return quadtree;\n          };\n\n          return quadtree;\n        };\n\n        function d3_geom_quadtreeCompatX(d) {\n          return d.x;\n        }\n\n        function d3_geom_quadtreeCompatY(d) {\n          return d.y;\n        }\n\n        function d3_geom_quadtreeNode() {\n          return {\n            leaf: true,\n            nodes: [],\n            point: null,\n            x: null,\n            y: null\n          };\n        }\n\n        function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n          if (!f(node, x1, y1, x2, y2)) {\n            var sx = (x1 + x2) * .5,\n                sy = (y1 + y2) * .5,\n                children = node.nodes;\n            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n          }\n        }\n\n        function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {\n          var minDistance2 = Infinity,\n              closestPoint;\n\n          (function find(node, x1, y1, x2, y2) {\n            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;\n\n            if (point = node.point) {\n              var point,\n                  dx = x - node.x,\n                  dy = y - node.y,\n                  distance2 = dx * dx + dy * dy;\n\n              if (distance2 < minDistance2) {\n                var distance = Math.sqrt(minDistance2 = distance2);\n                x0 = x - distance, y0 = y - distance;\n                x3 = x + distance, y3 = y + distance;\n                closestPoint = point;\n              }\n            }\n\n            var children = node.nodes,\n                xm = (x1 + x2) * .5,\n                ym = (y1 + y2) * .5,\n                right = x >= xm,\n                below = y >= ym;\n\n            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {\n              if (node = children[i & 3]) switch (i & 3) {\n                case 0:\n                  find(node, x1, y1, xm, ym);\n                  break;\n\n                case 1:\n                  find(node, xm, y1, x2, ym);\n                  break;\n\n                case 2:\n                  find(node, x1, ym, xm, y2);\n                  break;\n\n                case 3:\n                  find(node, xm, ym, x2, y2);\n                  break;\n              }\n            }\n          })(root, x0, y0, x3, y3);\n\n          return closestPoint;\n        }\n\n        d3.interpolateRgb = d3_interpolateRgb;\n\n        function d3_interpolateRgb(a, b) {\n          a = d3.rgb(a);\n          b = d3.rgb(b);\n          var ar = a.r,\n              ag = a.g,\n              ab = a.b,\n              br = b.r - ar,\n              bg = b.g - ag,\n              bb = b.b - ab;\n          return function (t) {\n            return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n          };\n        }\n\n        d3.interpolateObject = d3_interpolateObject;\n\n        function d3_interpolateObject(a, b) {\n          var i = {},\n              c = {},\n              k;\n\n          for (k in a) {\n            if (k in b) {\n              i[k] = d3_interpolate(a[k], b[k]);\n            } else {\n              c[k] = a[k];\n            }\n          }\n\n          for (k in b) {\n            if (!(k in a)) {\n              c[k] = b[k];\n            }\n          }\n\n          return function (t) {\n            for (k in i) c[k] = i[k](t);\n\n            return c;\n          };\n        }\n\n        d3.interpolateNumber = d3_interpolateNumber;\n\n        function d3_interpolateNumber(a, b) {\n          a = +a, b = +b;\n          return function (t) {\n            return a * (1 - t) + b * t;\n          };\n        }\n\n        d3.interpolateString = d3_interpolateString;\n\n        function d3_interpolateString(a, b) {\n          var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0,\n              am,\n              bm,\n              bs,\n              i = -1,\n              s = [],\n              q = [];\n          a = a + \"\", b = b + \"\";\n\n          while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\n            if ((bs = bm.index) > bi) {\n              bs = b.slice(bi, bs);\n              if (s[i]) s[i] += bs;else s[++i] = bs;\n            }\n\n            if ((am = am[0]) === (bm = bm[0])) {\n              if (s[i]) s[i] += bm;else s[++i] = bm;\n            } else {\n              s[++i] = null;\n              q.push({\n                i: i,\n                x: d3_interpolateNumber(am, bm)\n              });\n            }\n\n            bi = d3_interpolate_numberB.lastIndex;\n          }\n\n          if (bi < b.length) {\n            bs = b.slice(bi);\n            if (s[i]) s[i] += bs;else s[++i] = bs;\n          }\n\n          return s.length < 2 ? q[0] ? (b = q[0].x, function (t) {\n            return b(t) + \"\";\n          }) : function () {\n            return b;\n          } : (b = q.length, function (t) {\n            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n\n            return s.join(\"\");\n          });\n        }\n\n        var d3_interpolate_numberA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,\n            d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, \"g\");\n        d3.interpolate = d3_interpolate;\n\n        function d3_interpolate(a, b) {\n          var i = d3.interpolators.length,\n              f;\n\n          while (--i >= 0 && !(f = d3.interpolators[i](a, b)));\n\n          return f;\n        }\n\n        d3.interpolators = [function (a, b) {\n          var t = typeof b;\n          return (t === \"string\" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\\(|hsl\\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === \"object\" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\n        }];\n        d3.interpolateArray = d3_interpolateArray;\n\n        function d3_interpolateArray(a, b) {\n          var x = [],\n              c = [],\n              na = a.length,\n              nb = b.length,\n              n0 = Math.min(a.length, b.length),\n              i;\n\n          for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));\n\n          for (; i < na; ++i) c[i] = a[i];\n\n          for (; i < nb; ++i) c[i] = b[i];\n\n          return function (t) {\n            for (i = 0; i < n0; ++i) c[i] = x[i](t);\n\n            return c;\n          };\n        }\n\n        var d3_ease_default = function () {\n          return d3_identity;\n        };\n\n        var d3_ease = d3.map({\n          linear: d3_ease_default,\n          poly: d3_ease_poly,\n          quad: function () {\n            return d3_ease_quad;\n          },\n          cubic: function () {\n            return d3_ease_cubic;\n          },\n          sin: function () {\n            return d3_ease_sin;\n          },\n          exp: function () {\n            return d3_ease_exp;\n          },\n          circle: function () {\n            return d3_ease_circle;\n          },\n          elastic: d3_ease_elastic,\n          back: d3_ease_back,\n          bounce: function () {\n            return d3_ease_bounce;\n          }\n        });\n        var d3_ease_mode = d3.map({\n          \"in\": d3_identity,\n          out: d3_ease_reverse,\n          \"in-out\": d3_ease_reflect,\n          \"out-in\": function (f) {\n            return d3_ease_reflect(d3_ease_reverse(f));\n          }\n        });\n\n        d3.ease = function (name) {\n          var i = name.indexOf(\"-\"),\n              t = i >= 0 ? name.slice(0, i) : name,\n              m = i >= 0 ? name.slice(i + 1) : \"in\";\n          t = d3_ease.get(t) || d3_ease_default;\n          m = d3_ease_mode.get(m) || d3_identity;\n          return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\n        };\n\n        function d3_ease_clamp(f) {\n          return function (t) {\n            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n          };\n        }\n\n        function d3_ease_reverse(f) {\n          return function (t) {\n            return 1 - f(1 - t);\n          };\n        }\n\n        function d3_ease_reflect(f) {\n          return function (t) {\n            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n          };\n        }\n\n        function d3_ease_quad(t) {\n          return t * t;\n        }\n\n        function d3_ease_cubic(t) {\n          return t * t * t;\n        }\n\n        function d3_ease_cubicInOut(t) {\n          if (t <= 0) return 0;\n          if (t >= 1) return 1;\n          var t2 = t * t,\n              t3 = t2 * t;\n          return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n        }\n\n        function d3_ease_poly(e) {\n          return function (t) {\n            return Math.pow(t, e);\n          };\n        }\n\n        function d3_ease_sin(t) {\n          return 1 - Math.cos(t * halfπ);\n        }\n\n        function d3_ease_exp(t) {\n          return Math.pow(2, 10 * (t - 1));\n        }\n\n        function d3_ease_circle(t) {\n          return 1 - Math.sqrt(1 - t * t);\n        }\n\n        function d3_ease_elastic(a, p) {\n          var s;\n          if (arguments.length < 2) p = .45;\n          if (arguments.length) s = p / τ * Math.asin(1 / a);else a = 1, s = p / 4;\n          return function (t) {\n            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);\n          };\n        }\n\n        function d3_ease_back(s) {\n          if (!s) s = 1.70158;\n          return function (t) {\n            return t * t * ((s + 1) * t - s);\n          };\n        }\n\n        function d3_ease_bounce(t) {\n          return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n        }\n\n        d3.interpolateHcl = d3_interpolateHcl;\n\n        function d3_interpolateHcl(a, b) {\n          a = d3.hcl(a);\n          b = d3.hcl(b);\n          var ah = a.h,\n              ac = a.c,\n              al = a.l,\n              bh = b.h - ah,\n              bc = b.c - ac,\n              bl = b.l - al;\n          if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;\n          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;else if (bh > 180) bh -= 360;else if (bh < -180) bh += 360;\n          return function (t) {\n            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n          };\n        }\n\n        d3.interpolateHsl = d3_interpolateHsl;\n\n        function d3_interpolateHsl(a, b) {\n          a = d3.hsl(a);\n          b = d3.hsl(b);\n          var ah = a.h,\n              as = a.s,\n              al = a.l,\n              bh = b.h - ah,\n              bs = b.s - as,\n              bl = b.l - al;\n          if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;\n          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;else if (bh > 180) bh -= 360;else if (bh < -180) bh += 360;\n          return function (t) {\n            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + \"\";\n          };\n        }\n\n        d3.interpolateLab = d3_interpolateLab;\n\n        function d3_interpolateLab(a, b) {\n          a = d3.lab(a);\n          b = d3.lab(b);\n          var al = a.l,\n              aa = a.a,\n              ab = a.b,\n              bl = b.l - al,\n              ba = b.a - aa,\n              bb = b.b - ab;\n          return function (t) {\n            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n          };\n        }\n\n        d3.interpolateRound = d3_interpolateRound;\n\n        function d3_interpolateRound(a, b) {\n          b -= a;\n          return function (t) {\n            return Math.round(a + b * t);\n          };\n        }\n\n        d3.transform = function (string) {\n          var g = d3_document.createElementNS(d3.ns.prefix.svg, \"g\");\n          return (d3.transform = function (string) {\n            if (string != null) {\n              g.setAttribute(\"transform\", string);\n              var t = g.transform.baseVal.consolidate();\n            }\n\n            return new d3_transform(t ? t.matrix : d3_transformIdentity);\n          })(string);\n        };\n\n        function d3_transform(m) {\n          var r0 = [m.a, m.b],\n              r1 = [m.c, m.d],\n              kx = d3_transformNormalize(r0),\n              kz = d3_transformDot(r0, r1),\n              ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n\n          if (r0[0] * r1[1] < r1[0] * r0[1]) {\n            r0[0] *= -1;\n            r0[1] *= -1;\n            kx *= -1;\n            kz *= -1;\n          }\n\n          this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n          this.translate = [m.e, m.f];\n          this.scale = [kx, ky];\n          this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n        }\n\n        d3_transform.prototype.toString = function () {\n          return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\n        };\n\n        function d3_transformDot(a, b) {\n          return a[0] * b[0] + a[1] * b[1];\n        }\n\n        function d3_transformNormalize(a) {\n          var k = Math.sqrt(d3_transformDot(a, a));\n\n          if (k) {\n            a[0] /= k;\n            a[1] /= k;\n          }\n\n          return k;\n        }\n\n        function d3_transformCombine(a, b, k) {\n          a[0] += k * b[0];\n          a[1] += k * b[1];\n          return a;\n        }\n\n        var d3_transformIdentity = {\n          a: 1,\n          b: 0,\n          c: 0,\n          d: 1,\n          e: 0,\n          f: 0\n        };\n        d3.interpolateTransform = d3_interpolateTransform;\n\n        function d3_interpolateTransformPop(s) {\n          return s.length ? s.pop() + \",\" : \"\";\n        }\n\n        function d3_interpolateTranslate(ta, tb, s, q) {\n          if (ta[0] !== tb[0] || ta[1] !== tb[1]) {\n            var i = s.push(\"translate(\", null, \",\", null, \")\");\n            q.push({\n              i: i - 4,\n              x: d3_interpolateNumber(ta[0], tb[0])\n            }, {\n              i: i - 2,\n              x: d3_interpolateNumber(ta[1], tb[1])\n            });\n          } else if (tb[0] || tb[1]) {\n            s.push(\"translate(\" + tb + \")\");\n          }\n        }\n\n        function d3_interpolateRotate(ra, rb, s, q) {\n          if (ra !== rb) {\n            if (ra - rb > 180) rb += 360;else if (rb - ra > 180) ra += 360;\n            q.push({\n              i: s.push(d3_interpolateTransformPop(s) + \"rotate(\", null, \")\") - 2,\n              x: d3_interpolateNumber(ra, rb)\n            });\n          } else if (rb) {\n            s.push(d3_interpolateTransformPop(s) + \"rotate(\" + rb + \")\");\n          }\n        }\n\n        function d3_interpolateSkew(wa, wb, s, q) {\n          if (wa !== wb) {\n            q.push({\n              i: s.push(d3_interpolateTransformPop(s) + \"skewX(\", null, \")\") - 2,\n              x: d3_interpolateNumber(wa, wb)\n            });\n          } else if (wb) {\n            s.push(d3_interpolateTransformPop(s) + \"skewX(\" + wb + \")\");\n          }\n        }\n\n        function d3_interpolateScale(ka, kb, s, q) {\n          if (ka[0] !== kb[0] || ka[1] !== kb[1]) {\n            var i = s.push(d3_interpolateTransformPop(s) + \"scale(\", null, \",\", null, \")\");\n            q.push({\n              i: i - 4,\n              x: d3_interpolateNumber(ka[0], kb[0])\n            }, {\n              i: i - 2,\n              x: d3_interpolateNumber(ka[1], kb[1])\n            });\n          } else if (kb[0] !== 1 || kb[1] !== 1) {\n            s.push(d3_interpolateTransformPop(s) + \"scale(\" + kb + \")\");\n          }\n        }\n\n        function d3_interpolateTransform(a, b) {\n          var s = [],\n              q = [];\n          a = d3.transform(a), b = d3.transform(b);\n          d3_interpolateTranslate(a.translate, b.translate, s, q);\n          d3_interpolateRotate(a.rotate, b.rotate, s, q);\n          d3_interpolateSkew(a.skew, b.skew, s, q);\n          d3_interpolateScale(a.scale, b.scale, s, q);\n          a = b = null;\n          return function (t) {\n            var i = -1,\n                n = q.length,\n                o;\n\n            while (++i < n) s[(o = q[i]).i] = o.x(t);\n\n            return s.join(\"\");\n          };\n        }\n\n        function d3_uninterpolateNumber(a, b) {\n          b = (b -= a = +a) || 1 / b;\n          return function (x) {\n            return (x - a) / b;\n          };\n        }\n\n        function d3_uninterpolateClamp(a, b) {\n          b = (b -= a = +a) || 1 / b;\n          return function (x) {\n            return Math.max(0, Math.min(1, (x - a) / b));\n          };\n        }\n\n        d3.layout = {};\n\n        d3.layout.bundle = function () {\n          return function (links) {\n            var paths = [],\n                i = -1,\n                n = links.length;\n\n            while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n\n            return paths;\n          };\n        };\n\n        function d3_layout_bundlePath(link) {\n          var start = link.source,\n              end = link.target,\n              lca = d3_layout_bundleLeastCommonAncestor(start, end),\n              points = [start];\n\n          while (start !== lca) {\n            start = start.parent;\n            points.push(start);\n          }\n\n          var k = points.length;\n\n          while (end !== lca) {\n            points.splice(k, 0, end);\n            end = end.parent;\n          }\n\n          return points;\n        }\n\n        function d3_layout_bundleAncestors(node) {\n          var ancestors = [],\n              parent = node.parent;\n\n          while (parent != null) {\n            ancestors.push(node);\n            node = parent;\n            parent = parent.parent;\n          }\n\n          ancestors.push(node);\n          return ancestors;\n        }\n\n        function d3_layout_bundleLeastCommonAncestor(a, b) {\n          if (a === b) return a;\n          var aNodes = d3_layout_bundleAncestors(a),\n              bNodes = d3_layout_bundleAncestors(b),\n              aNode = aNodes.pop(),\n              bNode = bNodes.pop(),\n              sharedNode = null;\n\n          while (aNode === bNode) {\n            sharedNode = aNode;\n            aNode = aNodes.pop();\n            bNode = bNodes.pop();\n          }\n\n          return sharedNode;\n        }\n\n        d3.layout.chord = function () {\n          var chord = {},\n              chords,\n              groups,\n              matrix,\n              n,\n              padding = 0,\n              sortGroups,\n              sortSubgroups,\n              sortChords;\n\n          function relayout() {\n            var subgroups = {},\n                groupSums = [],\n                groupIndex = d3.range(n),\n                subgroupIndex = [],\n                k,\n                x,\n                x0,\n                i,\n                j;\n            chords = [];\n            groups = [];\n            k = 0, i = -1;\n\n            while (++i < n) {\n              x = 0, j = -1;\n\n              while (++j < n) {\n                x += matrix[i][j];\n              }\n\n              groupSums.push(x);\n              subgroupIndex.push(d3.range(n));\n              k += x;\n            }\n\n            if (sortGroups) {\n              groupIndex.sort(function (a, b) {\n                return sortGroups(groupSums[a], groupSums[b]);\n              });\n            }\n\n            if (sortSubgroups) {\n              subgroupIndex.forEach(function (d, i) {\n                d.sort(function (a, b) {\n                  return sortSubgroups(matrix[i][a], matrix[i][b]);\n                });\n              });\n            }\n\n            k = (τ - padding * n) / k;\n            x = 0, i = -1;\n\n            while (++i < n) {\n              x0 = x, j = -1;\n\n              while (++j < n) {\n                var di = groupIndex[i],\n                    dj = subgroupIndex[di][j],\n                    v = matrix[di][dj],\n                    a0 = x,\n                    a1 = x += v * k;\n                subgroups[di + \"-\" + dj] = {\n                  index: di,\n                  subindex: dj,\n                  startAngle: a0,\n                  endAngle: a1,\n                  value: v\n                };\n              }\n\n              groups[di] = {\n                index: di,\n                startAngle: x0,\n                endAngle: x,\n                value: groupSums[di]\n              };\n              x += padding;\n            }\n\n            i = -1;\n\n            while (++i < n) {\n              j = i - 1;\n\n              while (++j < n) {\n                var source = subgroups[i + \"-\" + j],\n                    target = subgroups[j + \"-\" + i];\n\n                if (source.value || target.value) {\n                  chords.push(source.value < target.value ? {\n                    source: target,\n                    target: source\n                  } : {\n                    source: source,\n                    target: target\n                  });\n                }\n              }\n            }\n\n            if (sortChords) resort();\n          }\n\n          function resort() {\n            chords.sort(function (a, b) {\n              return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\n            });\n          }\n\n          chord.matrix = function (x) {\n            if (!arguments.length) return matrix;\n            n = (matrix = x) && matrix.length;\n            chords = groups = null;\n            return chord;\n          };\n\n          chord.padding = function (x) {\n            if (!arguments.length) return padding;\n            padding = x;\n            chords = groups = null;\n            return chord;\n          };\n\n          chord.sortGroups = function (x) {\n            if (!arguments.length) return sortGroups;\n            sortGroups = x;\n            chords = groups = null;\n            return chord;\n          };\n\n          chord.sortSubgroups = function (x) {\n            if (!arguments.length) return sortSubgroups;\n            sortSubgroups = x;\n            chords = null;\n            return chord;\n          };\n\n          chord.sortChords = function (x) {\n            if (!arguments.length) return sortChords;\n            sortChords = x;\n            if (chords) resort();\n            return chord;\n          };\n\n          chord.chords = function () {\n            if (!chords) relayout();\n            return chords;\n          };\n\n          chord.groups = function () {\n            if (!groups) relayout();\n            return groups;\n          };\n\n          return chord;\n        };\n\n        d3.layout.force = function () {\n          var force = {},\n              event = d3.dispatch(\"start\", \"tick\", \"end\"),\n              timer,\n              size = [1, 1],\n              drag,\n              alpha,\n              friction = .9,\n              linkDistance = d3_layout_forceLinkDistance,\n              linkStrength = d3_layout_forceLinkStrength,\n              charge = -30,\n              chargeDistance2 = d3_layout_forceChargeDistance2,\n              gravity = .1,\n              theta2 = .64,\n              nodes = [],\n              links = [],\n              distances,\n              strengths,\n              charges;\n\n          function repulse(node) {\n            return function (quad, x1, _, x2) {\n              if (quad.point !== node) {\n                var dx = quad.cx - node.x,\n                    dy = quad.cy - node.y,\n                    dw = x2 - x1,\n                    dn = dx * dx + dy * dy;\n\n                if (dw * dw / theta2 < dn) {\n                  if (dn < chargeDistance2) {\n                    var k = quad.charge / dn;\n                    node.px -= dx * k;\n                    node.py -= dy * k;\n                  }\n\n                  return true;\n                }\n\n                if (quad.point && dn && dn < chargeDistance2) {\n                  var k = quad.pointCharge / dn;\n                  node.px -= dx * k;\n                  node.py -= dy * k;\n                }\n              }\n\n              return !quad.charge;\n            };\n          }\n\n          force.tick = function () {\n            if ((alpha *= .99) < .005) {\n              timer = null;\n              event.end({\n                type: \"end\",\n                alpha: alpha = 0\n              });\n              return true;\n            }\n\n            var n = nodes.length,\n                m = links.length,\n                q,\n                i,\n                o,\n                s,\n                t,\n                l,\n                k,\n                x,\n                y;\n\n            for (i = 0; i < m; ++i) {\n              o = links[i];\n              s = o.source;\n              t = o.target;\n              x = t.x - s.x;\n              y = t.y - s.y;\n\n              if (l = x * x + y * y) {\n                l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n                x *= l;\n                y *= l;\n                t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);\n                t.y -= y * k;\n                s.x += x * (k = 1 - k);\n                s.y += y * k;\n              }\n            }\n\n            if (k = alpha * gravity) {\n              x = size[0] / 2;\n              y = size[1] / 2;\n              i = -1;\n              if (k) while (++i < n) {\n                o = nodes[i];\n                o.x += (x - o.x) * k;\n                o.y += (y - o.y) * k;\n              }\n            }\n\n            if (charge) {\n              d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n              i = -1;\n\n              while (++i < n) {\n                if (!(o = nodes[i]).fixed) {\n                  q.visit(repulse(o));\n                }\n              }\n            }\n\n            i = -1;\n\n            while (++i < n) {\n              o = nodes[i];\n\n              if (o.fixed) {\n                o.x = o.px;\n                o.y = o.py;\n              } else {\n                o.x -= (o.px - (o.px = o.x)) * friction;\n                o.y -= (o.py - (o.py = o.y)) * friction;\n              }\n            }\n\n            event.tick({\n              type: \"tick\",\n              alpha: alpha\n            });\n          };\n\n          force.nodes = function (x) {\n            if (!arguments.length) return nodes;\n            nodes = x;\n            return force;\n          };\n\n          force.links = function (x) {\n            if (!arguments.length) return links;\n            links = x;\n            return force;\n          };\n\n          force.size = function (x) {\n            if (!arguments.length) return size;\n            size = x;\n            return force;\n          };\n\n          force.linkDistance = function (x) {\n            if (!arguments.length) return linkDistance;\n            linkDistance = typeof x === \"function\" ? x : +x;\n            return force;\n          };\n\n          force.distance = force.linkDistance;\n\n          force.linkStrength = function (x) {\n            if (!arguments.length) return linkStrength;\n            linkStrength = typeof x === \"function\" ? x : +x;\n            return force;\n          };\n\n          force.friction = function (x) {\n            if (!arguments.length) return friction;\n            friction = +x;\n            return force;\n          };\n\n          force.charge = function (x) {\n            if (!arguments.length) return charge;\n            charge = typeof x === \"function\" ? x : +x;\n            return force;\n          };\n\n          force.chargeDistance = function (x) {\n            if (!arguments.length) return Math.sqrt(chargeDistance2);\n            chargeDistance2 = x * x;\n            return force;\n          };\n\n          force.gravity = function (x) {\n            if (!arguments.length) return gravity;\n            gravity = +x;\n            return force;\n          };\n\n          force.theta = function (x) {\n            if (!arguments.length) return Math.sqrt(theta2);\n            theta2 = x * x;\n            return force;\n          };\n\n          force.alpha = function (x) {\n            if (!arguments.length) return alpha;\n            x = +x;\n\n            if (alpha) {\n              if (x > 0) {\n                alpha = x;\n              } else {\n                timer.c = null, timer.t = NaN, timer = null;\n                event.end({\n                  type: \"end\",\n                  alpha: alpha = 0\n                });\n              }\n            } else if (x > 0) {\n              event.start({\n                type: \"start\",\n                alpha: alpha = x\n              });\n              timer = d3_timer(force.tick);\n            }\n\n            return force;\n          };\n\n          force.start = function () {\n            var i,\n                n = nodes.length,\n                m = links.length,\n                w = size[0],\n                h = size[1],\n                neighbors,\n                o;\n\n            for (i = 0; i < n; ++i) {\n              (o = nodes[i]).index = i;\n              o.weight = 0;\n            }\n\n            for (i = 0; i < m; ++i) {\n              o = links[i];\n              if (typeof o.source == \"number\") o.source = nodes[o.source];\n              if (typeof o.target == \"number\") o.target = nodes[o.target];\n              ++o.source.weight;\n              ++o.target.weight;\n            }\n\n            for (i = 0; i < n; ++i) {\n              o = nodes[i];\n              if (isNaN(o.x)) o.x = position(\"x\", w);\n              if (isNaN(o.y)) o.y = position(\"y\", h);\n              if (isNaN(o.px)) o.px = o.x;\n              if (isNaN(o.py)) o.py = o.y;\n            }\n\n            distances = [];\n            if (typeof linkDistance === \"function\") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i);else for (i = 0; i < m; ++i) distances[i] = linkDistance;\n            strengths = [];\n            if (typeof linkStrength === \"function\") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i);else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\n            charges = [];\n            if (typeof charge === \"function\") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i);else for (i = 0; i < n; ++i) charges[i] = charge;\n\n            function position(dimension, size) {\n              if (!neighbors) {\n                neighbors = new Array(n);\n\n                for (j = 0; j < n; ++j) {\n                  neighbors[j] = [];\n                }\n\n                for (j = 0; j < m; ++j) {\n                  var o = links[j];\n                  neighbors[o.source.index].push(o.target);\n                  neighbors[o.target.index].push(o.source);\n                }\n              }\n\n              var candidates = neighbors[i],\n                  j = -1,\n                  l = candidates.length,\n                  x;\n\n              while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;\n\n              return Math.random() * size;\n            }\n\n            return force.resume();\n          };\n\n          force.resume = function () {\n            return force.alpha(.1);\n          };\n\n          force.stop = function () {\n            return force.alpha(0);\n          };\n\n          force.drag = function () {\n            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\"dragstart.force\", d3_layout_forceDragstart).on(\"drag.force\", dragmove).on(\"dragend.force\", d3_layout_forceDragend);\n            if (!arguments.length) return drag;\n            this.on(\"mouseover.force\", d3_layout_forceMouseover).on(\"mouseout.force\", d3_layout_forceMouseout).call(drag);\n          };\n\n          function dragmove(d) {\n            d.px = d3.event.x, d.py = d3.event.y;\n            force.resume();\n          }\n\n          return d3.rebind(force, event, \"on\");\n        };\n\n        function d3_layout_forceDragstart(d) {\n          d.fixed |= 2;\n        }\n\n        function d3_layout_forceDragend(d) {\n          d.fixed &= ~6;\n        }\n\n        function d3_layout_forceMouseover(d) {\n          d.fixed |= 4;\n          d.px = d.x, d.py = d.y;\n        }\n\n        function d3_layout_forceMouseout(d) {\n          d.fixed &= ~4;\n        }\n\n        function d3_layout_forceAccumulate(quad, alpha, charges) {\n          var cx = 0,\n              cy = 0;\n          quad.charge = 0;\n\n          if (!quad.leaf) {\n            var nodes = quad.nodes,\n                n = nodes.length,\n                i = -1,\n                c;\n\n            while (++i < n) {\n              c = nodes[i];\n              if (c == null) continue;\n              d3_layout_forceAccumulate(c, alpha, charges);\n              quad.charge += c.charge;\n              cx += c.charge * c.cx;\n              cy += c.charge * c.cy;\n            }\n          }\n\n          if (quad.point) {\n            if (!quad.leaf) {\n              quad.point.x += Math.random() - .5;\n              quad.point.y += Math.random() - .5;\n            }\n\n            var k = alpha * charges[quad.point.index];\n            quad.charge += quad.pointCharge = k;\n            cx += k * quad.point.x;\n            cy += k * quad.point.y;\n          }\n\n          quad.cx = cx / quad.charge;\n          quad.cy = cy / quad.charge;\n        }\n\n        var d3_layout_forceLinkDistance = 20,\n            d3_layout_forceLinkStrength = 1,\n            d3_layout_forceChargeDistance2 = Infinity;\n\n        d3.layout.hierarchy = function () {\n          var sort = d3_layout_hierarchySort,\n              children = d3_layout_hierarchyChildren,\n              value = d3_layout_hierarchyValue;\n\n          function hierarchy(root) {\n            var stack = [root],\n                nodes = [],\n                node;\n            root.depth = 0;\n\n            while ((node = stack.pop()) != null) {\n              nodes.push(node);\n\n              if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\n                var n, childs, child;\n\n                while (--n >= 0) {\n                  stack.push(child = childs[n]);\n                  child.parent = node;\n                  child.depth = node.depth + 1;\n                }\n\n                if (value) node.value = 0;\n                node.children = childs;\n              } else {\n                if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\n                delete node.children;\n              }\n            }\n\n            d3_layout_hierarchyVisitAfter(root, function (node) {\n              var childs, parent;\n              if (sort && (childs = node.children)) childs.sort(sort);\n              if (value && (parent = node.parent)) parent.value += node.value;\n            });\n            return nodes;\n          }\n\n          hierarchy.sort = function (x) {\n            if (!arguments.length) return sort;\n            sort = x;\n            return hierarchy;\n          };\n\n          hierarchy.children = function (x) {\n            if (!arguments.length) return children;\n            children = x;\n            return hierarchy;\n          };\n\n          hierarchy.value = function (x) {\n            if (!arguments.length) return value;\n            value = x;\n            return hierarchy;\n          };\n\n          hierarchy.revalue = function (root) {\n            if (value) {\n              d3_layout_hierarchyVisitBefore(root, function (node) {\n                if (node.children) node.value = 0;\n              });\n              d3_layout_hierarchyVisitAfter(root, function (node) {\n                var parent;\n                if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\n                if (parent = node.parent) parent.value += node.value;\n              });\n            }\n\n            return root;\n          };\n\n          return hierarchy;\n        };\n\n        function d3_layout_hierarchyRebind(object, hierarchy) {\n          d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n          object.nodes = object;\n          object.links = d3_layout_hierarchyLinks;\n          return object;\n        }\n\n        function d3_layout_hierarchyVisitBefore(node, callback) {\n          var nodes = [node];\n\n          while ((node = nodes.pop()) != null) {\n            callback(node);\n\n            if ((children = node.children) && (n = children.length)) {\n              var n, children;\n\n              while (--n >= 0) nodes.push(children[n]);\n            }\n          }\n        }\n\n        function d3_layout_hierarchyVisitAfter(node, callback) {\n          var nodes = [node],\n              nodes2 = [];\n\n          while ((node = nodes.pop()) != null) {\n            nodes2.push(node);\n\n            if ((children = node.children) && (n = children.length)) {\n              var i = -1,\n                  n,\n                  children;\n\n              while (++i < n) nodes.push(children[i]);\n            }\n          }\n\n          while ((node = nodes2.pop()) != null) {\n            callback(node);\n          }\n        }\n\n        function d3_layout_hierarchyChildren(d) {\n          return d.children;\n        }\n\n        function d3_layout_hierarchyValue(d) {\n          return d.value;\n        }\n\n        function d3_layout_hierarchySort(a, b) {\n          return b.value - a.value;\n        }\n\n        function d3_layout_hierarchyLinks(nodes) {\n          return d3.merge(nodes.map(function (parent) {\n            return (parent.children || []).map(function (child) {\n              return {\n                source: parent,\n                target: child\n              };\n            });\n          }));\n        }\n\n        d3.layout.partition = function () {\n          var hierarchy = d3.layout.hierarchy(),\n              size = [1, 1];\n\n          function position(node, x, dx, dy) {\n            var children = node.children;\n            node.x = x;\n            node.y = node.depth * dy;\n            node.dx = dx;\n            node.dy = dy;\n\n            if (children && (n = children.length)) {\n              var i = -1,\n                  n,\n                  c,\n                  d;\n              dx = node.value ? dx / node.value : 0;\n\n              while (++i < n) {\n                position(c = children[i], x, d = c.value * dx, dy);\n                x += d;\n              }\n            }\n          }\n\n          function depth(node) {\n            var children = node.children,\n                d = 0;\n\n            if (children && (n = children.length)) {\n              var i = -1,\n                  n;\n\n              while (++i < n) d = Math.max(d, depth(children[i]));\n            }\n\n            return 1 + d;\n          }\n\n          function partition(d, i) {\n            var nodes = hierarchy.call(this, d, i);\n            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n            return nodes;\n          }\n\n          partition.size = function (x) {\n            if (!arguments.length) return size;\n            size = x;\n            return partition;\n          };\n\n          return d3_layout_hierarchyRebind(partition, hierarchy);\n        };\n\n        d3.layout.pie = function () {\n          var value = Number,\n              sort = d3_layout_pieSortByValue,\n              startAngle = 0,\n              endAngle = τ,\n              padAngle = 0;\n\n          function pie(data) {\n            var n = data.length,\n                values = data.map(function (d, i) {\n              return +value.call(pie, d, i);\n            }),\n                a = +(typeof startAngle === \"function\" ? startAngle.apply(this, arguments) : startAngle),\n                da = (typeof endAngle === \"function\" ? endAngle.apply(this, arguments) : endAngle) - a,\n                p = Math.min(Math.abs(da) / n, +(typeof padAngle === \"function\" ? padAngle.apply(this, arguments) : padAngle)),\n                pa = p * (da < 0 ? -1 : 1),\n                sum = d3.sum(values),\n                k = sum ? (da - n * pa) / sum : 0,\n                index = d3.range(n),\n                arcs = [],\n                v;\n            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {\n              return values[j] - values[i];\n            } : function (i, j) {\n              return sort(data[i], data[j]);\n            });\n            index.forEach(function (i) {\n              arcs[i] = {\n                data: data[i],\n                value: v = values[i],\n                startAngle: a,\n                endAngle: a += v * k + pa,\n                padAngle: p\n              };\n            });\n            return arcs;\n          }\n\n          pie.value = function (_) {\n            if (!arguments.length) return value;\n            value = _;\n            return pie;\n          };\n\n          pie.sort = function (_) {\n            if (!arguments.length) return sort;\n            sort = _;\n            return pie;\n          };\n\n          pie.startAngle = function (_) {\n            if (!arguments.length) return startAngle;\n            startAngle = _;\n            return pie;\n          };\n\n          pie.endAngle = function (_) {\n            if (!arguments.length) return endAngle;\n            endAngle = _;\n            return pie;\n          };\n\n          pie.padAngle = function (_) {\n            if (!arguments.length) return padAngle;\n            padAngle = _;\n            return pie;\n          };\n\n          return pie;\n        };\n\n        var d3_layout_pieSortByValue = {};\n\n        d3.layout.stack = function () {\n          var values = d3_identity,\n              order = d3_layout_stackOrderDefault,\n              offset = d3_layout_stackOffsetZero,\n              out = d3_layout_stackOut,\n              x = d3_layout_stackX,\n              y = d3_layout_stackY;\n\n          function stack(data, index) {\n            if (!(n = data.length)) return data;\n            var series = data.map(function (d, i) {\n              return values.call(stack, d, i);\n            });\n            var points = series.map(function (d) {\n              return d.map(function (v, i) {\n                return [x.call(stack, v, i), y.call(stack, v, i)];\n              });\n            });\n            var orders = order.call(stack, points, index);\n            series = d3.permute(series, orders);\n            points = d3.permute(points, orders);\n            var offsets = offset.call(stack, points, index);\n            var m = series[0].length,\n                n,\n                i,\n                j,\n                o;\n\n            for (j = 0; j < m; ++j) {\n              out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n\n              for (i = 1; i < n; ++i) {\n                out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n              }\n            }\n\n            return data;\n          }\n\n          stack.values = function (x) {\n            if (!arguments.length) return values;\n            values = x;\n            return stack;\n          };\n\n          stack.order = function (x) {\n            if (!arguments.length) return order;\n            order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n            return stack;\n          };\n\n          stack.offset = function (x) {\n            if (!arguments.length) return offset;\n            offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n            return stack;\n          };\n\n          stack.x = function (z) {\n            if (!arguments.length) return x;\n            x = z;\n            return stack;\n          };\n\n          stack.y = function (z) {\n            if (!arguments.length) return y;\n            y = z;\n            return stack;\n          };\n\n          stack.out = function (z) {\n            if (!arguments.length) return out;\n            out = z;\n            return stack;\n          };\n\n          return stack;\n        };\n\n        function d3_layout_stackX(d) {\n          return d.x;\n        }\n\n        function d3_layout_stackY(d) {\n          return d.y;\n        }\n\n        function d3_layout_stackOut(d, y0, y) {\n          d.y0 = y0;\n          d.y = y;\n        }\n\n        var d3_layout_stackOrders = d3.map({\n          \"inside-out\": function (data) {\n            var n = data.length,\n                i,\n                j,\n                max = data.map(d3_layout_stackMaxIndex),\n                sums = data.map(d3_layout_stackReduceSum),\n                index = d3.range(n).sort(function (a, b) {\n              return max[a] - max[b];\n            }),\n                top = 0,\n                bottom = 0,\n                tops = [],\n                bottoms = [];\n\n            for (i = 0; i < n; ++i) {\n              j = index[i];\n\n              if (top < bottom) {\n                top += sums[j];\n                tops.push(j);\n              } else {\n                bottom += sums[j];\n                bottoms.push(j);\n              }\n            }\n\n            return bottoms.reverse().concat(tops);\n          },\n          reverse: function (data) {\n            return d3.range(data.length).reverse();\n          },\n          \"default\": d3_layout_stackOrderDefault\n        });\n        var d3_layout_stackOffsets = d3.map({\n          silhouette: function (data) {\n            var n = data.length,\n                m = data[0].length,\n                sums = [],\n                max = 0,\n                i,\n                j,\n                o,\n                y0 = [];\n\n            for (j = 0; j < m; ++j) {\n              for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n\n              if (o > max) max = o;\n              sums.push(o);\n            }\n\n            for (j = 0; j < m; ++j) {\n              y0[j] = (max - sums[j]) / 2;\n            }\n\n            return y0;\n          },\n          wiggle: function (data) {\n            var n = data.length,\n                x = data[0],\n                m = x.length,\n                i,\n                j,\n                k,\n                s1,\n                s2,\n                s3,\n                dx,\n                o,\n                o0,\n                y0 = [];\n            y0[0] = o = o0 = 0;\n\n            for (j = 1; j < m; ++j) {\n              for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n\n              for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n                for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n                  s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n                }\n\n                s2 += s3 * data[i][j][1];\n              }\n\n              y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n              if (o < o0) o0 = o;\n            }\n\n            for (j = 0; j < m; ++j) y0[j] -= o0;\n\n            return y0;\n          },\n          expand: function (data) {\n            var n = data.length,\n                m = data[0].length,\n                k = 1 / n,\n                i,\n                j,\n                o,\n                y0 = [];\n\n            for (j = 0; j < m; ++j) {\n              for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n\n              if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;else for (i = 0; i < n; i++) data[i][j][1] = k;\n            }\n\n            for (j = 0; j < m; ++j) y0[j] = 0;\n\n            return y0;\n          },\n          zero: d3_layout_stackOffsetZero\n        });\n\n        function d3_layout_stackOrderDefault(data) {\n          return d3.range(data.length);\n        }\n\n        function d3_layout_stackOffsetZero(data) {\n          var j = -1,\n              m = data[0].length,\n              y0 = [];\n\n          while (++j < m) y0[j] = 0;\n\n          return y0;\n        }\n\n        function d3_layout_stackMaxIndex(array) {\n          var i = 1,\n              j = 0,\n              v = array[0][1],\n              k,\n              n = array.length;\n\n          for (; i < n; ++i) {\n            if ((k = array[i][1]) > v) {\n              j = i;\n              v = k;\n            }\n          }\n\n          return j;\n        }\n\n        function d3_layout_stackReduceSum(d) {\n          return d.reduce(d3_layout_stackSum, 0);\n        }\n\n        function d3_layout_stackSum(p, d) {\n          return p + d[1];\n        }\n\n        d3.layout.histogram = function () {\n          var frequency = true,\n              valuer = Number,\n              ranger = d3_layout_histogramRange,\n              binner = d3_layout_histogramBinSturges;\n\n          function histogram(data, i) {\n            var bins = [],\n                values = data.map(valuer, this),\n                range = ranger.call(this, values, i),\n                thresholds = binner.call(this, range, values, i),\n                bin,\n                i = -1,\n                n = values.length,\n                m = thresholds.length - 1,\n                k = frequency ? 1 : 1 / n,\n                x;\n\n            while (++i < m) {\n              bin = bins[i] = [];\n              bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n              bin.y = 0;\n            }\n\n            if (m > 0) {\n              i = -1;\n\n              while (++i < n) {\n                x = values[i];\n\n                if (x >= range[0] && x <= range[1]) {\n                  bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n                  bin.y += k;\n                  bin.push(data[i]);\n                }\n              }\n            }\n\n            return bins;\n          }\n\n          histogram.value = function (x) {\n            if (!arguments.length) return valuer;\n            valuer = x;\n            return histogram;\n          };\n\n          histogram.range = function (x) {\n            if (!arguments.length) return ranger;\n            ranger = d3_functor(x);\n            return histogram;\n          };\n\n          histogram.bins = function (x) {\n            if (!arguments.length) return binner;\n            binner = typeof x === \"number\" ? function (range) {\n              return d3_layout_histogramBinFixed(range, x);\n            } : d3_functor(x);\n            return histogram;\n          };\n\n          histogram.frequency = function (x) {\n            if (!arguments.length) return frequency;\n            frequency = !!x;\n            return histogram;\n          };\n\n          return histogram;\n        };\n\n        function d3_layout_histogramBinSturges(range, values) {\n          return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n        }\n\n        function d3_layout_histogramBinFixed(range, n) {\n          var x = -1,\n              b = +range[0],\n              m = (range[1] - b) / n,\n              f = [];\n\n          while (++x <= n) f[x] = m * x + b;\n\n          return f;\n        }\n\n        function d3_layout_histogramRange(values) {\n          return [d3.min(values), d3.max(values)];\n        }\n\n        d3.layout.pack = function () {\n          var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),\n              padding = 0,\n              size = [1, 1],\n              radius;\n\n          function pack(d, i) {\n            var nodes = hierarchy.call(this, d, i),\n                root = nodes[0],\n                w = size[0],\n                h = size[1],\n                r = radius == null ? Math.sqrt : typeof radius === \"function\" ? radius : function () {\n              return radius;\n            };\n            root.x = root.y = 0;\n            d3_layout_hierarchyVisitAfter(root, function (d) {\n              d.r = +r(d.value);\n            });\n            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n\n            if (padding) {\n              var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;\n              d3_layout_hierarchyVisitAfter(root, function (d) {\n                d.r += dr;\n              });\n              d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n              d3_layout_hierarchyVisitAfter(root, function (d) {\n                d.r -= dr;\n              });\n            }\n\n            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));\n            return nodes;\n          }\n\n          pack.size = function (_) {\n            if (!arguments.length) return size;\n            size = _;\n            return pack;\n          };\n\n          pack.radius = function (_) {\n            if (!arguments.length) return radius;\n            radius = _ == null || typeof _ === \"function\" ? _ : +_;\n            return pack;\n          };\n\n          pack.padding = function (_) {\n            if (!arguments.length) return padding;\n            padding = +_;\n            return pack;\n          };\n\n          return d3_layout_hierarchyRebind(pack, hierarchy);\n        };\n\n        function d3_layout_packSort(a, b) {\n          return a.value - b.value;\n        }\n\n        function d3_layout_packInsert(a, b) {\n          var c = a._pack_next;\n          a._pack_next = b;\n          b._pack_prev = a;\n          b._pack_next = c;\n          c._pack_prev = b;\n        }\n\n        function d3_layout_packSplice(a, b) {\n          a._pack_next = b;\n          b._pack_prev = a;\n        }\n\n        function d3_layout_packIntersects(a, b) {\n          var dx = b.x - a.x,\n              dy = b.y - a.y,\n              dr = a.r + b.r;\n          return .999 * dr * dr > dx * dx + dy * dy;\n        }\n\n        function d3_layout_packSiblings(node) {\n          if (!(nodes = node.children) || !(n = nodes.length)) return;\n          var nodes,\n              xMin = Infinity,\n              xMax = -Infinity,\n              yMin = Infinity,\n              yMax = -Infinity,\n              a,\n              b,\n              c,\n              i,\n              j,\n              k,\n              n;\n\n          function bound(node) {\n            xMin = Math.min(node.x - node.r, xMin);\n            xMax = Math.max(node.x + node.r, xMax);\n            yMin = Math.min(node.y - node.r, yMin);\n            yMax = Math.max(node.y + node.r, yMax);\n          }\n\n          nodes.forEach(d3_layout_packLink);\n          a = nodes[0];\n          a.x = -a.r;\n          a.y = 0;\n          bound(a);\n\n          if (n > 1) {\n            b = nodes[1];\n            b.x = b.r;\n            b.y = 0;\n            bound(b);\n\n            if (n > 2) {\n              c = nodes[2];\n              d3_layout_packPlace(a, b, c);\n              bound(c);\n              d3_layout_packInsert(a, c);\n              a._pack_prev = c;\n              d3_layout_packInsert(c, b);\n              b = a._pack_next;\n\n              for (i = 3; i < n; i++) {\n                d3_layout_packPlace(a, b, c = nodes[i]);\n                var isect = 0,\n                    s1 = 1,\n                    s2 = 1;\n\n                for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n                  if (d3_layout_packIntersects(j, c)) {\n                    isect = 1;\n                    break;\n                  }\n                }\n\n                if (isect == 1) {\n                  for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n                    if (d3_layout_packIntersects(k, c)) {\n                      break;\n                    }\n                  }\n                }\n\n                if (isect) {\n                  if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j);else d3_layout_packSplice(a = k, b);\n                  i--;\n                } else {\n                  d3_layout_packInsert(a, c);\n                  b = c;\n                  bound(c);\n                }\n              }\n            }\n          }\n\n          var cx = (xMin + xMax) / 2,\n              cy = (yMin + yMax) / 2,\n              cr = 0;\n\n          for (i = 0; i < n; i++) {\n            c = nodes[i];\n            c.x -= cx;\n            c.y -= cy;\n            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n          }\n\n          node.r = cr;\n          nodes.forEach(d3_layout_packUnlink);\n        }\n\n        function d3_layout_packLink(node) {\n          node._pack_next = node._pack_prev = node;\n        }\n\n        function d3_layout_packUnlink(node) {\n          delete node._pack_next;\n          delete node._pack_prev;\n        }\n\n        function d3_layout_packTransform(node, x, y, k) {\n          var children = node.children;\n          node.x = x += k * node.x;\n          node.y = y += k * node.y;\n          node.r *= k;\n\n          if (children) {\n            var i = -1,\n                n = children.length;\n\n            while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n          }\n        }\n\n        function d3_layout_packPlace(a, b, c) {\n          var db = a.r + c.r,\n              dx = b.x - a.x,\n              dy = b.y - a.y;\n\n          if (db && (dx || dy)) {\n            var da = b.r + c.r,\n                dc = dx * dx + dy * dy;\n            da *= da;\n            db *= db;\n            var x = .5 + (db - da) / (2 * dc),\n                y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n            c.x = a.x + x * dx + y * dy;\n            c.y = a.y + x * dy - y * dx;\n          } else {\n            c.x = a.x + db;\n            c.y = a.y;\n          }\n        }\n\n        d3.layout.tree = function () {\n          var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n              separation = d3_layout_treeSeparation,\n              size = [1, 1],\n              nodeSize = null;\n\n          function tree(d, i) {\n            var nodes = hierarchy.call(this, d, i),\n                root0 = nodes[0],\n                root1 = wrapTree(root0);\n            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;\n            d3_layout_hierarchyVisitBefore(root1, secondWalk);\n            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode);else {\n              var left = root0,\n                  right = root0,\n                  bottom = root0;\n              d3_layout_hierarchyVisitBefore(root0, function (node) {\n                if (node.x < left.x) left = node;\n                if (node.x > right.x) right = node;\n                if (node.depth > bottom.depth) bottom = node;\n              });\n              var tx = separation(left, right) / 2 - left.x,\n                  kx = size[0] / (right.x + separation(right, left) / 2 + tx),\n                  ky = size[1] / (bottom.depth || 1);\n              d3_layout_hierarchyVisitBefore(root0, function (node) {\n                node.x = (node.x + tx) * kx;\n                node.y = node.depth * ky;\n              });\n            }\n            return nodes;\n          }\n\n          function wrapTree(root0) {\n            var root1 = {\n              A: null,\n              children: [root0]\n            },\n                queue = [root1],\n                node1;\n\n            while ((node1 = queue.pop()) != null) {\n              for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {\n                queue.push((children[i] = child = {\n                  _: children[i],\n                  parent: node1,\n                  children: (child = children[i].children) && child.slice() || [],\n                  A: null,\n                  a: null,\n                  z: 0,\n                  m: 0,\n                  c: 0,\n                  s: 0,\n                  t: null,\n                  i: i\n                }).a = child);\n              }\n            }\n\n            return root1.children[0];\n          }\n\n          function firstWalk(v) {\n            var children = v.children,\n                siblings = v.parent.children,\n                w = v.i ? siblings[v.i - 1] : null;\n\n            if (children.length) {\n              d3_layout_treeShift(v);\n              var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n\n              if (w) {\n                v.z = w.z + separation(v._, w._);\n                v.m = v.z - midpoint;\n              } else {\n                v.z = midpoint;\n              }\n            } else if (w) {\n              v.z = w.z + separation(v._, w._);\n            }\n\n            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n          }\n\n          function secondWalk(v) {\n            v._.x = v.z + v.parent.m;\n            v.m += v.parent.m;\n          }\n\n          function apportion(v, w, ancestor) {\n            if (w) {\n              var vip = v,\n                  vop = v,\n                  vim = w,\n                  vom = vip.parent.children[0],\n                  sip = vip.m,\n                  sop = vop.m,\n                  sim = vim.m,\n                  som = vom.m,\n                  shift;\n\n              while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n                vom = d3_layout_treeLeft(vom);\n                vop = d3_layout_treeRight(vop);\n                vop.a = v;\n                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n\n                if (shift > 0) {\n                  d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);\n                  sip += shift;\n                  sop += shift;\n                }\n\n                sim += vim.m;\n                sip += vip.m;\n                som += vom.m;\n                sop += vop.m;\n              }\n\n              if (vim && !d3_layout_treeRight(vop)) {\n                vop.t = vim;\n                vop.m += sim - sop;\n              }\n\n              if (vip && !d3_layout_treeLeft(vom)) {\n                vom.t = vip;\n                vom.m += sip - som;\n                ancestor = v;\n              }\n            }\n\n            return ancestor;\n          }\n\n          function sizeNode(node) {\n            node.x *= size[0];\n            node.y = node.depth * size[1];\n          }\n\n          tree.separation = function (x) {\n            if (!arguments.length) return separation;\n            separation = x;\n            return tree;\n          };\n\n          tree.size = function (x) {\n            if (!arguments.length) return nodeSize ? null : size;\n            nodeSize = (size = x) == null ? sizeNode : null;\n            return tree;\n          };\n\n          tree.nodeSize = function (x) {\n            if (!arguments.length) return nodeSize ? size : null;\n            nodeSize = (size = x) == null ? null : sizeNode;\n            return tree;\n          };\n\n          return d3_layout_hierarchyRebind(tree, hierarchy);\n        };\n\n        function d3_layout_treeSeparation(a, b) {\n          return a.parent == b.parent ? 1 : 2;\n        }\n\n        function d3_layout_treeLeft(v) {\n          var children = v.children;\n          return children.length ? children[0] : v.t;\n        }\n\n        function d3_layout_treeRight(v) {\n          var children = v.children,\n              n;\n          return (n = children.length) ? children[n - 1] : v.t;\n        }\n\n        function d3_layout_treeMove(wm, wp, shift) {\n          var change = shift / (wp.i - wm.i);\n          wp.c -= change;\n          wp.s += shift;\n          wm.c += change;\n          wp.z += shift;\n          wp.m += shift;\n        }\n\n        function d3_layout_treeShift(v) {\n          var shift = 0,\n              change = 0,\n              children = v.children,\n              i = children.length,\n              w;\n\n          while (--i >= 0) {\n            w = children[i];\n            w.z += shift;\n            w.m += shift;\n            shift += w.s + (change += w.c);\n          }\n        }\n\n        function d3_layout_treeAncestor(vim, v, ancestor) {\n          return vim.a.parent === v.parent ? vim.a : ancestor;\n        }\n\n        d3.layout.cluster = function () {\n          var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n              separation = d3_layout_treeSeparation,\n              size = [1, 1],\n              nodeSize = false;\n\n          function cluster(d, i) {\n            var nodes = hierarchy.call(this, d, i),\n                root = nodes[0],\n                previousNode,\n                x = 0;\n            d3_layout_hierarchyVisitAfter(root, function (node) {\n              var children = node.children;\n\n              if (children && children.length) {\n                node.x = d3_layout_clusterX(children);\n                node.y = d3_layout_clusterY(children);\n              } else {\n                node.x = previousNode ? x += separation(node, previousNode) : 0;\n                node.y = 0;\n                previousNode = node;\n              }\n            });\n            var left = d3_layout_clusterLeft(root),\n                right = d3_layout_clusterRight(root),\n                x0 = left.x - separation(left, right) / 2,\n                x1 = right.x + separation(right, left) / 2;\n            d3_layout_hierarchyVisitAfter(root, nodeSize ? function (node) {\n              node.x = (node.x - root.x) * size[0];\n              node.y = (root.y - node.y) * size[1];\n            } : function (node) {\n              node.x = (node.x - x0) / (x1 - x0) * size[0];\n              node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n            });\n            return nodes;\n          }\n\n          cluster.separation = function (x) {\n            if (!arguments.length) return separation;\n            separation = x;\n            return cluster;\n          };\n\n          cluster.size = function (x) {\n            if (!arguments.length) return nodeSize ? null : size;\n            nodeSize = (size = x) == null;\n            return cluster;\n          };\n\n          cluster.nodeSize = function (x) {\n            if (!arguments.length) return nodeSize ? size : null;\n            nodeSize = (size = x) != null;\n            return cluster;\n          };\n\n          return d3_layout_hierarchyRebind(cluster, hierarchy);\n        };\n\n        function d3_layout_clusterY(children) {\n          return 1 + d3.max(children, function (child) {\n            return child.y;\n          });\n        }\n\n        function d3_layout_clusterX(children) {\n          return children.reduce(function (x, child) {\n            return x + child.x;\n          }, 0) / children.length;\n        }\n\n        function d3_layout_clusterLeft(node) {\n          var children = node.children;\n          return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n        }\n\n        function d3_layout_clusterRight(node) {\n          var children = node.children,\n              n;\n          return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n        }\n\n        d3.layout.treemap = function () {\n          var hierarchy = d3.layout.hierarchy(),\n              round = Math.round,\n              size = [1, 1],\n              padding = null,\n              pad = d3_layout_treemapPadNull,\n              sticky = false,\n              stickies,\n              mode = \"squarify\",\n              ratio = .5 * (1 + Math.sqrt(5));\n\n          function scale(children, k) {\n            var i = -1,\n                n = children.length,\n                child,\n                area;\n\n            while (++i < n) {\n              area = (child = children[i]).value * (k < 0 ? 0 : k);\n              child.area = isNaN(area) || area <= 0 ? 0 : area;\n            }\n          }\n\n          function squarify(node) {\n            var children = node.children;\n\n            if (children && children.length) {\n              var rect = pad(node),\n                  row = [],\n                  remaining = children.slice(),\n                  child,\n                  best = Infinity,\n                  score,\n                  u = mode === \"slice\" ? rect.dx : mode === \"dice\" ? rect.dy : mode === \"slice-dice\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy),\n                  n;\n              scale(remaining, rect.dx * rect.dy / node.value);\n              row.area = 0;\n\n              while ((n = remaining.length) > 0) {\n                row.push(child = remaining[n - 1]);\n                row.area += child.area;\n\n                if (mode !== \"squarify\" || (score = worst(row, u)) <= best) {\n                  remaining.pop();\n                  best = score;\n                } else {\n                  row.area -= row.pop().area;\n                  position(row, u, rect, false);\n                  u = Math.min(rect.dx, rect.dy);\n                  row.length = row.area = 0;\n                  best = Infinity;\n                }\n              }\n\n              if (row.length) {\n                position(row, u, rect, true);\n                row.length = row.area = 0;\n              }\n\n              children.forEach(squarify);\n            }\n          }\n\n          function stickify(node) {\n            var children = node.children;\n\n            if (children && children.length) {\n              var rect = pad(node),\n                  remaining = children.slice(),\n                  child,\n                  row = [];\n              scale(remaining, rect.dx * rect.dy / node.value);\n              row.area = 0;\n\n              while (child = remaining.pop()) {\n                row.push(child);\n                row.area += child.area;\n\n                if (child.z != null) {\n                  position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n                  row.length = row.area = 0;\n                }\n              }\n\n              children.forEach(stickify);\n            }\n          }\n\n          function worst(row, u) {\n            var s = row.area,\n                r,\n                rmax = 0,\n                rmin = Infinity,\n                i = -1,\n                n = row.length;\n\n            while (++i < n) {\n              if (!(r = row[i].area)) continue;\n              if (r < rmin) rmin = r;\n              if (r > rmax) rmax = r;\n            }\n\n            s *= s;\n            u *= u;\n            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\n          }\n\n          function position(row, u, rect, flush) {\n            var i = -1,\n                n = row.length,\n                x = rect.x,\n                y = rect.y,\n                v = u ? round(row.area / u) : 0,\n                o;\n\n            if (u == rect.dx) {\n              if (flush || v > rect.dy) v = rect.dy;\n\n              while (++i < n) {\n                o = row[i];\n                o.x = x;\n                o.y = y;\n                o.dy = v;\n                x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n              }\n\n              o.z = true;\n              o.dx += rect.x + rect.dx - x;\n              rect.y += v;\n              rect.dy -= v;\n            } else {\n              if (flush || v > rect.dx) v = rect.dx;\n\n              while (++i < n) {\n                o = row[i];\n                o.x = x;\n                o.y = y;\n                o.dx = v;\n                y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n              }\n\n              o.z = false;\n              o.dy += rect.y + rect.dy - y;\n              rect.x += v;\n              rect.dx -= v;\n            }\n          }\n\n          function treemap(d) {\n            var nodes = stickies || hierarchy(d),\n                root = nodes[0];\n            root.x = root.y = 0;\n            if (root.value) root.dx = size[0], root.dy = size[1];else root.dx = root.dy = 0;\n            if (stickies) hierarchy.revalue(root);\n            scale([root], root.dx * root.dy / root.value);\n            (stickies ? stickify : squarify)(root);\n            if (sticky) stickies = nodes;\n            return nodes;\n          }\n\n          treemap.size = function (x) {\n            if (!arguments.length) return size;\n            size = x;\n            return treemap;\n          };\n\n          treemap.padding = function (x) {\n            if (!arguments.length) return padding;\n\n            function padFunction(node) {\n              var p = x.call(treemap, node, node.depth);\n              return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \"number\" ? [p, p, p, p] : p);\n            }\n\n            function padConstant(node) {\n              return d3_layout_treemapPad(node, x);\n            }\n\n            var type;\n            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \"function\" ? padFunction : type === \"number\" ? (x = [x, x, x, x], padConstant) : padConstant;\n            return treemap;\n          };\n\n          treemap.round = function (x) {\n            if (!arguments.length) return round != Number;\n            round = x ? Math.round : Number;\n            return treemap;\n          };\n\n          treemap.sticky = function (x) {\n            if (!arguments.length) return sticky;\n            sticky = x;\n            stickies = null;\n            return treemap;\n          };\n\n          treemap.ratio = function (x) {\n            if (!arguments.length) return ratio;\n            ratio = x;\n            return treemap;\n          };\n\n          treemap.mode = function (x) {\n            if (!arguments.length) return mode;\n            mode = x + \"\";\n            return treemap;\n          };\n\n          return d3_layout_hierarchyRebind(treemap, hierarchy);\n        };\n\n        function d3_layout_treemapPadNull(node) {\n          return {\n            x: node.x,\n            y: node.y,\n            dx: node.dx,\n            dy: node.dy\n          };\n        }\n\n        function d3_layout_treemapPad(node, padding) {\n          var x = node.x + padding[3],\n              y = node.y + padding[0],\n              dx = node.dx - padding[1] - padding[3],\n              dy = node.dy - padding[0] - padding[2];\n\n          if (dx < 0) {\n            x += dx / 2;\n            dx = 0;\n          }\n\n          if (dy < 0) {\n            y += dy / 2;\n            dy = 0;\n          }\n\n          return {\n            x: x,\n            y: y,\n            dx: dx,\n            dy: dy\n          };\n        }\n\n        d3.random = {\n          normal: function (µ, σ) {\n            var n = arguments.length;\n            if (n < 2) σ = 1;\n            if (n < 1) µ = 0;\n            return function () {\n              var x, y, r;\n\n              do {\n                x = Math.random() * 2 - 1;\n                y = Math.random() * 2 - 1;\n                r = x * x + y * y;\n              } while (!r || r > 1);\n\n              return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\n            };\n          },\n          logNormal: function () {\n            var random = d3.random.normal.apply(d3, arguments);\n            return function () {\n              return Math.exp(random());\n            };\n          },\n          bates: function (m) {\n            var random = d3.random.irwinHall(m);\n            return function () {\n              return random() / m;\n            };\n          },\n          irwinHall: function (m) {\n            return function () {\n              for (var s = 0, j = 0; j < m; j++) s += Math.random();\n\n              return s;\n            };\n          }\n        };\n        d3.scale = {};\n\n        function d3_scaleExtent(domain) {\n          var start = domain[0],\n              stop = domain[domain.length - 1];\n          return start < stop ? [start, stop] : [stop, start];\n        }\n\n        function d3_scaleRange(scale) {\n          return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n        }\n\n        function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n          var u = uninterpolate(domain[0], domain[1]),\n              i = interpolate(range[0], range[1]);\n          return function (x) {\n            return i(u(x));\n          };\n        }\n\n        function d3_scale_nice(domain, nice) {\n          var i0 = 0,\n              i1 = domain.length - 1,\n              x0 = domain[i0],\n              x1 = domain[i1],\n              dx;\n\n          if (x1 < x0) {\n            dx = i0, i0 = i1, i1 = dx;\n            dx = x0, x0 = x1, x1 = dx;\n          }\n\n          domain[i0] = nice.floor(x0);\n          domain[i1] = nice.ceil(x1);\n          return domain;\n        }\n\n        function d3_scale_niceStep(step) {\n          return step ? {\n            floor: function (x) {\n              return Math.floor(x / step) * step;\n            },\n            ceil: function (x) {\n              return Math.ceil(x / step) * step;\n            }\n          } : d3_scale_niceIdentity;\n        }\n\n        var d3_scale_niceIdentity = {\n          floor: d3_identity,\n          ceil: d3_identity\n        };\n\n        function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n          var u = [],\n              i = [],\n              j = 0,\n              k = Math.min(domain.length, range.length) - 1;\n\n          if (domain[k] < domain[0]) {\n            domain = domain.slice().reverse();\n            range = range.slice().reverse();\n          }\n\n          while (++j <= k) {\n            u.push(uninterpolate(domain[j - 1], domain[j]));\n            i.push(interpolate(range[j - 1], range[j]));\n          }\n\n          return function (x) {\n            var j = d3.bisect(domain, x, 1, k) - 1;\n            return i[j](u[j](x));\n          };\n        }\n\n        d3.scale.linear = function () {\n          return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);\n        };\n\n        function d3_scale_linear(domain, range, interpolate, clamp) {\n          var output, input;\n\n          function rescale() {\n            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,\n                uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n            output = linear(domain, range, uninterpolate, interpolate);\n            input = linear(range, domain, uninterpolate, d3_interpolate);\n            return scale;\n          }\n\n          function scale(x) {\n            return output(x);\n          }\n\n          scale.invert = function (y) {\n            return input(y);\n          };\n\n          scale.domain = function (x) {\n            if (!arguments.length) return domain;\n            domain = x.map(Number);\n            return rescale();\n          };\n\n          scale.range = function (x) {\n            if (!arguments.length) return range;\n            range = x;\n            return rescale();\n          };\n\n          scale.rangeRound = function (x) {\n            return scale.range(x).interpolate(d3_interpolateRound);\n          };\n\n          scale.clamp = function (x) {\n            if (!arguments.length) return clamp;\n            clamp = x;\n            return rescale();\n          };\n\n          scale.interpolate = function (x) {\n            if (!arguments.length) return interpolate;\n            interpolate = x;\n            return rescale();\n          };\n\n          scale.ticks = function (m) {\n            return d3_scale_linearTicks(domain, m);\n          };\n\n          scale.tickFormat = function (m, format) {\n            return d3_scale_linearTickFormat(domain, m, format);\n          };\n\n          scale.nice = function (m) {\n            d3_scale_linearNice(domain, m);\n            return rescale();\n          };\n\n          scale.copy = function () {\n            return d3_scale_linear(domain, range, interpolate, clamp);\n          };\n\n          return rescale();\n        }\n\n        function d3_scale_linearRebind(scale, linear) {\n          return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n        }\n\n        function d3_scale_linearNice(domain, m) {\n          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n          return domain;\n        }\n\n        function d3_scale_linearTickRange(domain, m) {\n          if (m == null) m = 10;\n          var extent = d3_scaleExtent(domain),\n              span = extent[1] - extent[0],\n              step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),\n              err = m / span * step;\n          if (err <= .15) step *= 10;else if (err <= .35) step *= 5;else if (err <= .75) step *= 2;\n          extent[0] = Math.ceil(extent[0] / step) * step;\n          extent[1] = Math.floor(extent[1] / step) * step + step * .5;\n          extent[2] = step;\n          return extent;\n        }\n\n        function d3_scale_linearTicks(domain, m) {\n          return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n        }\n\n        function d3_scale_linearTickFormat(domain, m, format) {\n          var range = d3_scale_linearTickRange(domain, m);\n\n          if (format) {\n            var match = d3_format_re.exec(format);\n            match.shift();\n\n            if (match[8] === \"s\") {\n              var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));\n              if (!match[7]) match[7] = \".\" + d3_scale_linearPrecision(prefix.scale(range[2]));\n              match[8] = \"f\";\n              format = d3.format(match.join(\"\"));\n              return function (d) {\n                return format(prefix.scale(d)) + prefix.symbol;\n              };\n            }\n\n            if (!match[7]) match[7] = \".\" + d3_scale_linearFormatPrecision(match[8], range);\n            format = match.join(\"\");\n          } else {\n            format = \",.\" + d3_scale_linearPrecision(range[2]) + \"f\";\n          }\n\n          return d3.format(format);\n        }\n\n        var d3_scale_linearFormatSignificant = {\n          s: 1,\n          g: 1,\n          p: 1,\n          r: 1,\n          e: 1\n        };\n\n        function d3_scale_linearPrecision(value) {\n          return -Math.floor(Math.log(value) / Math.LN10 + .01);\n        }\n\n        function d3_scale_linearFormatPrecision(type, range) {\n          var p = d3_scale_linearPrecision(range[2]);\n          return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== \"e\") : p - (type === \"%\") * 2;\n        }\n\n        d3.scale.log = function () {\n          return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);\n        };\n\n        function d3_scale_log(linear, base, positive, domain) {\n          function log(x) {\n            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);\n          }\n\n          function pow(x) {\n            return positive ? Math.pow(base, x) : -Math.pow(base, -x);\n          }\n\n          function scale(x) {\n            return linear(log(x));\n          }\n\n          scale.invert = function (x) {\n            return pow(linear.invert(x));\n          };\n\n          scale.domain = function (x) {\n            if (!arguments.length) return domain;\n            positive = x[0] >= 0;\n            linear.domain((domain = x.map(Number)).map(log));\n            return scale;\n          };\n\n          scale.base = function (_) {\n            if (!arguments.length) return base;\n            base = +_;\n            linear.domain(domain.map(log));\n            return scale;\n          };\n\n          scale.nice = function () {\n            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);\n            linear.domain(niced);\n            domain = niced.map(pow);\n            return scale;\n          };\n\n          scale.ticks = function () {\n            var extent = d3_scaleExtent(domain),\n                ticks = [],\n                u = extent[0],\n                v = extent[1],\n                i = Math.floor(log(u)),\n                j = Math.ceil(log(v)),\n                n = base % 1 ? 2 : base;\n\n            if (isFinite(j - i)) {\n              if (positive) {\n                for (; i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);\n\n                ticks.push(pow(i));\n              } else {\n                ticks.push(pow(i));\n\n                for (; i++ < j;) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);\n              }\n\n              for (i = 0; ticks[i] < u; i++) {}\n\n              for (j = ticks.length; ticks[j - 1] > v; j--) {}\n\n              ticks = ticks.slice(i, j);\n            }\n\n            return ticks;\n          };\n\n          scale.tickFormat = function (n, format) {\n            if (!arguments.length) return d3_scale_logFormat;\n            if (arguments.length < 2) format = d3_scale_logFormat;else if (typeof format !== \"function\") format = d3.format(format);\n            var k = Math.max(1, base * n / scale.ticks().length);\n            return function (d) {\n              var i = d / pow(Math.round(log(d)));\n              if (i * base < base - .5) i *= base;\n              return i <= k ? format(d) : \"\";\n            };\n          };\n\n          scale.copy = function () {\n            return d3_scale_log(linear.copy(), base, positive, domain);\n          };\n\n          return d3_scale_linearRebind(scale, linear);\n        }\n\n        var d3_scale_logFormat = d3.format(\".0e\"),\n            d3_scale_logNiceNegative = {\n          floor: function (x) {\n            return -Math.ceil(-x);\n          },\n          ceil: function (x) {\n            return -Math.floor(-x);\n          }\n        };\n\n        d3.scale.pow = function () {\n          return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);\n        };\n\n        function d3_scale_pow(linear, exponent, domain) {\n          var powp = d3_scale_powPow(exponent),\n              powb = d3_scale_powPow(1 / exponent);\n\n          function scale(x) {\n            return linear(powp(x));\n          }\n\n          scale.invert = function (x) {\n            return powb(linear.invert(x));\n          };\n\n          scale.domain = function (x) {\n            if (!arguments.length) return domain;\n            linear.domain((domain = x.map(Number)).map(powp));\n            return scale;\n          };\n\n          scale.ticks = function (m) {\n            return d3_scale_linearTicks(domain, m);\n          };\n\n          scale.tickFormat = function (m, format) {\n            return d3_scale_linearTickFormat(domain, m, format);\n          };\n\n          scale.nice = function (m) {\n            return scale.domain(d3_scale_linearNice(domain, m));\n          };\n\n          scale.exponent = function (x) {\n            if (!arguments.length) return exponent;\n            powp = d3_scale_powPow(exponent = x);\n            powb = d3_scale_powPow(1 / exponent);\n            linear.domain(domain.map(powp));\n            return scale;\n          };\n\n          scale.copy = function () {\n            return d3_scale_pow(linear.copy(), exponent, domain);\n          };\n\n          return d3_scale_linearRebind(scale, linear);\n        }\n\n        function d3_scale_powPow(e) {\n          return function (x) {\n            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n          };\n        }\n\n        d3.scale.sqrt = function () {\n          return d3.scale.pow().exponent(.5);\n        };\n\n        d3.scale.ordinal = function () {\n          return d3_scale_ordinal([], {\n            t: \"range\",\n            a: [[]]\n          });\n        };\n\n        function d3_scale_ordinal(domain, ranger) {\n          var index, range, rangeBand;\n\n          function scale(x) {\n            return range[((index.get(x) || (ranger.t === \"range\" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];\n          }\n\n          function steps(start, step) {\n            return d3.range(domain.length).map(function (i) {\n              return start + step * i;\n            });\n          }\n\n          scale.domain = function (x) {\n            if (!arguments.length) return domain;\n            domain = [];\n            index = new d3_Map();\n            var i = -1,\n                n = x.length,\n                xi;\n\n            while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n\n            return scale[ranger.t].apply(scale, ranger.a);\n          };\n\n          scale.range = function (x) {\n            if (!arguments.length) return range;\n            range = x;\n            rangeBand = 0;\n            ranger = {\n              t: \"range\",\n              a: arguments\n            };\n            return scale;\n          };\n\n          scale.rangePoints = function (x, padding) {\n            if (arguments.length < 2) padding = 0;\n            var start = x[0],\n                stop = x[1],\n                step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);\n            range = steps(start + step * padding / 2, step);\n            rangeBand = 0;\n            ranger = {\n              t: \"rangePoints\",\n              a: arguments\n            };\n            return scale;\n          };\n\n          scale.rangeRoundPoints = function (x, padding) {\n            if (arguments.length < 2) padding = 0;\n            var start = x[0],\n                stop = x[1],\n                step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;\n            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);\n            rangeBand = 0;\n            ranger = {\n              t: \"rangeRoundPoints\",\n              a: arguments\n            };\n            return scale;\n          };\n\n          scale.rangeBands = function (x, padding, outerPadding) {\n            if (arguments.length < 2) padding = 0;\n            if (arguments.length < 3) outerPadding = padding;\n            var reverse = x[1] < x[0],\n                start = x[reverse - 0],\n                stop = x[1 - reverse],\n                step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n            range = steps(start + step * outerPadding, step);\n            if (reverse) range.reverse();\n            rangeBand = step * (1 - padding);\n            ranger = {\n              t: \"rangeBands\",\n              a: arguments\n            };\n            return scale;\n          };\n\n          scale.rangeRoundBands = function (x, padding, outerPadding) {\n            if (arguments.length < 2) padding = 0;\n            if (arguments.length < 3) outerPadding = padding;\n            var reverse = x[1] < x[0],\n                start = x[reverse - 0],\n                stop = x[1 - reverse],\n                step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));\n            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);\n            if (reverse) range.reverse();\n            rangeBand = Math.round(step * (1 - padding));\n            ranger = {\n              t: \"rangeRoundBands\",\n              a: arguments\n            };\n            return scale;\n          };\n\n          scale.rangeBand = function () {\n            return rangeBand;\n          };\n\n          scale.rangeExtent = function () {\n            return d3_scaleExtent(ranger.a[0]);\n          };\n\n          scale.copy = function () {\n            return d3_scale_ordinal(domain, ranger);\n          };\n\n          return scale.domain(domain);\n        }\n\n        d3.scale.category10 = function () {\n          return d3.scale.ordinal().range(d3_category10);\n        };\n\n        d3.scale.category20 = function () {\n          return d3.scale.ordinal().range(d3_category20);\n        };\n\n        d3.scale.category20b = function () {\n          return d3.scale.ordinal().range(d3_category20b);\n        };\n\n        d3.scale.category20c = function () {\n          return d3.scale.ordinal().range(d3_category20c);\n        };\n\n        var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);\n        var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);\n        var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);\n        var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);\n\n        d3.scale.quantile = function () {\n          return d3_scale_quantile([], []);\n        };\n\n        function d3_scale_quantile(domain, range) {\n          var thresholds;\n\n          function rescale() {\n            var k = 0,\n                q = range.length;\n            thresholds = [];\n\n            while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n\n            return scale;\n          }\n\n          function scale(x) {\n            if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];\n          }\n\n          scale.domain = function (x) {\n            if (!arguments.length) return domain;\n            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);\n            return rescale();\n          };\n\n          scale.range = function (x) {\n            if (!arguments.length) return range;\n            range = x;\n            return rescale();\n          };\n\n          scale.quantiles = function () {\n            return thresholds;\n          };\n\n          scale.invertExtent = function (y) {\n            y = range.indexOf(y);\n            return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];\n          };\n\n          scale.copy = function () {\n            return d3_scale_quantile(domain, range);\n          };\n\n          return rescale();\n        }\n\n        d3.scale.quantize = function () {\n          return d3_scale_quantize(0, 1, [0, 1]);\n        };\n\n        function d3_scale_quantize(x0, x1, range) {\n          var kx, i;\n\n          function scale(x) {\n            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n          }\n\n          function rescale() {\n            kx = range.length / (x1 - x0);\n            i = range.length - 1;\n            return scale;\n          }\n\n          scale.domain = function (x) {\n            if (!arguments.length) return [x0, x1];\n            x0 = +x[0];\n            x1 = +x[x.length - 1];\n            return rescale();\n          };\n\n          scale.range = function (x) {\n            if (!arguments.length) return range;\n            range = x;\n            return rescale();\n          };\n\n          scale.invertExtent = function (y) {\n            y = range.indexOf(y);\n            y = y < 0 ? NaN : y / kx + x0;\n            return [y, y + 1 / kx];\n          };\n\n          scale.copy = function () {\n            return d3_scale_quantize(x0, x1, range);\n          };\n\n          return rescale();\n        }\n\n        d3.scale.threshold = function () {\n          return d3_scale_threshold([.5], [0, 1]);\n        };\n\n        function d3_scale_threshold(domain, range) {\n          function scale(x) {\n            if (x <= x) return range[d3.bisect(domain, x)];\n          }\n\n          scale.domain = function (_) {\n            if (!arguments.length) return domain;\n            domain = _;\n            return scale;\n          };\n\n          scale.range = function (_) {\n            if (!arguments.length) return range;\n            range = _;\n            return scale;\n          };\n\n          scale.invertExtent = function (y) {\n            y = range.indexOf(y);\n            return [domain[y - 1], domain[y]];\n          };\n\n          scale.copy = function () {\n            return d3_scale_threshold(domain, range);\n          };\n\n          return scale;\n        }\n\n        d3.scale.identity = function () {\n          return d3_scale_identity([0, 1]);\n        };\n\n        function d3_scale_identity(domain) {\n          function identity(x) {\n            return +x;\n          }\n\n          identity.invert = identity;\n\n          identity.domain = identity.range = function (x) {\n            if (!arguments.length) return domain;\n            domain = x.map(identity);\n            return identity;\n          };\n\n          identity.ticks = function (m) {\n            return d3_scale_linearTicks(domain, m);\n          };\n\n          identity.tickFormat = function (m, format) {\n            return d3_scale_linearTickFormat(domain, m, format);\n          };\n\n          identity.copy = function () {\n            return d3_scale_identity(domain);\n          };\n\n          return identity;\n        }\n\n        d3.svg = {};\n\n        function d3_zero() {\n          return 0;\n        }\n\n        d3.svg.arc = function () {\n          var innerRadius = d3_svg_arcInnerRadius,\n              outerRadius = d3_svg_arcOuterRadius,\n              cornerRadius = d3_zero,\n              padRadius = d3_svg_arcAuto,\n              startAngle = d3_svg_arcStartAngle,\n              endAngle = d3_svg_arcEndAngle,\n              padAngle = d3_svg_arcPadAngle;\n\n          function arc() {\n            var r0 = Math.max(0, +innerRadius.apply(this, arguments)),\n                r1 = Math.max(0, +outerRadius.apply(this, arguments)),\n                a0 = startAngle.apply(this, arguments) - halfπ,\n                a1 = endAngle.apply(this, arguments) - halfπ,\n                da = Math.abs(a1 - a0),\n                cw = a0 > a1 ? 0 : 1;\n            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;\n            if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : \"\") + \"Z\";\n            var rc,\n                cr,\n                rp,\n                ap,\n                p0 = 0,\n                p1 = 0,\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2,\n                x3,\n                y3,\n                path = [];\n\n            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {\n              rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);\n              if (!cw) p1 *= -1;\n              if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));\n              if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));\n            }\n\n            if (r1) {\n              x0 = r1 * Math.cos(a0 + p1);\n              y0 = r1 * Math.sin(a0 + p1);\n              x1 = r1 * Math.cos(a1 - p1);\n              y1 = r1 * Math.sin(a1 - p1);\n              var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;\n\n              if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {\n                var h1 = (a0 + a1) / 2;\n                x0 = r1 * Math.cos(h1);\n                y0 = r1 * Math.sin(h1);\n                x1 = y1 = null;\n              }\n            } else {\n              x0 = y0 = 0;\n            }\n\n            if (r0) {\n              x2 = r0 * Math.cos(a1 - p0);\n              y2 = r0 * Math.sin(a1 - p0);\n              x3 = r0 * Math.cos(a0 + p0);\n              y3 = r0 * Math.sin(a0 + p0);\n              var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;\n\n              if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {\n                var h0 = (a0 + a1) / 2;\n                x2 = r0 * Math.cos(h0);\n                y2 = r0 * Math.sin(h0);\n                x3 = y3 = null;\n              }\n            } else {\n              x2 = y2 = 0;\n            }\n\n            if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {\n              cr = r0 < r1 ^ cw ? 0 : 1;\n              var rc1 = rc,\n                  rc0 = rc;\n\n              if (da < π) {\n                var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]),\n                    ax = x0 - oc[0],\n                    ay = y0 - oc[1],\n                    bx = x1 - oc[0],\n                    by = y1 - oc[1],\n                    kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),\n                    lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n                rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n                rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n              }\n\n              if (x1 != null) {\n                var t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw),\n                    t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);\n\n                if (rc === rc1) {\n                  path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t30[1], \"A\", r1, \",\", r1, \" 0 \", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), \",\", cw, \" \", t12[1], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t12[0]);\n                } else {\n                  path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 1,\", cr, \" \", t12[0]);\n                }\n              } else {\n                path.push(\"M\", x0, \",\", y0);\n              }\n\n              if (x3 != null) {\n                var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw),\n                    t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);\n\n                if (rc === rc0) {\n                  path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t21[1], \"A\", r0, \",\", r0, \" 0 \", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), \",\", 1 - cw, \" \", t03[1], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n                } else {\n                  path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n                }\n              } else {\n                path.push(\"L\", x2, \",\", y2);\n              }\n            } else {\n              path.push(\"M\", x0, \",\", y0);\n              if (x1 != null) path.push(\"A\", r1, \",\", r1, \" 0 \", l1, \",\", cw, \" \", x1, \",\", y1);\n              path.push(\"L\", x2, \",\", y2);\n              if (x3 != null) path.push(\"A\", r0, \",\", r0, \" 0 \", l0, \",\", 1 - cw, \" \", x3, \",\", y3);\n            }\n\n            path.push(\"Z\");\n            return path.join(\"\");\n          }\n\n          function circleSegment(r1, cw) {\n            return \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + r1;\n          }\n\n          arc.innerRadius = function (v) {\n            if (!arguments.length) return innerRadius;\n            innerRadius = d3_functor(v);\n            return arc;\n          };\n\n          arc.outerRadius = function (v) {\n            if (!arguments.length) return outerRadius;\n            outerRadius = d3_functor(v);\n            return arc;\n          };\n\n          arc.cornerRadius = function (v) {\n            if (!arguments.length) return cornerRadius;\n            cornerRadius = d3_functor(v);\n            return arc;\n          };\n\n          arc.padRadius = function (v) {\n            if (!arguments.length) return padRadius;\n            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);\n            return arc;\n          };\n\n          arc.startAngle = function (v) {\n            if (!arguments.length) return startAngle;\n            startAngle = d3_functor(v);\n            return arc;\n          };\n\n          arc.endAngle = function (v) {\n            if (!arguments.length) return endAngle;\n            endAngle = d3_functor(v);\n            return arc;\n          };\n\n          arc.padAngle = function (v) {\n            if (!arguments.length) return padAngle;\n            padAngle = d3_functor(v);\n            return arc;\n          };\n\n          arc.centroid = function () {\n            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n                a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;\n            return [Math.cos(a) * r, Math.sin(a) * r];\n          };\n\n          return arc;\n        };\n\n        var d3_svg_arcAuto = \"auto\";\n\n        function d3_svg_arcInnerRadius(d) {\n          return d.innerRadius;\n        }\n\n        function d3_svg_arcOuterRadius(d) {\n          return d.outerRadius;\n        }\n\n        function d3_svg_arcStartAngle(d) {\n          return d.startAngle;\n        }\n\n        function d3_svg_arcEndAngle(d) {\n          return d.endAngle;\n        }\n\n        function d3_svg_arcPadAngle(d) {\n          return d && d.padAngle;\n        }\n\n        function d3_svg_arcSweep(x0, y0, x1, y1) {\n          return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;\n        }\n\n        function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {\n          var x01 = p0[0] - p1[0],\n              y01 = p0[1] - p1[1],\n              lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),\n              ox = lo * y01,\n              oy = -lo * x01,\n              x1 = p0[0] + ox,\n              y1 = p0[1] + oy,\n              x2 = p1[0] + ox,\n              y2 = p1[1] + oy,\n              x3 = (x1 + x2) / 2,\n              y3 = (y1 + y2) / 2,\n              dx = x2 - x1,\n              dy = y2 - y1,\n              d2 = dx * dx + dy * dy,\n              r = r1 - rc,\n              D = x1 * y2 - x2 * y1,\n              d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),\n              cx0 = (D * dy - dx * d) / d2,\n              cy0 = (-D * dx - dy * d) / d2,\n              cx1 = (D * dy + dx * d) / d2,\n              cy1 = (-D * dx + dy * d) / d2,\n              dx0 = cx0 - x3,\n              dy0 = cy0 - y3,\n              dx1 = cx1 - x3,\n              dy1 = cy1 - y3;\n          if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n          return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];\n        }\n\n        function d3_svg_line(projection) {\n          var x = d3_geom_pointX,\n              y = d3_geom_pointY,\n              defined = d3_true,\n              interpolate = d3_svg_lineLinear,\n              interpolateKey = interpolate.key,\n              tension = .7;\n\n          function line(data) {\n            var segments = [],\n                points = [],\n                i = -1,\n                n = data.length,\n                d,\n                fx = d3_functor(x),\n                fy = d3_functor(y);\n\n            function segment() {\n              segments.push(\"M\", interpolate(projection(points), tension));\n            }\n\n            while (++i < n) {\n              if (defined.call(this, d = data[i], i)) {\n                points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);\n              } else if (points.length) {\n                segment();\n                points = [];\n              }\n            }\n\n            if (points.length) segment();\n            return segments.length ? segments.join(\"\") : null;\n          }\n\n          line.x = function (_) {\n            if (!arguments.length) return x;\n            x = _;\n            return line;\n          };\n\n          line.y = function (_) {\n            if (!arguments.length) return y;\n            y = _;\n            return line;\n          };\n\n          line.defined = function (_) {\n            if (!arguments.length) return defined;\n            defined = _;\n            return line;\n          };\n\n          line.interpolate = function (_) {\n            if (!arguments.length) return interpolateKey;\n            if (typeof _ === \"function\") interpolateKey = interpolate = _;else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n            return line;\n          };\n\n          line.tension = function (_) {\n            if (!arguments.length) return tension;\n            tension = _;\n            return line;\n          };\n\n          return line;\n        }\n\n        d3.svg.line = function () {\n          return d3_svg_line(d3_identity);\n        };\n\n        var d3_svg_lineInterpolators = d3.map({\n          linear: d3_svg_lineLinear,\n          \"linear-closed\": d3_svg_lineLinearClosed,\n          step: d3_svg_lineStep,\n          \"step-before\": d3_svg_lineStepBefore,\n          \"step-after\": d3_svg_lineStepAfter,\n          basis: d3_svg_lineBasis,\n          \"basis-open\": d3_svg_lineBasisOpen,\n          \"basis-closed\": d3_svg_lineBasisClosed,\n          bundle: d3_svg_lineBundle,\n          cardinal: d3_svg_lineCardinal,\n          \"cardinal-open\": d3_svg_lineCardinalOpen,\n          \"cardinal-closed\": d3_svg_lineCardinalClosed,\n          monotone: d3_svg_lineMonotone\n        });\n        d3_svg_lineInterpolators.forEach(function (key, value) {\n          value.key = key;\n          value.closed = /-closed$/.test(key);\n        });\n\n        function d3_svg_lineLinear(points) {\n          return points.length > 1 ? points.join(\"L\") : points + \"Z\";\n        }\n\n        function d3_svg_lineLinearClosed(points) {\n          return points.join(\"L\") + \"Z\";\n        }\n\n        function d3_svg_lineStep(points) {\n          var i = 0,\n              n = points.length,\n              p = points[0],\n              path = [p[0], \",\", p[1]];\n\n          while (++i < n) path.push(\"H\", (p[0] + (p = points[i])[0]) / 2, \"V\", p[1]);\n\n          if (n > 1) path.push(\"H\", p[0]);\n          return path.join(\"\");\n        }\n\n        function d3_svg_lineStepBefore(points) {\n          var i = 0,\n              n = points.length,\n              p = points[0],\n              path = [p[0], \",\", p[1]];\n\n          while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n\n          return path.join(\"\");\n        }\n\n        function d3_svg_lineStepAfter(points) {\n          var i = 0,\n              n = points.length,\n              p = points[0],\n              path = [p[0], \",\", p[1]];\n\n          while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n\n          return path.join(\"\");\n        }\n\n        function d3_svg_lineCardinalOpen(points, tension) {\n          return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));\n        }\n\n        function d3_svg_lineCardinalClosed(points, tension) {\n          return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));\n        }\n\n        function d3_svg_lineCardinal(points, tension) {\n          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\n        }\n\n        function d3_svg_lineHermite(points, tangents) {\n          if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\n            return d3_svg_lineLinear(points);\n          }\n\n          var quad = points.length != tangents.length,\n              path = \"\",\n              p0 = points[0],\n              p = points[1],\n              t0 = tangents[0],\n              t = t0,\n              pi = 1;\n\n          if (quad) {\n            path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3) + \",\" + p[0] + \",\" + p[1];\n            p0 = points[1];\n            pi = 2;\n          }\n\n          if (tangents.length > 1) {\n            t = tangents[1];\n            p = points[pi];\n            pi++;\n            path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1]) + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n\n            for (var i = 2; i < tangents.length; i++, pi++) {\n              p = points[pi];\n              t = tangents[i];\n              path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n            }\n          }\n\n          if (quad) {\n            var lp = points[pi];\n            path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3) + \",\" + lp[0] + \",\" + lp[1];\n          }\n\n          return path;\n        }\n\n        function d3_svg_lineCardinalTangents(points, tension) {\n          var tangents = [],\n              a = (1 - tension) / 2,\n              p0,\n              p1 = points[0],\n              p2 = points[1],\n              i = 1,\n              n = points.length;\n\n          while (++i < n) {\n            p0 = p1;\n            p1 = p2;\n            p2 = points[i];\n            tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);\n          }\n\n          return tangents;\n        }\n\n        function d3_svg_lineBasis(points) {\n          if (points.length < 3) return d3_svg_lineLinear(points);\n          var i = 1,\n              n = points.length,\n              pi = points[0],\n              x0 = pi[0],\n              y0 = pi[1],\n              px = [x0, x0, x0, (pi = points[1])[0]],\n              py = [y0, y0, y0, pi[1]],\n              path = [x0, \",\", y0, \"L\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];\n          points.push(points[n - 1]);\n\n          while (++i <= n) {\n            pi = points[i];\n            px.shift();\n            px.push(pi[0]);\n            py.shift();\n            py.push(pi[1]);\n            d3_svg_lineBasisBezier(path, px, py);\n          }\n\n          points.pop();\n          path.push(\"L\", pi);\n          return path.join(\"\");\n        }\n\n        function d3_svg_lineBasisOpen(points) {\n          if (points.length < 4) return d3_svg_lineLinear(points);\n          var path = [],\n              i = -1,\n              n = points.length,\n              pi,\n              px = [0],\n              py = [0];\n\n          while (++i < 3) {\n            pi = points[i];\n            px.push(pi[0]);\n            py.push(pi[1]);\n          }\n\n          path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n          --i;\n\n          while (++i < n) {\n            pi = points[i];\n            px.shift();\n            px.push(pi[0]);\n            py.shift();\n            py.push(pi[1]);\n            d3_svg_lineBasisBezier(path, px, py);\n          }\n\n          return path.join(\"\");\n        }\n\n        function d3_svg_lineBasisClosed(points) {\n          var path,\n              i = -1,\n              n = points.length,\n              m = n + 4,\n              pi,\n              px = [],\n              py = [];\n\n          while (++i < 4) {\n            pi = points[i % n];\n            px.push(pi[0]);\n            py.push(pi[1]);\n          }\n\n          path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];\n          --i;\n\n          while (++i < m) {\n            pi = points[i % n];\n            px.shift();\n            px.push(pi[0]);\n            py.shift();\n            py.push(pi[1]);\n            d3_svg_lineBasisBezier(path, px, py);\n          }\n\n          return path.join(\"\");\n        }\n\n        function d3_svg_lineBundle(points, tension) {\n          var n = points.length - 1;\n\n          if (n) {\n            var x0 = points[0][0],\n                y0 = points[0][1],\n                dx = points[n][0] - x0,\n                dy = points[n][1] - y0,\n                i = -1,\n                p,\n                t;\n\n            while (++i <= n) {\n              p = points[i];\n              t = i / n;\n              p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n              p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n            }\n          }\n\n          return d3_svg_lineBasis(points);\n        }\n\n        function d3_svg_lineDot4(a, b) {\n          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n        }\n\n        var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],\n            d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],\n            d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];\n\n        function d3_svg_lineBasisBezier(path, x, y) {\n          path.push(\"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n        }\n\n        function d3_svg_lineSlope(p0, p1) {\n          return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n        }\n\n        function d3_svg_lineFiniteDifferences(points) {\n          var i = 0,\n              j = points.length - 1,\n              m = [],\n              p0 = points[0],\n              p1 = points[1],\n              d = m[0] = d3_svg_lineSlope(p0, p1);\n\n          while (++i < j) {\n            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n          }\n\n          m[i] = d;\n          return m;\n        }\n\n        function d3_svg_lineMonotoneTangents(points) {\n          var tangents = [],\n              d,\n              a,\n              b,\n              s,\n              m = d3_svg_lineFiniteDifferences(points),\n              i = -1,\n              j = points.length - 1;\n\n          while (++i < j) {\n            d = d3_svg_lineSlope(points[i], points[i + 1]);\n\n            if (abs(d) < ε) {\n              m[i] = m[i + 1] = 0;\n            } else {\n              a = m[i] / d;\n              b = m[i + 1] / d;\n              s = a * a + b * b;\n\n              if (s > 9) {\n                s = d * 3 / Math.sqrt(s);\n                m[i] = s * a;\n                m[i + 1] = s * b;\n              }\n            }\n          }\n\n          i = -1;\n\n          while (++i <= j) {\n            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n            tangents.push([s || 0, m[i] * s || 0]);\n          }\n\n          return tangents;\n        }\n\n        function d3_svg_lineMonotone(points) {\n          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n        }\n\n        d3.svg.line.radial = function () {\n          var line = d3_svg_line(d3_svg_lineRadial);\n          line.radius = line.x, delete line.x;\n          line.angle = line.y, delete line.y;\n          return line;\n        };\n\n        function d3_svg_lineRadial(points) {\n          var point,\n              i = -1,\n              n = points.length,\n              r,\n              a;\n\n          while (++i < n) {\n            point = points[i];\n            r = point[0];\n            a = point[1] - halfπ;\n            point[0] = r * Math.cos(a);\n            point[1] = r * Math.sin(a);\n          }\n\n          return points;\n        }\n\n        function d3_svg_area(projection) {\n          var x0 = d3_geom_pointX,\n              x1 = d3_geom_pointX,\n              y0 = 0,\n              y1 = d3_geom_pointY,\n              defined = d3_true,\n              interpolate = d3_svg_lineLinear,\n              interpolateKey = interpolate.key,\n              interpolateReverse = interpolate,\n              L = \"L\",\n              tension = .7;\n\n          function area(data) {\n            var segments = [],\n                points0 = [],\n                points1 = [],\n                i = -1,\n                n = data.length,\n                d,\n                fx0 = d3_functor(x0),\n                fy0 = d3_functor(y0),\n                fx1 = x0 === x1 ? function () {\n              return x;\n            } : d3_functor(x1),\n                fy1 = y0 === y1 ? function () {\n              return y;\n            } : d3_functor(y1),\n                x,\n                y;\n\n            function segment() {\n              segments.push(\"M\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \"Z\");\n            }\n\n            while (++i < n) {\n              if (defined.call(this, d = data[i], i)) {\n                points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);\n                points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);\n              } else if (points0.length) {\n                segment();\n                points0 = [];\n                points1 = [];\n              }\n            }\n\n            if (points0.length) segment();\n            return segments.length ? segments.join(\"\") : null;\n          }\n\n          area.x = function (_) {\n            if (!arguments.length) return x1;\n            x0 = x1 = _;\n            return area;\n          };\n\n          area.x0 = function (_) {\n            if (!arguments.length) return x0;\n            x0 = _;\n            return area;\n          };\n\n          area.x1 = function (_) {\n            if (!arguments.length) return x1;\n            x1 = _;\n            return area;\n          };\n\n          area.y = function (_) {\n            if (!arguments.length) return y1;\n            y0 = y1 = _;\n            return area;\n          };\n\n          area.y0 = function (_) {\n            if (!arguments.length) return y0;\n            y0 = _;\n            return area;\n          };\n\n          area.y1 = function (_) {\n            if (!arguments.length) return y1;\n            y1 = _;\n            return area;\n          };\n\n          area.defined = function (_) {\n            if (!arguments.length) return defined;\n            defined = _;\n            return area;\n          };\n\n          area.interpolate = function (_) {\n            if (!arguments.length) return interpolateKey;\n            if (typeof _ === \"function\") interpolateKey = interpolate = _;else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n            interpolateReverse = interpolate.reverse || interpolate;\n            L = interpolate.closed ? \"M\" : \"L\";\n            return area;\n          };\n\n          area.tension = function (_) {\n            if (!arguments.length) return tension;\n            tension = _;\n            return area;\n          };\n\n          return area;\n        }\n\n        d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n        d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n\n        d3.svg.area = function () {\n          return d3_svg_area(d3_identity);\n        };\n\n        d3.svg.area.radial = function () {\n          var area = d3_svg_area(d3_svg_lineRadial);\n          area.radius = area.x, delete area.x;\n          area.innerRadius = area.x0, delete area.x0;\n          area.outerRadius = area.x1, delete area.x1;\n          area.angle = area.y, delete area.y;\n          area.startAngle = area.y0, delete area.y0;\n          area.endAngle = area.y1, delete area.y1;\n          return area;\n        };\n\n        d3.svg.chord = function () {\n          var source = d3_source,\n              target = d3_target,\n              radius = d3_svg_chordRadius,\n              startAngle = d3_svg_arcStartAngle,\n              endAngle = d3_svg_arcEndAngle;\n\n          function chord(d, i) {\n            var s = subgroup(this, source, d, i),\n                t = subgroup(this, target, d, i);\n            return \"M\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \"Z\";\n          }\n\n          function subgroup(self, f, d, i) {\n            var subgroup = f.call(self, d, i),\n                r = radius.call(self, subgroup, i),\n                a0 = startAngle.call(self, subgroup, i) - halfπ,\n                a1 = endAngle.call(self, subgroup, i) - halfπ;\n            return {\n              r: r,\n              a0: a0,\n              a1: a1,\n              p0: [r * Math.cos(a0), r * Math.sin(a0)],\n              p1: [r * Math.cos(a1), r * Math.sin(a1)]\n            };\n          }\n\n          function equals(a, b) {\n            return a.a0 == b.a0 && a.a1 == b.a1;\n          }\n\n          function arc(r, p, a) {\n            return \"A\" + r + \",\" + r + \" 0 \" + +(a > π) + \",1 \" + p;\n          }\n\n          function curve(r0, p0, r1, p1) {\n            return \"Q 0,0 \" + p1;\n          }\n\n          chord.radius = function (v) {\n            if (!arguments.length) return radius;\n            radius = d3_functor(v);\n            return chord;\n          };\n\n          chord.source = function (v) {\n            if (!arguments.length) return source;\n            source = d3_functor(v);\n            return chord;\n          };\n\n          chord.target = function (v) {\n            if (!arguments.length) return target;\n            target = d3_functor(v);\n            return chord;\n          };\n\n          chord.startAngle = function (v) {\n            if (!arguments.length) return startAngle;\n            startAngle = d3_functor(v);\n            return chord;\n          };\n\n          chord.endAngle = function (v) {\n            if (!arguments.length) return endAngle;\n            endAngle = d3_functor(v);\n            return chord;\n          };\n\n          return chord;\n        };\n\n        function d3_svg_chordRadius(d) {\n          return d.radius;\n        }\n\n        d3.svg.diagonal = function () {\n          var source = d3_source,\n              target = d3_target,\n              projection = d3_svg_diagonalProjection;\n\n          function diagonal(d, i) {\n            var p0 = source.call(this, d, i),\n                p3 = target.call(this, d, i),\n                m = (p0.y + p3.y) / 2,\n                p = [p0, {\n              x: p0.x,\n              y: m\n            }, {\n              x: p3.x,\n              y: m\n            }, p3];\n            p = p.map(projection);\n            return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n          }\n\n          diagonal.source = function (x) {\n            if (!arguments.length) return source;\n            source = d3_functor(x);\n            return diagonal;\n          };\n\n          diagonal.target = function (x) {\n            if (!arguments.length) return target;\n            target = d3_functor(x);\n            return diagonal;\n          };\n\n          diagonal.projection = function (x) {\n            if (!arguments.length) return projection;\n            projection = x;\n            return diagonal;\n          };\n\n          return diagonal;\n        };\n\n        function d3_svg_diagonalProjection(d) {\n          return [d.x, d.y];\n        }\n\n        d3.svg.diagonal.radial = function () {\n          var diagonal = d3.svg.diagonal(),\n              projection = d3_svg_diagonalProjection,\n              projection_ = diagonal.projection;\n\n          diagonal.projection = function (x) {\n            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\n          };\n\n          return diagonal;\n        };\n\n        function d3_svg_diagonalRadialProjection(projection) {\n          return function () {\n            var d = projection.apply(this, arguments),\n                r = d[0],\n                a = d[1] - halfπ;\n            return [r * Math.cos(a), r * Math.sin(a)];\n          };\n        }\n\n        d3.svg.symbol = function () {\n          var type = d3_svg_symbolType,\n              size = d3_svg_symbolSize;\n\n          function symbol(d, i) {\n            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\n          }\n\n          symbol.type = function (x) {\n            if (!arguments.length) return type;\n            type = d3_functor(x);\n            return symbol;\n          };\n\n          symbol.size = function (x) {\n            if (!arguments.length) return size;\n            size = d3_functor(x);\n            return symbol;\n          };\n\n          return symbol;\n        };\n\n        function d3_svg_symbolSize() {\n          return 64;\n        }\n\n        function d3_svg_symbolType() {\n          return \"circle\";\n        }\n\n        function d3_svg_symbolCircle(size) {\n          var r = Math.sqrt(size / π);\n          return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + -r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n        }\n\n        var d3_svg_symbols = d3.map({\n          circle: d3_svg_symbolCircle,\n          cross: function (size) {\n            var r = Math.sqrt(size / 5) / 2;\n            return \"M\" + -3 * r + \",\" + -r + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n          },\n          diamond: function (size) {\n            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),\n                rx = ry * d3_svg_symbolTan30;\n            return \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\";\n          },\n          square: function (size) {\n            var r = Math.sqrt(size) / 2;\n            return \"M\" + -r + \",\" + -r + \"L\" + r + \",\" + -r + \" \" + r + \",\" + r + \" \" + -r + \",\" + r + \"Z\";\n          },\n          \"triangle-down\": function (size) {\n            var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n                ry = rx * d3_svg_symbolSqrt3 / 2;\n            return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\n          },\n          \"triangle-up\": function (size) {\n            var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n                ry = rx * d3_svg_symbolSqrt3 / 2;\n            return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\n          }\n        });\n        d3.svg.symbolTypes = d3_svg_symbols.keys();\n        var d3_svg_symbolSqrt3 = Math.sqrt(3),\n            d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\n\n        d3_selectionPrototype.transition = function (name) {\n          var id = d3_transitionInheritId || ++d3_transitionId,\n              ns = d3_transitionNamespace(name),\n              subgroups = [],\n              subgroup,\n              node,\n              transition = d3_transitionInherit || {\n            time: Date.now(),\n            ease: d3_ease_cubicInOut,\n            delay: 0,\n            duration: 250\n          };\n\n          for (var j = -1, m = this.length; ++j < m;) {\n            subgroups.push(subgroup = []);\n\n            for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n              if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);\n              subgroup.push(node);\n            }\n          }\n\n          return d3_transition(subgroups, ns, id);\n        };\n\n        d3_selectionPrototype.interrupt = function (name) {\n          return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));\n        };\n\n        var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());\n\n        function d3_selection_interruptNS(ns) {\n          return function () {\n            var lock, activeId, active;\n\n            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {\n              active.timer.c = null;\n              active.timer.t = NaN;\n              if (--lock.count) delete lock[activeId];else delete this[ns];\n              lock.active += .5;\n              active.event && active.event.interrupt.call(this, this.__data__, active.index);\n            }\n          };\n        }\n\n        function d3_transition(groups, ns, id) {\n          d3_subclass(groups, d3_transitionPrototype);\n          groups.namespace = ns;\n          groups.id = id;\n          return groups;\n        }\n\n        var d3_transitionPrototype = [],\n            d3_transitionId = 0,\n            d3_transitionInheritId,\n            d3_transitionInherit;\n        d3_transitionPrototype.call = d3_selectionPrototype.call;\n        d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n        d3_transitionPrototype.node = d3_selectionPrototype.node;\n        d3_transitionPrototype.size = d3_selectionPrototype.size;\n\n        d3.transition = function (selection, name) {\n          return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);\n        };\n\n        d3.transition.prototype = d3_transitionPrototype;\n\n        d3_transitionPrototype.select = function (selector) {\n          var id = this.id,\n              ns = this.namespace,\n              subgroups = [],\n              subgroup,\n              subnode,\n              node;\n          selector = d3_selection_selector(selector);\n\n          for (var j = -1, m = this.length; ++j < m;) {\n            subgroups.push(subgroup = []);\n\n            for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n              if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\n                if (\"__data__\" in node) subnode.__data__ = node.__data__;\n                d3_transitionNode(subnode, i, ns, id, node[ns][id]);\n                subgroup.push(subnode);\n              } else {\n                subgroup.push(null);\n              }\n            }\n          }\n\n          return d3_transition(subgroups, ns, id);\n        };\n\n        d3_transitionPrototype.selectAll = function (selector) {\n          var id = this.id,\n              ns = this.namespace,\n              subgroups = [],\n              subgroup,\n              subnodes,\n              node,\n              subnode,\n              transition;\n          selector = d3_selection_selectorAll(selector);\n\n          for (var j = -1, m = this.length; ++j < m;) {\n            for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n              if (node = group[i]) {\n                transition = node[ns][id];\n                subnodes = selector.call(node, node.__data__, i, j);\n                subgroups.push(subgroup = []);\n\n                for (var k = -1, o = subnodes.length; ++k < o;) {\n                  if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);\n                  subgroup.push(subnode);\n                }\n              }\n            }\n          }\n\n          return d3_transition(subgroups, ns, id);\n        };\n\n        d3_transitionPrototype.filter = function (filter) {\n          var subgroups = [],\n              subgroup,\n              group,\n              node;\n          if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n          for (var j = 0, m = this.length; j < m; j++) {\n            subgroups.push(subgroup = []);\n\n            for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n              if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n                subgroup.push(node);\n              }\n            }\n          }\n\n          return d3_transition(subgroups, this.namespace, this.id);\n        };\n\n        d3_transitionPrototype.tween = function (name, tween) {\n          var id = this.id,\n              ns = this.namespace;\n          if (arguments.length < 2) return this.node()[ns][id].tween.get(name);\n          return d3_selection_each(this, tween == null ? function (node) {\n            node[ns][id].tween.remove(name);\n          } : function (node) {\n            node[ns][id].tween.set(name, tween);\n          });\n        };\n\n        function d3_transition_tween(groups, name, value, tween) {\n          var id = groups.id,\n              ns = groups.namespace;\n          return d3_selection_each(groups, typeof value === \"function\" ? function (node, i, j) {\n            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n          } : (value = tween(value), function (node) {\n            node[ns][id].tween.set(name, value);\n          }));\n        }\n\n        d3_transitionPrototype.attr = function (nameNS, value) {\n          if (arguments.length < 2) {\n            for (value in nameNS) this.attr(value, nameNS[value]);\n\n            return this;\n          }\n\n          var interpolate = nameNS == \"transform\" ? d3_interpolateTransform : d3_interpolate,\n              name = d3.ns.qualify(nameNS);\n\n          function attrNull() {\n            this.removeAttribute(name);\n          }\n\n          function attrNullNS() {\n            this.removeAttributeNS(name.space, name.local);\n          }\n\n          function attrTween(b) {\n            return b == null ? attrNull : (b += \"\", function () {\n              var a = this.getAttribute(name),\n                  i;\n              return a !== b && (i = interpolate(a, b), function (t) {\n                this.setAttribute(name, i(t));\n              });\n            });\n          }\n\n          function attrTweenNS(b) {\n            return b == null ? attrNullNS : (b += \"\", function () {\n              var a = this.getAttributeNS(name.space, name.local),\n                  i;\n              return a !== b && (i = interpolate(a, b), function (t) {\n                this.setAttributeNS(name.space, name.local, i(t));\n              });\n            });\n          }\n\n          return d3_transition_tween(this, \"attr.\" + nameNS, value, name.local ? attrTweenNS : attrTween);\n        };\n\n        d3_transitionPrototype.attrTween = function (nameNS, tween) {\n          var name = d3.ns.qualify(nameNS);\n\n          function attrTween(d, i) {\n            var f = tween.call(this, d, i, this.getAttribute(name));\n            return f && function (t) {\n              this.setAttribute(name, f(t));\n            };\n          }\n\n          function attrTweenNS(d, i) {\n            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n            return f && function (t) {\n              this.setAttributeNS(name.space, name.local, f(t));\n            };\n          }\n\n          return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n        };\n\n        d3_transitionPrototype.style = function (name, value, priority) {\n          var n = arguments.length;\n\n          if (n < 3) {\n            if (typeof name !== \"string\") {\n              if (n < 2) value = \"\";\n\n              for (priority in name) this.style(priority, name[priority], value);\n\n              return this;\n            }\n\n            priority = \"\";\n          }\n\n          function styleNull() {\n            this.style.removeProperty(name);\n          }\n\n          function styleString(b) {\n            return b == null ? styleNull : (b += \"\", function () {\n              var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name),\n                  i;\n              return a !== b && (i = d3_interpolate(a, b), function (t) {\n                this.style.setProperty(name, i(t), priority);\n              });\n            });\n          }\n\n          return d3_transition_tween(this, \"style.\" + name, value, styleString);\n        };\n\n        d3_transitionPrototype.styleTween = function (name, tween, priority) {\n          if (arguments.length < 3) priority = \"\";\n\n          function styleTween(d, i) {\n            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));\n            return f && function (t) {\n              this.style.setProperty(name, f(t), priority);\n            };\n          }\n\n          return this.tween(\"style.\" + name, styleTween);\n        };\n\n        d3_transitionPrototype.text = function (value) {\n          return d3_transition_tween(this, \"text\", value, d3_transition_text);\n        };\n\n        function d3_transition_text(b) {\n          if (b == null) b = \"\";\n          return function () {\n            this.textContent = b;\n          };\n        }\n\n        d3_transitionPrototype.remove = function () {\n          var ns = this.namespace;\n          return this.each(\"end.transition\", function () {\n            var p;\n            if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);\n          });\n        };\n\n        d3_transitionPrototype.ease = function (value) {\n          var id = this.id,\n              ns = this.namespace;\n          if (arguments.length < 1) return this.node()[ns][id].ease;\n          if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\n          return d3_selection_each(this, function (node) {\n            node[ns][id].ease = value;\n          });\n        };\n\n        d3_transitionPrototype.delay = function (value) {\n          var id = this.id,\n              ns = this.namespace;\n          if (arguments.length < 1) return this.node()[ns][id].delay;\n          return d3_selection_each(this, typeof value === \"function\" ? function (node, i, j) {\n            node[ns][id].delay = +value.call(node, node.__data__, i, j);\n          } : (value = +value, function (node) {\n            node[ns][id].delay = value;\n          }));\n        };\n\n        d3_transitionPrototype.duration = function (value) {\n          var id = this.id,\n              ns = this.namespace;\n          if (arguments.length < 1) return this.node()[ns][id].duration;\n          return d3_selection_each(this, typeof value === \"function\" ? function (node, i, j) {\n            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));\n          } : (value = Math.max(1, value), function (node) {\n            node[ns][id].duration = value;\n          }));\n        };\n\n        d3_transitionPrototype.each = function (type, listener) {\n          var id = this.id,\n              ns = this.namespace;\n\n          if (arguments.length < 2) {\n            var inherit = d3_transitionInherit,\n                inheritId = d3_transitionInheritId;\n\n            try {\n              d3_transitionInheritId = id;\n              d3_selection_each(this, function (node, i, j) {\n                d3_transitionInherit = node[ns][id];\n                type.call(node, node.__data__, i, j);\n              });\n            } finally {\n              d3_transitionInherit = inherit;\n              d3_transitionInheritId = inheritId;\n            }\n          } else {\n            d3_selection_each(this, function (node) {\n              var transition = node[ns][id];\n              (transition.event || (transition.event = d3.dispatch(\"start\", \"end\", \"interrupt\"))).on(type, listener);\n            });\n          }\n\n          return this;\n        };\n\n        d3_transitionPrototype.transition = function () {\n          var id0 = this.id,\n              id1 = ++d3_transitionId,\n              ns = this.namespace,\n              subgroups = [],\n              subgroup,\n              group,\n              node,\n              transition;\n\n          for (var j = 0, m = this.length; j < m; j++) {\n            subgroups.push(subgroup = []);\n\n            for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n              if (node = group[i]) {\n                transition = node[ns][id0];\n                d3_transitionNode(node, i, ns, id1, {\n                  time: transition.time,\n                  ease: transition.ease,\n                  delay: transition.delay + transition.duration,\n                  duration: transition.duration\n                });\n              }\n\n              subgroup.push(node);\n            }\n          }\n\n          return d3_transition(subgroups, ns, id1);\n        };\n\n        function d3_transitionNamespace(name) {\n          return name == null ? \"__transition__\" : \"__transition_\" + name + \"__\";\n        }\n\n        function d3_transitionNode(node, i, ns, id, inherit) {\n          var lock = node[ns] || (node[ns] = {\n            active: 0,\n            count: 0\n          }),\n              transition = lock[id],\n              time,\n              timer,\n              duration,\n              ease,\n              tweens;\n\n          function schedule(elapsed) {\n            var delay = transition.delay;\n            timer.t = delay + time;\n            if (delay <= elapsed) return start(elapsed - delay);\n            timer.c = start;\n          }\n\n          function start(elapsed) {\n            var activeId = lock.active,\n                active = lock[activeId];\n\n            if (active) {\n              active.timer.c = null;\n              active.timer.t = NaN;\n              --lock.count;\n              delete lock[activeId];\n              active.event && active.event.interrupt.call(node, node.__data__, active.index);\n            }\n\n            for (var cancelId in lock) {\n              if (+cancelId < id) {\n                var cancel = lock[cancelId];\n                cancel.timer.c = null;\n                cancel.timer.t = NaN;\n                --lock.count;\n                delete lock[cancelId];\n              }\n            }\n\n            timer.c = tick;\n            d3_timer(function () {\n              if (timer.c && tick(elapsed || 1)) {\n                timer.c = null;\n                timer.t = NaN;\n              }\n\n              return 1;\n            }, 0, time);\n            lock.active = id;\n            transition.event && transition.event.start.call(node, node.__data__, i);\n            tweens = [];\n            transition.tween.forEach(function (key, value) {\n              if (value = value.call(node, node.__data__, i)) {\n                tweens.push(value);\n              }\n            });\n            ease = transition.ease;\n            duration = transition.duration;\n          }\n\n          function tick(elapsed) {\n            var t = elapsed / duration,\n                e = ease(t),\n                n = tweens.length;\n\n            while (n > 0) {\n              tweens[--n].call(node, e);\n            }\n\n            if (t >= 1) {\n              transition.event && transition.event.end.call(node, node.__data__, i);\n              if (--lock.count) delete lock[id];else delete node[ns];\n              return 1;\n            }\n          }\n\n          if (!transition) {\n            time = inherit.time;\n            timer = d3_timer(schedule, 0, time);\n            transition = lock[id] = {\n              tween: new d3_Map(),\n              time: time,\n              timer: timer,\n              delay: inherit.delay,\n              duration: inherit.duration,\n              ease: inherit.ease,\n              index: i\n            };\n            inherit = null;\n            ++lock.count;\n          }\n        }\n\n        d3.svg.axis = function () {\n          var scale = d3.scale.linear(),\n              orient = d3_svg_axisDefaultOrient,\n              innerTickSize = 6,\n              outerTickSize = 6,\n              tickPadding = 3,\n              tickArguments_ = [10],\n              tickValues = null,\n              tickFormat_;\n\n          function axis(g) {\n            g.each(function () {\n              var g = d3.select(this);\n              var scale0 = this.__chart__ || scale,\n                  scale1 = this.__chart__ = scale.copy();\n              var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues,\n                  tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_,\n                  tick = g.selectAll(\".tick\").data(ticks, scale1),\n                  tickEnter = tick.enter().insert(\"g\", \".domain\").attr(\"class\", \"tick\").style(\"opacity\", ε),\n                  tickExit = d3.transition(tick.exit()).style(\"opacity\", ε).remove(),\n                  tickUpdate = d3.transition(tick.order()).style(\"opacity\", 1),\n                  tickSpacing = Math.max(innerTickSize, 0) + tickPadding,\n                  tickTransform;\n              var range = d3_scaleRange(scale1),\n                  path = g.selectAll(\".domain\").data([0]),\n                  pathUpdate = (path.enter().append(\"path\").attr(\"class\", \"domain\"), d3.transition(path));\n              tickEnter.append(\"line\");\n              tickEnter.append(\"text\");\n              var lineEnter = tickEnter.select(\"line\"),\n                  lineUpdate = tickUpdate.select(\"line\"),\n                  text = tick.select(\"text\").text(tickFormat),\n                  textEnter = tickEnter.select(\"text\"),\n                  textUpdate = tickUpdate.select(\"text\"),\n                  sign = orient === \"top\" || orient === \"left\" ? -1 : 1,\n                  x1,\n                  x2,\n                  y1,\n                  y2;\n\n              if (orient === \"bottom\" || orient === \"top\") {\n                tickTransform = d3_svg_axisX, x1 = \"x\", y1 = \"y\", x2 = \"x2\", y2 = \"y2\";\n                text.attr(\"dy\", sign < 0 ? \"0em\" : \".71em\").style(\"text-anchor\", \"middle\");\n                pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + sign * outerTickSize + \"V0H\" + range[1] + \"V\" + sign * outerTickSize);\n              } else {\n                tickTransform = d3_svg_axisY, x1 = \"y\", y1 = \"x\", x2 = \"y2\", y2 = \"x2\";\n                text.attr(\"dy\", \".32em\").style(\"text-anchor\", sign < 0 ? \"end\" : \"start\");\n                pathUpdate.attr(\"d\", \"M\" + sign * outerTickSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + sign * outerTickSize);\n              }\n\n              lineEnter.attr(y2, sign * innerTickSize);\n              textEnter.attr(y1, sign * tickSpacing);\n              lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);\n              textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);\n\n              if (scale1.rangeBand) {\n                var x = scale1,\n                    dx = x.rangeBand() / 2;\n\n                scale0 = scale1 = function (d) {\n                  return x(d) + dx;\n                };\n              } else if (scale0.rangeBand) {\n                scale0 = scale1;\n              } else {\n                tickExit.call(tickTransform, scale1, scale0);\n              }\n\n              tickEnter.call(tickTransform, scale0, scale1);\n              tickUpdate.call(tickTransform, scale1, scale1);\n            });\n          }\n\n          axis.scale = function (x) {\n            if (!arguments.length) return scale;\n            scale = x;\n            return axis;\n          };\n\n          axis.orient = function (x) {\n            if (!arguments.length) return orient;\n            orient = x in d3_svg_axisOrients ? x + \"\" : d3_svg_axisDefaultOrient;\n            return axis;\n          };\n\n          axis.ticks = function () {\n            if (!arguments.length) return tickArguments_;\n            tickArguments_ = d3_array(arguments);\n            return axis;\n          };\n\n          axis.tickValues = function (x) {\n            if (!arguments.length) return tickValues;\n            tickValues = x;\n            return axis;\n          };\n\n          axis.tickFormat = function (x) {\n            if (!arguments.length) return tickFormat_;\n            tickFormat_ = x;\n            return axis;\n          };\n\n          axis.tickSize = function (x) {\n            var n = arguments.length;\n            if (!n) return innerTickSize;\n            innerTickSize = +x;\n            outerTickSize = +arguments[n - 1];\n            return axis;\n          };\n\n          axis.innerTickSize = function (x) {\n            if (!arguments.length) return innerTickSize;\n            innerTickSize = +x;\n            return axis;\n          };\n\n          axis.outerTickSize = function (x) {\n            if (!arguments.length) return outerTickSize;\n            outerTickSize = +x;\n            return axis;\n          };\n\n          axis.tickPadding = function (x) {\n            if (!arguments.length) return tickPadding;\n            tickPadding = +x;\n            return axis;\n          };\n\n          axis.tickSubdivide = function () {\n            return arguments.length && axis;\n          };\n\n          return axis;\n        };\n\n        var d3_svg_axisDefaultOrient = \"bottom\",\n            d3_svg_axisOrients = {\n          top: 1,\n          right: 1,\n          bottom: 1,\n          left: 1\n        };\n\n        function d3_svg_axisX(selection, x0, x1) {\n          selection.attr(\"transform\", function (d) {\n            var v0 = x0(d);\n            return \"translate(\" + (isFinite(v0) ? v0 : x1(d)) + \",0)\";\n          });\n        }\n\n        function d3_svg_axisY(selection, y0, y1) {\n          selection.attr(\"transform\", function (d) {\n            var v0 = y0(d);\n            return \"translate(0,\" + (isFinite(v0) ? v0 : y1(d)) + \")\";\n          });\n        }\n\n        d3.svg.brush = function () {\n          var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"),\n              x = null,\n              y = null,\n              xExtent = [0, 0],\n              yExtent = [0, 0],\n              xExtentDomain,\n              yExtentDomain,\n              xClamp = true,\n              yClamp = true,\n              resizes = d3_svg_brushResizes[0];\n\n          function brush(g) {\n            g.each(function () {\n              var g = d3.select(this).style(\"pointer-events\", \"all\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\").on(\"mousedown.brush\", brushstart).on(\"touchstart.brush\", brushstart);\n              var background = g.selectAll(\".background\").data([0]);\n              background.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\");\n              g.selectAll(\".extent\").data([0]).enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\");\n              var resize = g.selectAll(\".resize\").data(resizes, d3_identity);\n              resize.exit().remove();\n              resize.enter().append(\"g\").attr(\"class\", function (d) {\n                return \"resize \" + d;\n              }).style(\"cursor\", function (d) {\n                return d3_svg_brushCursor[d];\n              }).append(\"rect\").attr(\"x\", function (d) {\n                return /[ew]$/.test(d) ? -3 : null;\n              }).attr(\"y\", function (d) {\n                return /^[ns]/.test(d) ? -3 : null;\n              }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\");\n              resize.style(\"display\", brush.empty() ? \"none\" : null);\n              var gUpdate = d3.transition(g),\n                  backgroundUpdate = d3.transition(background),\n                  range;\n\n              if (x) {\n                range = d3_scaleRange(x);\n                backgroundUpdate.attr(\"x\", range[0]).attr(\"width\", range[1] - range[0]);\n                redrawX(gUpdate);\n              }\n\n              if (y) {\n                range = d3_scaleRange(y);\n                backgroundUpdate.attr(\"y\", range[0]).attr(\"height\", range[1] - range[0]);\n                redrawY(gUpdate);\n              }\n\n              redraw(gUpdate);\n            });\n          }\n\n          brush.event = function (g) {\n            g.each(function () {\n              var event_ = event.of(this, arguments),\n                  extent1 = {\n                x: xExtent,\n                y: yExtent,\n                i: xExtentDomain,\n                j: yExtentDomain\n              },\n                  extent0 = this.__chart__ || extent1;\n              this.__chart__ = extent1;\n\n              if (d3_transitionInheritId) {\n                d3.select(this).transition().each(\"start.brush\", function () {\n                  xExtentDomain = extent0.i;\n                  yExtentDomain = extent0.j;\n                  xExtent = extent0.x;\n                  yExtent = extent0.y;\n                  event_({\n                    type: \"brushstart\"\n                  });\n                }).tween(\"brush:brush\", function () {\n                  var xi = d3_interpolateArray(xExtent, extent1.x),\n                      yi = d3_interpolateArray(yExtent, extent1.y);\n                  xExtentDomain = yExtentDomain = null;\n                  return function (t) {\n                    xExtent = extent1.x = xi(t);\n                    yExtent = extent1.y = yi(t);\n                    event_({\n                      type: \"brush\",\n                      mode: \"resize\"\n                    });\n                  };\n                }).each(\"end.brush\", function () {\n                  xExtentDomain = extent1.i;\n                  yExtentDomain = extent1.j;\n                  event_({\n                    type: \"brush\",\n                    mode: \"resize\"\n                  });\n                  event_({\n                    type: \"brushend\"\n                  });\n                });\n              } else {\n                event_({\n                  type: \"brushstart\"\n                });\n                event_({\n                  type: \"brush\",\n                  mode: \"resize\"\n                });\n                event_({\n                  type: \"brushend\"\n                });\n              }\n            });\n          };\n\n          function redraw(g) {\n            g.selectAll(\".resize\").attr(\"transform\", function (d) {\n              return \"translate(\" + xExtent[+/e$/.test(d)] + \",\" + yExtent[+/^s/.test(d)] + \")\";\n            });\n          }\n\n          function redrawX(g) {\n            g.select(\".extent\").attr(\"x\", xExtent[0]);\n            g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", xExtent[1] - xExtent[0]);\n          }\n\n          function redrawY(g) {\n            g.select(\".extent\").attr(\"y\", yExtent[0]);\n            g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", yExtent[1] - yExtent[0]);\n          }\n\n          function brushstart() {\n            var target = this,\n                eventTarget = d3.select(d3.event.target),\n                event_ = event.of(target, arguments),\n                g = d3.select(target),\n                resizing = eventTarget.datum(),\n                resizingX = !/^(n|s)$/.test(resizing) && x,\n                resizingY = !/^(e|w)$/.test(resizing) && y,\n                dragging = eventTarget.classed(\"extent\"),\n                dragRestore = d3_event_dragSuppress(target),\n                center,\n                origin = d3.mouse(target),\n                offset;\n            var w = d3.select(d3_window(target)).on(\"keydown.brush\", keydown).on(\"keyup.brush\", keyup);\n\n            if (d3.event.changedTouches) {\n              w.on(\"touchmove.brush\", brushmove).on(\"touchend.brush\", brushend);\n            } else {\n              w.on(\"mousemove.brush\", brushmove).on(\"mouseup.brush\", brushend);\n            }\n\n            g.interrupt().selectAll(\"*\").interrupt();\n\n            if (dragging) {\n              origin[0] = xExtent[0] - origin[0];\n              origin[1] = yExtent[0] - origin[1];\n            } else if (resizing) {\n              var ex = +/w$/.test(resizing),\n                  ey = +/^n/.test(resizing);\n              offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];\n              origin[0] = xExtent[ex];\n              origin[1] = yExtent[ey];\n            } else if (d3.event.altKey) center = origin.slice();\n\n            g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n            d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n            event_({\n              type: \"brushstart\"\n            });\n            brushmove();\n\n            function keydown() {\n              if (d3.event.keyCode == 32) {\n                if (!dragging) {\n                  center = null;\n                  origin[0] -= xExtent[1];\n                  origin[1] -= yExtent[1];\n                  dragging = 2;\n                }\n\n                d3_eventPreventDefault();\n              }\n            }\n\n            function keyup() {\n              if (d3.event.keyCode == 32 && dragging == 2) {\n                origin[0] += xExtent[1];\n                origin[1] += yExtent[1];\n                dragging = 0;\n                d3_eventPreventDefault();\n              }\n            }\n\n            function brushmove() {\n              var point = d3.mouse(target),\n                  moved = false;\n\n              if (offset) {\n                point[0] += offset[0];\n                point[1] += offset[1];\n              }\n\n              if (!dragging) {\n                if (d3.event.altKey) {\n                  if (!center) center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];\n                  origin[0] = xExtent[+(point[0] < center[0])];\n                  origin[1] = yExtent[+(point[1] < center[1])];\n                } else center = null;\n              }\n\n              if (resizingX && move1(point, x, 0)) {\n                redrawX(g);\n                moved = true;\n              }\n\n              if (resizingY && move1(point, y, 1)) {\n                redrawY(g);\n                moved = true;\n              }\n\n              if (moved) {\n                redraw(g);\n                event_({\n                  type: \"brush\",\n                  mode: dragging ? \"move\" : \"resize\"\n                });\n              }\n            }\n\n            function move1(point, scale, i) {\n              var range = d3_scaleRange(scale),\n                  r0 = range[0],\n                  r1 = range[1],\n                  position = origin[i],\n                  extent = i ? yExtent : xExtent,\n                  size = extent[1] - extent[0],\n                  min,\n                  max;\n\n              if (dragging) {\n                r0 -= position;\n                r1 -= size + position;\n              }\n\n              min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];\n\n              if (dragging) {\n                max = (min += position) + size;\n              } else {\n                if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n\n                if (position < min) {\n                  max = min;\n                  min = position;\n                } else {\n                  max = position;\n                }\n              }\n\n              if (extent[0] != min || extent[1] != max) {\n                if (i) yExtentDomain = null;else xExtentDomain = null;\n                extent[0] = min;\n                extent[1] = max;\n                return true;\n              }\n            }\n\n            function brushend() {\n              brushmove();\n              g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n              d3.select(\"body\").style(\"cursor\", null);\n              w.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null);\n              dragRestore();\n              event_({\n                type: \"brushend\"\n              });\n            }\n          }\n\n          brush.x = function (z) {\n            if (!arguments.length) return x;\n            x = z;\n            resizes = d3_svg_brushResizes[!x << 1 | !y];\n            return brush;\n          };\n\n          brush.y = function (z) {\n            if (!arguments.length) return y;\n            y = z;\n            resizes = d3_svg_brushResizes[!x << 1 | !y];\n            return brush;\n          };\n\n          brush.clamp = function (z) {\n            if (!arguments.length) return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;\n            if (x && y) xClamp = !!z[0], yClamp = !!z[1];else if (x) xClamp = !!z;else if (y) yClamp = !!z;\n            return brush;\n          };\n\n          brush.extent = function (z) {\n            var x0, x1, y0, y1, t;\n\n            if (!arguments.length) {\n              if (x) {\n                if (xExtentDomain) {\n                  x0 = xExtentDomain[0], x1 = xExtentDomain[1];\n                } else {\n                  x0 = xExtent[0], x1 = xExtent[1];\n                  if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n                  if (x1 < x0) t = x0, x0 = x1, x1 = t;\n                }\n              }\n\n              if (y) {\n                if (yExtentDomain) {\n                  y0 = yExtentDomain[0], y1 = yExtentDomain[1];\n                } else {\n                  y0 = yExtent[0], y1 = yExtent[1];\n                  if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n                  if (y1 < y0) t = y0, y0 = y1, y1 = t;\n                }\n              }\n\n              return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];\n            }\n\n            if (x) {\n              x0 = z[0], x1 = z[1];\n              if (y) x0 = x0[0], x1 = x1[0];\n              xExtentDomain = [x0, x1];\n              if (x.invert) x0 = x(x0), x1 = x(x1);\n              if (x1 < x0) t = x0, x0 = x1, x1 = t;\n              if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [x0, x1];\n            }\n\n            if (y) {\n              y0 = z[0], y1 = z[1];\n              if (x) y0 = y0[1], y1 = y1[1];\n              yExtentDomain = [y0, y1];\n              if (y.invert) y0 = y(y0), y1 = y(y1);\n              if (y1 < y0) t = y0, y0 = y1, y1 = t;\n              if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [y0, y1];\n            }\n\n            return brush;\n          };\n\n          brush.clear = function () {\n            if (!brush.empty()) {\n              xExtent = [0, 0], yExtent = [0, 0];\n              xExtentDomain = yExtentDomain = null;\n            }\n\n            return brush;\n          };\n\n          brush.empty = function () {\n            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\n          };\n\n          return d3.rebind(brush, event, \"on\");\n        };\n\n        var d3_svg_brushCursor = {\n          n: \"ns-resize\",\n          e: \"ew-resize\",\n          s: \"ns-resize\",\n          w: \"ew-resize\",\n          nw: \"nwse-resize\",\n          ne: \"nesw-resize\",\n          se: \"nwse-resize\",\n          sw: \"nesw-resize\"\n        };\n        var d3_svg_brushResizes = [[\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"], [\"e\", \"w\"], [\"n\", \"s\"], []];\n        var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\n        var d3_time_formatUtc = d3_time_format.utc;\n        var d3_time_formatIso = d3_time_formatUtc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n        d3_time_format.iso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\") ? d3_time_formatIsoNative : d3_time_formatIso;\n\n        function d3_time_formatIsoNative(date) {\n          return date.toISOString();\n        }\n\n        d3_time_formatIsoNative.parse = function (string) {\n          var date = new Date(string);\n          return isNaN(date) ? null : date;\n        };\n\n        d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n        d3_time.second = d3_time_interval(function (date) {\n          return new d3_date(Math.floor(date / 1e3) * 1e3);\n        }, function (date, offset) {\n          date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n        }, function (date) {\n          return date.getSeconds();\n        });\n        d3_time.seconds = d3_time.second.range;\n        d3_time.seconds.utc = d3_time.second.utc.range;\n        d3_time.minute = d3_time_interval(function (date) {\n          return new d3_date(Math.floor(date / 6e4) * 6e4);\n        }, function (date, offset) {\n          date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n        }, function (date) {\n          return date.getMinutes();\n        });\n        d3_time.minutes = d3_time.minute.range;\n        d3_time.minutes.utc = d3_time.minute.utc.range;\n        d3_time.hour = d3_time_interval(function (date) {\n          var timezone = date.getTimezoneOffset() / 60;\n          return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n        }, function (date, offset) {\n          date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n        }, function (date) {\n          return date.getHours();\n        });\n        d3_time.hours = d3_time.hour.range;\n        d3_time.hours.utc = d3_time.hour.utc.range;\n        d3_time.month = d3_time_interval(function (date) {\n          date = d3_time.day(date);\n          date.setDate(1);\n          return date;\n        }, function (date, offset) {\n          date.setMonth(date.getMonth() + offset);\n        }, function (date) {\n          return date.getMonth();\n        });\n        d3_time.months = d3_time.month.range;\n        d3_time.months.utc = d3_time.month.utc.range;\n\n        function d3_time_scale(linear, methods, format) {\n          function scale(x) {\n            return linear(x);\n          }\n\n          scale.invert = function (x) {\n            return d3_time_scaleDate(linear.invert(x));\n          };\n\n          scale.domain = function (x) {\n            if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n            linear.domain(x);\n            return scale;\n          };\n\n          function tickMethod(extent, count) {\n            var span = extent[1] - extent[0],\n                target = span / count,\n                i = d3.bisect(d3_time_scaleSteps, target);\n            return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function (d) {\n              return d / 31536e6;\n            }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\n          }\n\n          scale.nice = function (interval, skip) {\n            var domain = scale.domain(),\n                extent = d3_scaleExtent(domain),\n                method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" && tickMethod(extent, interval);\n            if (method) interval = method[0], skip = method[1];\n\n            function skipped(date) {\n              return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;\n            }\n\n            return scale.domain(d3_scale_nice(domain, skip > 1 ? {\n              floor: function (date) {\n                while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);\n\n                return date;\n              },\n              ceil: function (date) {\n                while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);\n\n                return date;\n              }\n            } : interval));\n          };\n\n          scale.ticks = function (interval, skip) {\n            var extent = d3_scaleExtent(scale.domain()),\n                method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" ? tickMethod(extent, interval) : !interval.range && [{\n              range: interval\n            }, skip];\n            if (method) interval = method[0], skip = method[1];\n            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);\n          };\n\n          scale.tickFormat = function () {\n            return format;\n          };\n\n          scale.copy = function () {\n            return d3_time_scale(linear.copy(), methods, format);\n          };\n\n          return d3_scale_linearRebind(scale, linear);\n        }\n\n        function d3_time_scaleDate(t) {\n          return new Date(t);\n        }\n\n        var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];\n        var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];\n        var d3_time_scaleLocalFormat = d3_time_format.multi([[\".%L\", function (d) {\n          return d.getMilliseconds();\n        }], [\":%S\", function (d) {\n          return d.getSeconds();\n        }], [\"%I:%M\", function (d) {\n          return d.getMinutes();\n        }], [\"%I %p\", function (d) {\n          return d.getHours();\n        }], [\"%a %d\", function (d) {\n          return d.getDay() && d.getDate() != 1;\n        }], [\"%b %d\", function (d) {\n          return d.getDate() != 1;\n        }], [\"%B\", function (d) {\n          return d.getMonth();\n        }], [\"%Y\", d3_true]]);\n        var d3_time_scaleMilliseconds = {\n          range: function (start, stop, step) {\n            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);\n          },\n          floor: d3_identity,\n          ceil: d3_identity\n        };\n        d3_time_scaleLocalMethods.year = d3_time.year;\n\n        d3_time.scale = function () {\n          return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n        };\n\n        var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function (m) {\n          return [m[0].utc, m[1]];\n        });\n        var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[\".%L\", function (d) {\n          return d.getUTCMilliseconds();\n        }], [\":%S\", function (d) {\n          return d.getUTCSeconds();\n        }], [\"%I:%M\", function (d) {\n          return d.getUTCMinutes();\n        }], [\"%I %p\", function (d) {\n          return d.getUTCHours();\n        }], [\"%a %d\", function (d) {\n          return d.getUTCDay() && d.getUTCDate() != 1;\n        }], [\"%b %d\", function (d) {\n          return d.getUTCDate() != 1;\n        }], [\"%B\", function (d) {\n          return d.getUTCMonth();\n        }], [\"%Y\", d3_true]]);\n        d3_time_scaleUtcMethods.year = d3_time.year.utc;\n\n        d3_time.scale.utc = function () {\n          return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);\n        };\n\n        d3.text = d3_xhrType(function (request) {\n          return request.responseText;\n        });\n\n        d3.json = function (url, callback) {\n          return d3_xhr(url, \"application/json\", d3_json, callback);\n        };\n\n        function d3_json(request) {\n          return JSON.parse(request.responseText);\n        }\n\n        d3.html = function (url, callback) {\n          return d3_xhr(url, \"text/html\", d3_html, callback);\n        };\n\n        function d3_html(request) {\n          var range = d3_document.createRange();\n          range.selectNode(d3_document.body);\n          return range.createContextualFragment(request.responseText);\n        }\n\n        d3.xml = d3_xhrType(function (request) {\n          return request.responseXML;\n        });\n        if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = d3, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if (typeof module === \"object\" && module.exports) module.exports = d3;else this.d3 = d3;\n      }();\n      /***/\n    },\n    /* 52 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _d3DataToJSX = __webpack_require__(33);\n\n      var _d3DataToJSX2 = _interopRequireDefault(_d3DataToJSX);\n\n      var _ChildComponent = __webpack_require__(39);\n\n      var _ChildComponent2 = _interopRequireDefault(_ChildComponent);\n\n      var _createBarChart = __webpack_require__(53);\n\n      var _createBarChart2 = _interopRequireDefault(_createBarChart);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var _class = function (_React$Component) {\n        _inherits(_class, _React$Component);\n\n        function _class(props) {\n          _classCallCheck(this, _class);\n\n          var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));\n\n          _this.state = {\n            d3DOM: [],\n            state: []\n          };\n          return _this;\n        }\n\n        _createClass(_class, [{\n          key: 'componentWillReceiveProps',\n          value: function componentWillReceiveProps(nextProps) {\n            var d3Data = (0, _d3DataToJSX2.default)((0, _createBarChart2.default)(nextProps.data));\n            this.setState({\n              d3DOM: d3Data.mappedData,\n              state: d3Data.state\n            });\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            return _react2.default.createElement('div', null, _react2.default.createElement(_ChildComponent2.default, {\n              data: this.state\n            }));\n          }\n        }]);\n\n        return _class;\n      }(_react2.default.Component);\n\n      exports.default = _class;\n      ;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 53 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _d = __webpack_require__(51);\n\n      var _d2 = _interopRequireDefault(_d);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var createBarChart = function createBarChart(data) {\n        // if user has defined colors for bars, designate fill colors\n        if (data.fill) {\n          data.dataSet.forEach(function (el, i) {\n            return el.fill = data.fill[i];\n          });\n        } // create html element for d3 to work on\n\n\n        var node = document.createElement('div'); // establish margins based on user input\n\n        var margin = data.margins,\n            width = data.width - margin.left - margin.right,\n            height = data.height - margin.top - margin.bottom; // ordinal scale for x-axis since not a numerical range\n\n        var x = _d2.default.scale.ordinal().rangeRoundBands([0, width], 0.1); // linear scale for y-axis as it will entail numerical values\n\n\n        var y = _d2.default.scale.linear().range([height, 0]); // scales x-axis based on user's defined width\n\n\n        var xAxis = _d2.default.svg.axis().scale(x) // applies labels below x-axis\n        .orient(\"bottom\"); // scales y-axis based on user's defined height\n\n\n        var yAxis = _d2.default.svg.axis().scale(y).orient(\"left\") // apply tick intervals based on user input\n        .ticks(data.ticks); // select created html element and append svg\n        // apply attributes to svg and append g elements\n\n\n        var svg = _d2.default.select(node).append(\"svg\").attr(\"width\", width + margin.left + margin.right).attr(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\"); // scale x-axis based on amount of labels provided by user\n\n\n        x.domain(data.dataSet.map(function (d) {\n          return d.label;\n        })); // scale y-axis based on range of values provided by user\n\n        y.domain([0, _d2.default.max(data.dataSet, function (d) {\n          return d.value;\n        })]); // append g elements responsible for x-axis label properties\n\n        svg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis).selectAll(\"text\").style(\"text-anchor\", \"end\").attr(\"dx\", \"-.8em\").attr(\"dy\", \"-.55em\").attr(\"transform\", \"rotate(-90)\"); // append g elements responsible for y-axis tick and label properties\n\n        svg.append(\"g\").attr(\"class\", \"y axis\").call(yAxis).append(\"text\").attr(\"transform\", \"rotate(-90)\").attr(\"y\", 6).attr(\"dy\", \".71em\").style(\"text-anchor\", \"end\").text(data.yAxisLabel); // bind user data to rectangles that will be appended to svg\n\n        svg.selectAll(\"bar\").data(data.dataSet).enter().append(\"rect\") // if user defined fill colors, they will be assigned here\n        .style(\"fill\", function (d) {\n          return d.fill || \"steelblue\";\n        }).attr(\"x\", function (d) {\n          return x(d.label);\n        }).attr(\"width\", x.rangeBand()).attr(\"y\", function (d) {\n          return y(d.value);\n        }).attr(\"height\", function (d) {\n          return height - y(d.value);\n        }).attr('fill', function (d) {\n          return d.fill;\n        }); // return built up html tree to be compiled to react elements\n\n        return node;\n      };\n\n      exports.default = createBarChart;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 54 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _d3DataToJSX = __webpack_require__(33);\n\n      var _d3DataToJSX2 = _interopRequireDefault(_d3DataToJSX);\n\n      var _ChildComponent = __webpack_require__(39);\n\n      var _ChildComponent2 = _interopRequireDefault(_ChildComponent);\n\n      var _createLineChart = __webpack_require__(55);\n\n      var _createLineChart2 = _interopRequireDefault(_createLineChart);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var _class = function (_React$Component) {\n        _inherits(_class, _React$Component);\n\n        function _class(props) {\n          _classCallCheck(this, _class);\n\n          var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));\n\n          _this.state = {\n            d3DOM: [],\n            state: []\n          };\n          return _this;\n        }\n\n        _createClass(_class, [{\n          key: 'componentWillReceiveProps',\n          value: function componentWillReceiveProps(nextProps) {\n            var d3Data = (0, _d3DataToJSX2.default)((0, _createLineChart2.default)(nextProps.data));\n            this.setState({\n              d3DOM: d3Data.mappedData,\n              state: d3Data.state\n            });\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            return _react2.default.createElement('div', null, _react2.default.createElement(_ChildComponent2.default, {\n              data: this.state\n            }));\n          }\n        }]);\n\n        return _class;\n      }(_react2.default.Component);\n\n      exports.default = _class;\n      ;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 55 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _d = __webpack_require__(51);\n\n      var _d2 = _interopRequireDefault(_d);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var createLineChart = function createLineChart(data) {\n        var node = document.createElement('div');\n        var margin = data.margins,\n            width = data.width - margin.left - margin.right,\n            height = data.height - margin.top - margin.bottom;\n\n        var formatDate = _d2.default.time.format(\"%d-%b-%y\");\n\n        var x = _d2.default.time.scale().range([0, width]);\n\n        var y = _d2.default.scale.linear().range([height, 0]);\n\n        var xAxis = _d2.default.svg.axis().scale(x).orient(data.orientXTicks);\n\n        var yAxis = _d2.default.svg.axis().scale(y).orient(data.orientYTicks);\n\n        var line = _d2.default.svg.line().x(function (d) {\n          return x(d.time);\n        }).y(function (d) {\n          return y(d.value);\n        });\n\n        var svg = _d2.default.select(node).append(\"svg\").attr(\"width\", width + margin.left + margin.right).attr(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n        data.dataset.map(function (el) {\n          if (typeof el.time === 'string') {\n            el.time = formatDate.parse(el.time);\n            el.value = +el.value;\n          }\n        });\n\n        var lineChartParse = function lineChartParse(data) {\n          data.time = formatDate.parse(data.time);\n          data.value = +data.value;\n          return data;\n        };\n\n        var setLineChartData = function setLineChartData(error, dataset) {\n          if (error) throw error;\n          x.domain(_d2.default.extent(dataset, function (d) {\n            return d.time;\n          }));\n          y.domain(_d2.default.extent(dataset, function (d) {\n            return d.value;\n          }));\n          svg.append(\"g\").attr(\"class\", data.XAxisClasses).attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis);\n          svg.append(\"g\").attr(\"class\", data.YAxisClasses).call(yAxis).append(\"text\").attr(\"transform\", \"rotate(-90)\").attr(\"y\", 6).attr(\"dy\", \".71em\").style(\"text-anchor\", \"end\").text(data.YAxisLabel);\n          svg.append(\"path\").datum(dataset).attr(\"class\", data.lineClass).attr(\"d\", line);\n          return node;\n        };\n\n        return data.tsvFileName !== '' ? _d2.default.tsv(data.tsvFileName, lineChartParse, setLineChartData) : data.csvFileName !== '' ? _d2.default.csv(data.csvFileName, lineChartParse, setLineChartData) : setLineChartData(false, data.dataset, data);\n      };\n\n      exports.default = createLineChart;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 56 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _d3DataToJSX = __webpack_require__(33);\n\n      var _d3DataToJSX2 = _interopRequireDefault(_d3DataToJSX);\n\n      var _ChildComponent = __webpack_require__(39);\n\n      var _ChildComponent2 = _interopRequireDefault(_ChildComponent);\n\n      var _createPieChart = __webpack_require__(57);\n\n      var _createPieChart2 = _interopRequireDefault(_createPieChart);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var _class = function (_React$Component) {\n        _inherits(_class, _React$Component);\n\n        function _class(props) {\n          _classCallCheck(this, _class);\n\n          var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));\n\n          _this.state = {\n            d3DOM: [],\n            state: []\n          };\n          return _this;\n        }\n\n        _createClass(_class, [{\n          key: 'componentWillReceiveProps',\n          value: function componentWillReceiveProps(nextProps) {\n            var d3Data = (0, _d3DataToJSX2.default)((0, _createPieChart2.default)(nextProps.data));\n            this.setState({\n              d3DOM: d3Data.mappedData,\n              state: d3Data.state\n            });\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            return _react2.default.createElement('div', null, _react2.default.createElement(_ChildComponent2.default, {\n              data: this.state\n            }));\n          }\n        }]);\n\n        return _class;\n      }(_react2.default.Component);\n\n      exports.default = _class;\n      ;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 57 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _d = __webpack_require__(51);\n\n      var _d2 = _interopRequireDefault(_d);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var createPieChart = function createPieChart(data) {\n        var node = document.createElement('div');\n        var radius = Math.min(data.width, data.height) / 2;\n\n        var color = _d2.default.scale.ordinal().range(data.colors);\n\n        var arc = _d2.default.svg.arc().outerRadius(radius - 10).innerRadius(0);\n\n        var labelArc = _d2.default.svg.arc().outerRadius(radius - 40).innerRadius(radius - 40);\n\n        var pie = _d2.default.layout.pie().sort(null).value(function (d) {\n          return d.quantity;\n        });\n\n        var svg = _d2.default.select(node).append(\"svg\").attr(\"width\", data.width).attr(\"height\", data.height).append(\"g\").attr(\"transform\", \"translate(\" + data.width / 2 + \",\" + data.height / 2 + \")\");\n\n        var g = svg.selectAll(\".arc\").data(pie(data.dataSet)).enter().append(\"g\").attr(\"class\", data.arcClass);\n        g.append(\"path\").attr(\"d\", arc).style(\"fill\", function (d) {\n          return color(d.data.label);\n        });\n        g.append(\"text\").attr(\"transform\", function (d) {\n          return \"translate(\" + labelArc.centroid(d) + \")\";\n        }).attr(\"dy\", \".35em\").text(function (d) {\n          return d.data.label;\n        });\n\n        var type = function type(d) {\n          d.quantity = +d.quantity;\n          return d;\n        };\n\n        return node;\n      };\n\n      exports.default = createPieChart;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 58 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _d3DataToJSX = __webpack_require__(33);\n\n      var _d3DataToJSX2 = _interopRequireDefault(_d3DataToJSX);\n\n      var _ChildComponent = __webpack_require__(39);\n\n      var _ChildComponent2 = _interopRequireDefault(_ChildComponent);\n\n      var _createScatterPlot = __webpack_require__(59);\n\n      var _createScatterPlot2 = _interopRequireDefault(_createScatterPlot);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var _class = function (_React$Component) {\n        _inherits(_class, _React$Component);\n\n        function _class(props) {\n          _classCallCheck(this, _class);\n\n          var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));\n\n          _this.state = {\n            d3DOM: [],\n            state: []\n          };\n          return _this;\n        }\n\n        _createClass(_class, [{\n          key: 'componentWillReceiveProps',\n          value: function componentWillReceiveProps(nextProps) {\n            var d3Data = (0, _d3DataToJSX2.default)((0, _createScatterPlot2.default)(nextProps.data));\n            this.setState({\n              d3DOM: d3Data.mappedData,\n              state: d3Data.state\n            });\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            return _react2.default.createElement('div', null, _react2.default.createElement(_ChildComponent2.default, {\n              data: this.state\n            }));\n          }\n        }]);\n\n        return _class;\n      }(_react2.default.Component);\n\n      exports.default = _class;\n      ;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 59 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _d = __webpack_require__(51);\n\n      var _d2 = _interopRequireDefault(_d);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var createScatterPlot = function createScatterPlot(data) {\n        var node = document.createElement('div');\n        var width = data.width - data.margin.left - data.margin.right;\n        var height = data.height - data.margin.top - data.margin.bottom;\n\n        var x = _d2.default.scale.linear().range([0, width]);\n\n        var y = _d2.default.scale.linear().range([height, 0]);\n\n        var color = _d2.default.scale.category10();\n\n        var xAxis = _d2.default.svg.axis().scale(x).orient(\"bottom\");\n\n        var yAxis = _d2.default.svg.axis().scale(y).orient(\"left\");\n\n        var svg = _d2.default.select(node).append(\"svg\").attr(\"width\", width + data.margin.left + data.margin.right).attr(\"height\", height + data.margin.top + data.margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + data.margin.left + \",\" + data.margin.top + \")\");\n\n        data.dataSet.forEach(function (d) {\n          d.y_value = +d.y_value;\n          d.x_value = +d.x_value;\n        });\n        x.domain(_d2.default.extent(data.dataSet, function (d) {\n          return d.x_value;\n        })).nice();\n        y.domain(_d2.default.extent(data.dataSet, function (d) {\n          return d.y_value;\n        })).nice();\n        svg.append(\"g\").attr(\"class\", data.x_axis_class).attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis).append(\"text\").attr(\"class\", data.label_class).attr(\"x\", width).attr(\"y\", -6).style(\"text-anchor\", \"end\").text(data.x_display_name);\n        svg.append(\"g\").attr(\"class\", data.y_axis_class).call(yAxis).append(\"text\").attr(\"class\", data.label_class).attr(\"transform\", \"rotate(-90)\").attr(\"y\", 6).attr(\"dy\", \".71em\").style(\"text-anchor\", \"end\").text(data.y_display_name);\n        svg.selectAll(\".dot\").data(data.dataSet).enter().append(\"circle\").attr(\"class\", data.dot_class).attr(\"r\", 3.5).attr(\"cx\", function (d) {\n          return x(d.x_value);\n        }).attr(\"cy\", function (d) {\n          return y(d.y_value);\n        }).style(\"fill\", function (d) {\n          return color(d.type);\n        });\n        var legend = svg.selectAll(\".legend\").data(color.domain()).enter().append(\"g\").attr(\"class\", data.legend_class).attr(\"transform\", function (d, i) {\n          return \"translate(0,\" + i * 20 + \")\";\n        });\n        legend.append(\"rect\").attr(\"x\", width - 18).attr(\"width\", 18).attr(\"height\", 18).style(\"fill\", color);\n        legend.append(\"text\").attr(\"x\", width - 24).attr(\"y\", 9).attr(\"dy\", \".35em\").style(\"text-anchor\", \"end\").text(function (d) {\n          return d;\n        });\n        return node;\n      };\n\n      exports.default = createScatterPlot;\n      module.exports = exports['default'];\n      /***/\n    }\n    /******/\n    ])\n  );\n});\n\n;","map":null,"metadata":{},"sourceType":"script"}