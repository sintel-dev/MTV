{"ast":null,"code":"import _defineProperty from \"/home/sergiu/Projects/mtv-react/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { createSelector } from 'reselect';\nexport const getSelectedExperimentData = state => state.selectedExperimentData;\n\nconst groupDataBy = (prediction, option) => prediction.data.map(predData => [Math.trunc(predData[0]) * 1000, predData[prediction.names.indexOf(option)]]);\n\nconst groupByEventWindows = (events, timestamps) => events.map(event => [timestamps.indexOf(Math.trunc(event.start_time) * 1000), timestamps.indexOf(Math.trunc(event.stop_time) * 1000), event.score, event.tag]);\n\nconst getScale = (w, h) => {\n  let minValue = Number.MAX_SAFE_INTEGER;\n  let maxValue = Number.MIN_SAFE_INTEGER;\n  const timeSeries = this.props.dataRun.timeSeries;\n  const timeSeriesMin = timeSeries[0][0];\n  const timeSeriesMax = timeSeries[timeSeries.length - 1][0];\n  const x = d3.scaleTime().range([0, w]);\n  const y = d3.scaleLinear().range([h, 0]);\n  minValue = minValue > timeSeriesMin ? timeSeriesMin : minValue;\n  maxValue = maxValue < timeSeriesMax ? timeSeriesMax : maxValue;\n  x.domain([minValue, maxValue]);\n  y.domain([-1, 1]);\n  return {\n    x,\n    y\n  };\n};\n\nexport const getProcessedDataRuns = createSelector([getSelectedExperimentData], experimentData => {\n  if (experimentData.isExperimentDataLoading) {\n    return [];\n  }\n\n  return experimentData.data.dataruns.map(datarun => {\n    const timeSeries = groupDataBy(datarun.prediction, 'y_raw');\n    const timeseriesPred = groupDataBy(datarun.prediction, 'y_raw_hat');\n    const timeseriesErr = groupDataBy(datarun.prediction, 'es_raw');\n    const eventWindows = groupByEventWindows(datarun.events, timeSeries.map(series => series[0]));\n    return _objectSpread({}, datarun, {\n      timeSeries,\n      timeseriesPred,\n      timeseriesErr,\n      eventWindows\n    });\n  });\n});","map":{"version":3,"sources":["/home/sergiu/Projects/mtv-react/src/model/selectors/experiment.js"],"names":["createSelector","getSelectedExperimentData","state","selectedExperimentData","groupDataBy","prediction","option","data","map","predData","Math","trunc","names","indexOf","groupByEventWindows","events","timestamps","event","start_time","stop_time","score","tag","getScale","w","h","minValue","Number","MAX_SAFE_INTEGER","maxValue","MIN_SAFE_INTEGER","timeSeries","props","dataRun","timeSeriesMin","timeSeriesMax","length","x","d3","scaleTime","range","y","scaleLinear","domain","getProcessedDataRuns","experimentData","isExperimentDataLoading","dataruns","datarun","timeseriesPred","timeseriesErr","eventWindows","series"],"mappings":"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","sourcesContent":["import { createSelector } from 'reselect';\n\nexport const getSelectedExperimentData = (state) => state.selectedExperimentData;\n\nconst groupDataBy = (prediction, option) => prediction.data.map(predData => [\n        Math.trunc(predData[0]) * 1000,\n        predData[prediction.names.indexOf(option)],\n    ]);\n\nconst groupByEventWindows = (events, timestamps) =>\n     events.map(event => [\n        timestamps.indexOf(Math.trunc(event.start_time) * 1000),\n        timestamps.indexOf(Math.trunc(event.stop_time) * 1000),\n        event.score,\n        event.tag,\n    ]);\n\n    const getScale = (w, h) => {\n        let minValue = Number.MAX_SAFE_INTEGER;\n        let maxValue = Number.MIN_SAFE_INTEGER;\n        const { timeSeries } = this.props.dataRun;\n        const timeSeriesMin = timeSeries[0][0];\n        const timeSeriesMax = timeSeries[timeSeries.length - 1][0];\n        const x = d3.scaleTime().range([0, w]);\n        const y = d3.scaleLinear().range([h, 0]);\n\n        minValue = minValue > timeSeriesMin ? timeSeriesMin : minValue;\n        maxValue = maxValue < timeSeriesMax ? timeSeriesMax : maxValue;\n        x.domain([minValue, maxValue]);\n        y.domain([-1, 1]);\n\n        return { x, y };\n      };\n\nexport const getProcessedDataRuns = createSelector(\n    [getSelectedExperimentData],\n    (experimentData) => {\n        if (experimentData.isExperimentDataLoading) { return []; }\n        return experimentData.data.dataruns.map(datarun => {\n            const timeSeries = groupDataBy(datarun.prediction, 'y_raw');\n            const timeseriesPred = groupDataBy(datarun.prediction, 'y_raw_hat');\n            const timeseriesErr = groupDataBy(datarun.prediction, 'es_raw');\n            const eventWindows = groupByEventWindows(datarun.events, timeSeries.map(series => series[0]));\n            return {\n                ...datarun,\n                timeSeries,\n                timeseriesPred,\n                timeseriesErr,\n                eventWindows,\n            };\n        });\n    },\n);\n"]},"metadata":{},"sourceType":"module"}