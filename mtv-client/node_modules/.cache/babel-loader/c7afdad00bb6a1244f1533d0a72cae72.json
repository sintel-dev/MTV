{"ast":null,"code":"import { createSelector } from 'reselect';\nexport const getExperimentsData = state => state.experiments;\nexport const getPipelinesData = state => state.pipelines;\nexport const getDatasets = state => state.datasets;\nexport const getSelectedPipeline = state => state.pipelines.pipelineName;\nexport const getSelectedProjectName = state => state.projects.selectedProject;\nexport const getIsExperimentsLoading = state => state.experiments.isExperimentsLoading;\nexport const getIsProjectsLoading = createSelector([getExperimentsData, getPipelinesData, getDatasets], (experimentsData, pipelinesData, datasets) => experimentsData.ieExperimentsLoading || datasets.isDatasetLoading || pipelinesData.isPipelinesLoading);\n\nconst groupExperimentsByProj = experiments => {\n  const projects = [];\n  const groupedExperiments = experiments.reduce((result, experiment) => {\n    result[experiment.project] = (result[experiment.project] || []).concat(experiment);\n    return result;\n  }, []);\n  Object.keys(groupedExperiments).forEach(projectName => {\n    projects.push({\n      experimentNum: groupedExperiments[projectName].length,\n      experiments: groupedExperiments[projectName],\n      name: projectName,\n      // uniquePipelineNum: countPipelines(projectName),\n      signalNum: function () {\n        switch (projectName) {\n          case 'SMAP':\n            return 55;\n\n          case 'MSL':\n            return 27;\n\n          default:\n            // For SES\n            return 71;\n        }\n      }()\n    });\n  }); // return projects;\n\n  return experiments.reduce((accumulator, experiment) => {\n    accumulator.push({});\n    return accumulator;\n  }, []);\n};\n\nexport const getProjectsList = createSelector([getExperimentsData], experimentsData => groupExperimentsByProj(experimentsData.experimentsList));\nexport const getFilteredExperiments = createSelector([getSelectedProjectName, getExperimentsData, getSelectedPipeline], (selectedProjectName, experimentsData, selectedPipeline) => experimentsData.experimentsList.filter(experiment => {\n  const isFromCurrentProject = experiment.project === selectedProjectName;\n  const isPipelineMatch = !selectedPipeline || experiment.pipeline === selectedPipeline;\n  return isFromCurrentProject && isPipelineMatch;\n}));","map":{"version":3,"sources":["/home/sergiu/Projects/mtv-react/src/model/selectors/projects.js"],"names":["createSelector","getExperimentsData","state","experiments","getPipelinesData","pipelines","getDatasets","datasets","getSelectedPipeline","pipelineName","getSelectedProjectName","projects","selectedProject","getIsExperimentsLoading","isExperimentsLoading","getIsProjectsLoading","experimentsData","pipelinesData","ieExperimentsLoading","isDatasetLoading","isPipelinesLoading","groupExperimentsByProj","groupedExperiments","reduce","result","experiment","project","concat","Object","keys","forEach","projectName","push","experimentNum","length","name","signalNum","accumulator","getProjectsList","experimentsList","getFilteredExperiments","selectedProjectName","selectedPipeline","filter","isFromCurrentProject","isPipelineMatch","pipeline"],"mappings":"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","sourcesContent":["import { createSelector } from 'reselect';\n\nexport const getExperimentsData = (state) => state.experiments;\nexport const getPipelinesData = (state) => state.pipelines;\nexport const getDatasets = (state) => state.datasets;\nexport const getSelectedPipeline = (state) => state.pipelines.pipelineName;\nexport const getSelectedProjectName = (state) => state.projects.selectedProject;\nexport const getIsExperimentsLoading = state => state.experiments.isExperimentsLoading;\n\nexport const getIsProjectsLoading = createSelector(\n    [getExperimentsData, getPipelinesData, getDatasets],\n    (experimentsData, pipelinesData, datasets) =>\n        experimentsData.ieExperimentsLoading || datasets.isDatasetLoading || pipelinesData.isPipelinesLoading);\n\nconst groupExperimentsByProj = (experiments) => {\n    const projects = [];\n    const groupedExperiments = experiments.reduce((result, experiment) => {\n        result[experiment.project] = (result[experiment.project] || []).concat(experiment);\n        return result;\n    }, []);\n\n    Object.keys(groupedExperiments).forEach(projectName => {\n        projects.push({\n            experimentNum: groupedExperiments[projectName].length,\n            experiments: groupedExperiments[projectName],\n            name: projectName,\n            // uniquePipelineNum: countPipelines(projectName),\n            signalNum: (function() {\n                switch (projectName) {\n                    case 'SMAP': return 55;\n                    case 'MSL': return 27;\n                    default: // For SES\n                        return 71;\n                }\n            }()),\n        });\n    });\n\n    // return projects;\n    return experiments.reduce((accumulator, experiment) => {\n        accumulator.push({});\n        return accumulator;\n    }, []);\n};\n\n\nexport const getProjectsList = createSelector(\n    [getExperimentsData], (experimentsData) => groupExperimentsByProj(experimentsData.experimentsList),\n);\n\nexport const getFilteredExperiments = createSelector(\n    [getSelectedProjectName, getExperimentsData, getSelectedPipeline],\n    (selectedProjectName, experimentsData, selectedPipeline) => experimentsData.experimentsList.filter(experiment => {\n        const isFromCurrentProject = experiment.project === selectedProjectName;\n        const isPipelineMatch = (!selectedPipeline || experiment.pipeline === selectedPipeline);\n        return isFromCurrentProject && isPipelineMatch;\n    }),\n);\n"]},"metadata":{},"sourceType":"module"}