{"ast":null,"code":"import _defineProperty from \"/home/sergiu/Projects/mtv-react/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { createSelector } from 'reselect';\nexport const getExperimentsData = state => state.experiments;\nexport const getPipelinesData = state => state.pipelines;\nexport const getDatasets = state => state.datasets;\n\nconst addPipelines = (projectStack, pipelines) => projectStack.map(project => _objectSpread({}, project, {\n  pipelines\n}));\n\nconst getSelectedPipeline = state => state.pipelines.pipelineName;\n\nconst isProjectsLoading = createSelector([getExperimentsData, getPipelinesData, getDatasets], (experimentsData, pipelinesData, datasets) => experimentsData.ieExperimentsLoading || datasets.isDatasetLoading || pipelinesData.isPipelinesLoading);\nexport const choosedPipeline = createSelector([getPipelinesData, getSelectedPipeline], (pipelinesData, pipeLineSelected) => {\n  if (pipelinesData.isPipelinesLoading) {\n    return null;\n  }\n\n  const selected = pipeLineSelected !== null ? pipelinesData.pipelineList.filter(pipeline => pipeline.name === pipeLineSelected) : pipelinesData.pipelineList[0];\n  return selected.name;\n});\n\nconst groupExperimentsByProj = (stack, criteria) => {\n  const grouppedProjects = [];\n  const grouppedStack = stack.reduce((result, currentValue) => {\n    (result[currentValue[criteria]] = result[currentValue[criteria]] || []).push(currentValue);\n    return result;\n  }, []);\n  Object.keys(grouppedStack).forEach(expGroup => {\n    grouppedProjects.push({\n      experimentNum: grouppedStack[expGroup].length,\n      experiments: grouppedStack[expGroup],\n      name: expGroup,\n      // uniquePipelineNum: countPipelines(expGroup),\n      signalNum: function () {\n        switch (expGroup) {\n          case 'SMAP':\n            return 55;\n\n          case 'MSL':\n            return 27;\n\n          default:\n            // For SES\n            return 71;\n        }\n      }()\n    });\n  });\n  return grouppedProjects;\n};\n\nexport const getFilteredExperiments = createSelector([getExperimentsData, choosedPipeline], (experimentsData, selectedPipeline) => {\n  const isExperimentsLoading = experimentsData.isExperimentsLoading;\n  const experimentsList = experimentsData.experimentsList.filter(experiment => !selectedPipeline || experiment.pipeline === selectedPipeline);\n  return {\n    experimentsList,\n    isExperimentsLoading\n  };\n});\nconst getProjectsList = createSelector([isProjectsLoading, getExperimentsData, getDatasets, getPipelinesData], (isLoadingProjects, experimentsData, dataSets, pipelinesData) => {\n  if (isLoadingProjects) {\n    return [];\n  }\n\n  let projectData = {};\n  const grouppedExpByProject = groupExperimentsByProj(experimentsData.experimentsList, 'project');\n  const projects = addPipelines(grouppedExpByProject, pipelinesData.pipelineList);\n  projectData = {\n    isProjectsLoading: isLoadingProjects,\n    projects\n  };\n  return projectData;\n});\nexport const getProjectsData = createSelector([isProjectsLoading, getProjectsList], (isLoadingProjects, projectsList) => {\n  let projectData = {\n    isProjectsLoading: isLoadingProjects,\n    projectsList\n  };\n  return projectData;\n});","map":{"version":3,"sources":["/home/sergiu/Projects/mtv-react/src/model/selectors/projects.js"],"names":["createSelector","getExperimentsData","state","experiments","getPipelinesData","pipelines","getDatasets","datasets","addPipelines","projectStack","map","project","getSelectedPipeline","pipelineName","isProjectsLoading","experimentsData","pipelinesData","ieExperimentsLoading","isDatasetLoading","isPipelinesLoading","choosedPipeline","pipeLineSelected","selected","pipelineList","filter","pipeline","name","groupExperimentsByProj","stack","criteria","grouppedProjects","grouppedStack","reduce","result","currentValue","push","Object","keys","forEach","expGroup","experimentNum","length","signalNum","getFilteredExperiments","selectedPipeline","isExperimentsLoading","experimentsList","experiment","getProjectsList","isLoadingProjects","dataSets","projectData","grouppedExpByProject","projects","getProjectsData","projectsList"],"mappings":"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","sourcesContent":["import { createSelector } from 'reselect';\n\nexport const getExperimentsData = (state) => state.experiments;\nexport const getPipelinesData = (state) => state.pipelines;\nexport const getDatasets = (state) => state.datasets;\n\nconst addPipelines = (projectStack, pipelines) => projectStack.map(project => ({ ...project, pipelines }));\nconst getSelectedPipeline = (state) => state.pipelines.pipelineName;\n\nconst isProjectsLoading = createSelector(\n    [getExperimentsData, getPipelinesData, getDatasets],\n    (experimentsData, pipelinesData, datasets) =>\n        experimentsData.ieExperimentsLoading || datasets.isDatasetLoading || pipelinesData.isPipelinesLoading);\n\nexport const choosedPipeline = createSelector(\n    [getPipelinesData, getSelectedPipeline],\n    (pipelinesData, pipeLineSelected) => {\n        if (pipelinesData.isPipelinesLoading) { return null; }\n        const selected = pipeLineSelected !== null ? pipelinesData.pipelineList.filter(pipeline => pipeline.name === pipeLineSelected) : pipelinesData.pipelineList[0];\n        return selected.name;\n    },\n);\n\nconst groupExperimentsByProj = (stack, criteria) => {\n    const grouppedProjects = [];\n    const grouppedStack = stack.reduce((result, currentValue) => {\n        (result[currentValue[criteria]] = result[currentValue[criteria]] || []).push(currentValue);\n        return result;\n    }, []);\n\n    Object.keys(grouppedStack).forEach(expGroup => {\n        grouppedProjects.push({\n            experimentNum: grouppedStack[expGroup].length,\n            experiments: grouppedStack[expGroup],\n            name: expGroup,\n            // uniquePipelineNum: countPipelines(expGroup),\n            signalNum: (function() {\n                switch (expGroup) {\n                    case 'SMAP': return 55;\n                    case 'MSL': return 27;\n                    default: // For SES\n                        return 71;\n                }\n            }()),\n        });\n    });\n\n    return grouppedProjects;\n};\n\nexport const getFilteredExperiments = createSelector(\n    [getExperimentsData, choosedPipeline],\n    (experimentsData, selectedPipeline) => {\n        const { isExperimentsLoading } = experimentsData;\n        const experimentsList = experimentsData.experimentsList.filter(experiment => !selectedPipeline || experiment.pipeline === selectedPipeline);\n        return { experimentsList, isExperimentsLoading };\n    });\n\n\nconst getProjectsList = createSelector(\n    [isProjectsLoading, getExperimentsData, getDatasets, getPipelinesData],\n    (isLoadingProjects, experimentsData, dataSets, pipelinesData) => {\n        if (isLoadingProjects) { return []; }\n        let projectData = {};\n        const grouppedExpByProject = groupExperimentsByProj(experimentsData.experimentsList, 'project');\n        const projects = addPipelines(grouppedExpByProject, pipelinesData.pipelineList);\n\n         projectData = {\n            isProjectsLoading: isLoadingProjects,\n            projects,\n        };\n\n        return projectData;\n    },\n);\n\nexport const getProjectsData = createSelector(\n    [isProjectsLoading, getProjectsList],\n    (isLoadingProjects, projectsList) => {\n        let projectData = {\n            isProjectsLoading: isLoadingProjects,\n            projectsList,\n        };\n        return projectData;\n    },\n);\n"]},"metadata":{},"sourceType":"module"}