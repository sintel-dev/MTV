{"ast":null,"code":"var _jsxFileName = \"/home/sergiu/Projects/mtv-react/src/components/Timeseries/Overview/DrawChart.jsx\";\nimport React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3 from 'd3';\nimport { drawChart } from './chartUtils';\n\nconst DrawChart = ({\n  dataRun,\n  onPeriodTimeChange\n}) => {\n  // const width = document.querySelector('.overview-wrapper').offsetWidth - 60;\n  const width = 1000;\n  const height = 36;\n  useEffect(() => drawChart(width, height, dataRun, onPeriodTimeChange)); // function getScale(w, h) {\n  //   let minValue = Number.MAX_SAFE_INTEGER;\n  //   let maxValue = Number.MIN_SAFE_INTEGER;\n  //   const { timeSeries } = props.dataRun;\n  //   const timeSeriesMin = timeSeries[0][0];\n  //   const timeSeriesMax = timeSeries[timeSeries.length - 1][0];\n  //   const x = d3.scaleTime().range([0, w]);\n  //   const y = d3.scaleLinear().range([h, 0]);\n  //   minValue = minValue > timeSeriesMin ? timeSeriesMin : minValue;\n  //   maxValue = maxValue < timeSeriesMax ? timeSeriesMax : maxValue;\n  //   x.domain([minValue, maxValue]);\n  //   y.domain([-1, 1]);\n  //   return { x, y };\n  // }\n  // function drawChart() {\n  //   const chartWidth = width - 10;\n  //   const { timeSeries, eventWindows } = props.dataRun;\n  //   const { x, y } = getScale(chartWidth, height);\n  //   const line = d3.line()\n  //     .x(d => x(d[0]))\n  //     .y(d => y(d[1]));\n  //   const highlightedEvents = eventWindows.map(event => timeSeries.slice(event[0], event[1] + 2));\n  //   const svg = d3.select(`._${props.dataRun.id}`)\n  //     .append('svg')\n  //     .attr('width', chartWidth)\n  //     .attr('class', 'wave-chart');\n  //   svg.append('path')\n  //     .attr('class', 'wave-data')\n  //     .attr('d', line(timeSeries))\n  //     .attr('transform', 'translate(10, 6)');\n  //   highlightedEvents.map(event =>\n  //     svg.append('path')\n  //       .attr('class', 'wave-event')\n  //       .attr('transform', 'translate(10, 6)')\n  //       .attr('d', line(event)),\n  //   );\n  //   drawBrush(svg);\n  // }\n  // function drawBrush (element) {\n  //   const brushHeight = 43;\n  //   const xRange = d3.scaleTime().range([0, width]);\n  //   const brush = d3.brushX()\n  //     .extent([[0, 0], [width, brushHeight]]);\n  //   const brushContext = element.append('g').attr('class', 'brushContext');\n  //   brushContext.append('g')\n  //     .attr('class', 'brush')\n  //     .attr('transform', 'translate(5, 3)')\n  //     .call(brush)\n  //     .call(brush.move, xRange.range());\n  //     brush.on('brush end', brushChange.bind(this));\n  //   function brushChange() {\n  //     if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'zoom') return;\n  //     props.onPeriodTimeChange(d3.event.selection);\n  //   }\n  // }\n\n  return React.createElement(\"div\", {\n    className: \"_\".concat(props.dataRun.id),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 81\n    },\n    __self: this\n  }) // @TODO - find a better way to target this element\n  ;\n};\n\nDrawChart.propTypes = {\n  dataRun: PropTypes.object,\n  onPeriodTimeChange: PropTypes.func\n};\nexport default DrawChart;","map":{"version":3,"sources":["/home/sergiu/Projects/mtv-react/src/components/Timeseries/Overview/DrawChart.jsx"],"names":["React","useEffect","PropTypes","d3","drawChart","DrawChart","dataRun","onPeriodTimeChange","width","height","props","id","propTypes","object","func"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAO,KAAKC,EAAZ,MAAoB,IAApB;AAEA,SAASC,SAAT,QAA0B,cAA1B;;AAEA,MAAMC,SAAS,GAAG,CAAC;AAAEC,EAAAA,OAAF;AAAWC,EAAAA;AAAX,CAAD,KAAqC;AACrD;AACA,QAAMC,KAAK,GAAG,IAAd;AACA,QAAMC,MAAM,GAAG,EAAf;AACER,EAAAA,SAAS,CAAC,MAAMG,SAAS,CAACI,KAAD,EAAQC,MAAR,EAAgBH,OAAhB,EAAyBC,kBAAzB,CAAhB,CAAT,CAJmD,CAMnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEE,SACE;AAAK,IAAA,SAAS,aAAMG,KAAK,CAACJ,OAAN,CAAcK,EAApB,CAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,CAC6C;AAD7C;AAGL,CA5ED;;AA8EAN,SAAS,CAACO,SAAV,GAAsB;AACpBN,EAAAA,OAAO,EAAEJ,SAAS,CAACW,MADC;AAEpBN,EAAAA,kBAAkB,EAAEL,SAAS,CAACY;AAFV,CAAtB;AAKA,eAAeT,SAAf","sourcesContent":["import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3 from 'd3';\n\nimport { drawChart } from './chartUtils';\n\nconst DrawChart = ({ dataRun, onPeriodTimeChange }) => {\n  // const width = document.querySelector('.overview-wrapper').offsetWidth - 60;\n  const width = 1000;\n  const height = 36;\n    useEffect(() => drawChart(width, height, dataRun, onPeriodTimeChange));\n\n    // function getScale(w, h) {\n    //   let minValue = Number.MAX_SAFE_INTEGER;\n    //   let maxValue = Number.MIN_SAFE_INTEGER;\n    //   const { timeSeries } = props.dataRun;\n    //   const timeSeriesMin = timeSeries[0][0];\n    //   const timeSeriesMax = timeSeries[timeSeries.length - 1][0];\n    //   const x = d3.scaleTime().range([0, w]);\n    //   const y = d3.scaleLinear().range([h, 0]);\n\n    //   minValue = minValue > timeSeriesMin ? timeSeriesMin : minValue;\n    //   maxValue = maxValue < timeSeriesMax ? timeSeriesMax : maxValue;\n    //   x.domain([minValue, maxValue]);\n    //   y.domain([-1, 1]);\n\n    //   return { x, y };\n    // }\n\n    // function drawChart() {\n    //   const chartWidth = width - 10;\n\n    //   const { timeSeries, eventWindows } = props.dataRun;\n    //   const { x, y } = getScale(chartWidth, height);\n    //   const line = d3.line()\n    //     .x(d => x(d[0]))\n    //     .y(d => y(d[1]));\n\n    //   const highlightedEvents = eventWindows.map(event => timeSeries.slice(event[0], event[1] + 2));\n    //   const svg = d3.select(`._${props.dataRun.id}`)\n    //     .append('svg')\n    //     .attr('width', chartWidth)\n    //     .attr('class', 'wave-chart');\n\n    //   svg.append('path')\n    //     .attr('class', 'wave-data')\n    //     .attr('d', line(timeSeries))\n    //     .attr('transform', 'translate(10, 6)');\n\n    //   highlightedEvents.map(event =>\n    //     svg.append('path')\n    //       .attr('class', 'wave-event')\n    //       .attr('transform', 'translate(10, 6)')\n    //       .attr('d', line(event)),\n    //   );\n    //   drawBrush(svg);\n    // }\n\n    // function drawBrush (element) {\n    //   const brushHeight = 43;\n    //   const xRange = d3.scaleTime().range([0, width]);\n    //   const brush = d3.brushX()\n    //     .extent([[0, 0], [width, brushHeight]]);\n    //   const brushContext = element.append('g').attr('class', 'brushContext');\n\n    //   brushContext.append('g')\n    //     .attr('class', 'brush')\n    //     .attr('transform', 'translate(5, 3)')\n    //     .call(brush)\n    //     .call(brush.move, xRange.range());\n\n    //     brush.on('brush end', brushChange.bind(this));\n\n    //   function brushChange() {\n    //     if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'zoom') return;\n    //     props.onPeriodTimeChange(d3.event.selection);\n    //   }\n    // }\n\n      return (\n        <div className={`_${props.dataRun.id}`} /> // @TODO - find a better way to target this element\n      );\n};\n\nDrawChart.propTypes = {\n  dataRun: PropTypes.object,\n  onPeriodTimeChange: PropTypes.func,\n};\n\nexport default DrawChart;\n"]},"metadata":{},"sourceType":"module"}