{"ast":null,"code":"import _defineProperty from \"/home/sergiu/Projects/mtv-react/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { createSelector } from 'reselect';\nexport const getExperimentsData = state => state.experiments;\nexport const getPipelinesData = state => state.pipelines;\nexport const getDatasets = state => state.datasets;\nexport const getSelectedPipeline = state => state.pipelines.pipelineName;\nexport const getSelectedProjectName = state => state.projects.selectedProject;\nexport const getIsExperimentsLoading = state => state.experiments.isExperimentsLoading;\n\nconst addPipelines = (projectStack, pipelines) => projectStack.map(project => _objectSpread({}, project, {\n  pipelines\n}));\n\nexport const getIsProjectsLoading = createSelector([getExperimentsData, getPipelinesData, getDatasets], (experimentsData, pipelinesData, datasets) => experimentsData.ieExperimentsLoading || datasets.isDatasetLoading || pipelinesData.isPipelinesLoading);\n\nconst groupExperimentsByProj = (experiments, criteria) => {\n  const projects = [];\n  const grouppedStack = experiments.reduce((result, currentValue) => {\n    (result[currentValue[criteria]] = result[currentValue[criteria]] || []).push(currentValue);\n    return result;\n  }, []);\n  Object.keys(grouppedStack).forEach(expGroup => {\n    projects.push({\n      experimentNum: grouppedStack[expGroup].length,\n      experiments: grouppedStack[expGroup],\n      name: expGroup,\n      // uniquePipelineNum: countPipelines(expGroup),\n      signalNum: function () {\n        switch (expGroup) {\n          case 'SMAP':\n            return 55;\n\n          case 'MSL':\n            return 27;\n\n          default:\n            // For SES\n            return 71;\n        }\n      }()\n    });\n  });\n  return projects;\n};\n\nexport const getProjectsList = createSelector([getExperimentsData], experimentsData => groupExperimentsByProj(experimentsData.experimentsList, 'project'));\nexport const getFilteredExperiments = createSelector([getSelectedProjectName, getExperimentsData, getSelectedPipeline], (selectedProjectName, experimentsData, selectedPipeline) => experimentsData.experimentsList.filter(experiment => {\n  const isFromCurrentProject = experiment.project === selectedProjectName;\n  const isPipelineMatch = !selectedPipeline || experiment.pipeline === selectedPipeline;\n  return isFromCurrentProject && isPipelineMatch;\n}));","map":{"version":3,"sources":["/home/sergiu/Projects/mtv-react/src/model/selectors/projects.js"],"names":["createSelector","getExperimentsData","state","experiments","getPipelinesData","pipelines","getDatasets","datasets","getSelectedPipeline","pipelineName","getSelectedProjectName","projects","selectedProject","getIsExperimentsLoading","isExperimentsLoading","addPipelines","projectStack","map","project","getIsProjectsLoading","experimentsData","pipelinesData","ieExperimentsLoading","isDatasetLoading","isPipelinesLoading","groupExperimentsByProj","criteria","grouppedStack","reduce","result","currentValue","push","Object","keys","forEach","expGroup","experimentNum","length","name","signalNum","getProjectsList","experimentsList","getFilteredExperiments","selectedProjectName","selectedPipeline","filter","experiment","isFromCurrentProject","isPipelineMatch","pipeline"],"mappings":"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","sourcesContent":["import { createSelector } from 'reselect';\n\nexport const getExperimentsData = (state) => state.experiments;\nexport const getPipelinesData = (state) => state.pipelines;\nexport const getDatasets = (state) => state.datasets;\nexport const getSelectedPipeline = (state) => state.pipelines.pipelineName;\nexport const getSelectedProjectName = (state) => state.projects.selectedProject;\nexport const getIsExperimentsLoading = state => state.experiments.isExperimentsLoading;\n\nconst addPipelines = (projectStack, pipelines) => projectStack.map(project => ({ ...project, pipelines }));\n\nexport const getIsProjectsLoading = createSelector(\n    [getExperimentsData, getPipelinesData, getDatasets],\n    (experimentsData, pipelinesData, datasets) =>\n        experimentsData.ieExperimentsLoading || datasets.isDatasetLoading || pipelinesData.isPipelinesLoading);\n\nconst groupExperimentsByProj = (experiments, criteria) => {\n    const projects = [];\n    const grouppedStack = experiments.reduce((result, currentValue) => {\n        (result[currentValue[criteria]] = result[currentValue[criteria]] || []).push(currentValue);\n        return result;\n    }, []);\n\n    Object.keys(grouppedStack).forEach(expGroup => {\n        projects.push({\n            experimentNum: grouppedStack[expGroup].length,\n            experiments: grouppedStack[expGroup],\n            name: expGroup,\n            // uniquePipelineNum: countPipelines(expGroup),\n            signalNum: (function() {\n                switch (expGroup) {\n                    case 'SMAP': return 55;\n                    case 'MSL': return 27;\n                    default: // For SES\n                        return 71;\n                }\n            }()),\n        });\n    });\n\n    return projects;\n};\n\n\nexport const getProjectsList = createSelector(\n    [getExperimentsData],\n    (experimentsData) => groupExperimentsByProj(experimentsData.experimentsList, 'project'),\n);\n\n\nexport const getFilteredExperiments = createSelector(\n    [getSelectedProjectName, getExperimentsData, getSelectedPipeline],\n    (selectedProjectName, experimentsData, selectedPipeline) => experimentsData.experimentsList.filter(experiment => {\n        const isFromCurrentProject = experiment.project === selectedProjectName;\n        const isPipelineMatch = (!selectedPipeline || experiment.pipeline === selectedPipeline);\n        return isFromCurrentProject && isPipelineMatch;\n    }),\n);\n"]},"metadata":{},"sourceType":"module"}