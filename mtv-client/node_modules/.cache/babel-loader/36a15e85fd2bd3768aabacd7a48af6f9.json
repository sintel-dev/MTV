{"ast":null,"code":"import _defineProperty from \"/home/sergiu/Projects/mtv-react/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { createSelector } from 'reselect';\nexport const getSelectedExperimentData = state => state.experimentData;\n\nconst groupDataBy = (datarun, option) => datarun.data.map(value => [Math.trunc(value[0]) * 1000, value[datarun.names.indexOf(option)]]);\n\nconst groupByEventWindows = (data, timestamps) => data.map(event => [timestamps.indexOf(Math.trunc(event.start_time) * 1000), timestamps.indexOf(Math.trunc(event.stop_time) * 1000), event.score, event.tag]);\n\nexport const getProcessedDataRun = createSelector([getSelectedExperimentData], experimentData => {\n  if (experimentData.isExperimentDataLoading) {\n    return [];\n  }\n\n  return experimentData.data.dataruns.map(datarun => {\n    const timeSeries = groupDataBy(datarun.prediction, 'y_raw');\n    const timeseriesPred = groupDataBy(datarun.prediction, 'y_raw_hat');\n    const timeseriesErr = groupDataBy(datarun.prediction, 'es_raw');\n    const eventWindows = groupByEventWindows(datarun.events, timeSeries.map(series => series[0]));\n    return _objectSpread({}, datarun, {\n      timeSeries,\n      timeseriesPred,\n      timeseriesErr,\n      eventWindows\n    });\n  });\n});","map":{"version":3,"sources":["/home/sergiu/Projects/mtv-react/src/model/selectors/experiment.js"],"names":["createSelector","getSelectedExperimentData","state","experimentData","groupDataBy","datarun","option","data","map","value","Math","trunc","names","indexOf","groupByEventWindows","timestamps","event","start_time","stop_time","score","tag","getProcessedDataRun","isExperimentDataLoading","dataruns","timeSeries","prediction","timeseriesPred","timeseriesErr","eventWindows","events","series"],"mappings":";;;;;;AAAA,SAASA,cAAT,QAA+B,UAA/B;AAEA,OAAO,MAAMC,yBAAyB,GAAIC,KAAD,IAAWA,KAAK,CAACC,cAAnD;;AAEP,MAAMC,WAAW,GAAG,CAACC,OAAD,EAAUC,MAAV,KAAqBD,OAAO,CAACE,IAAR,CAAaC,GAAb,CAAiBC,KAAK,IAAI,CAC3DC,IAAI,CAACC,KAAL,CAAWF,KAAK,CAAC,CAAD,CAAhB,IAAuB,IADoC,EAE3DA,KAAK,CAACJ,OAAO,CAACO,KAAR,CAAcC,OAAd,CAAsBP,MAAtB,CAAD,CAFsD,CAA1B,CAAzC;;AAKA,MAAMQ,mBAAmB,GAAG,CAACP,IAAD,EAAOQ,UAAP,KACvBR,IAAI,CAACC,GAAL,CAASQ,KAAK,IAAI,CACfD,UAAU,CAACF,OAAX,CAAmBH,IAAI,CAACC,KAAL,CAAWK,KAAK,CAACC,UAAjB,IAA+B,IAAlD,CADe,EAEfF,UAAU,CAACF,OAAX,CAAmBH,IAAI,CAACC,KAAL,CAAWK,KAAK,CAACE,SAAjB,IAA8B,IAAjD,CAFe,EAGfF,KAAK,CAACG,KAHS,EAIfH,KAAK,CAACI,GAJS,CAAlB,CADL;;AAQA,OAAO,MAAMC,mBAAmB,GAAGrB,cAAc,CAC7C,CAACC,yBAAD,CAD6C,EAE5CE,cAAD,IAAoB;AAChB,MAAIA,cAAc,CAACmB,uBAAnB,EAA4C;AAAE,WAAO,EAAP;AAAY;;AAC1D,SAAOnB,cAAc,CAACI,IAAf,CAAoBgB,QAApB,CAA6Bf,GAA7B,CAAiCH,OAAO,IAAI;AAC/C,UAAMmB,UAAU,GAAGpB,WAAW,CAACC,OAAO,CAACoB,UAAT,EAAqB,OAArB,CAA9B;AACA,UAAMC,cAAc,GAAGtB,WAAW,CAACC,OAAO,CAACoB,UAAT,EAAqB,WAArB,CAAlC;AACA,UAAME,aAAa,GAAGvB,WAAW,CAACC,OAAO,CAACoB,UAAT,EAAqB,QAArB,CAAjC;AACA,UAAMG,YAAY,GAAGd,mBAAmB,CAACT,OAAO,CAACwB,MAAT,EAAiBL,UAAU,CAAChB,GAAX,CAAesB,MAAM,IAAIA,MAAM,CAAC,CAAD,CAA/B,CAAjB,CAAxC;AACA,6BACOzB,OADP;AAEImB,MAAAA,UAFJ;AAGIE,MAAAA,cAHJ;AAIIC,MAAAA,aAJJ;AAKIC,MAAAA;AALJ;AAOH,GAZM,CAAP;AAaH,CAjB4C,CAA1C","sourcesContent":["import { createSelector } from 'reselect';\n\nexport const getSelectedExperimentData = (state) => state.experimentData;\n\nconst groupDataBy = (datarun, option) => datarun.data.map(value => [\n        Math.trunc(value[0]) * 1000,\n        value[datarun.names.indexOf(option)],\n    ]);\n\nconst groupByEventWindows = (data, timestamps) =>\n     data.map(event => [\n        timestamps.indexOf(Math.trunc(event.start_time) * 1000),\n        timestamps.indexOf(Math.trunc(event.stop_time) * 1000),\n        event.score,\n        event.tag,\n    ]);\n\nexport const getProcessedDataRun = createSelector(\n    [getSelectedExperimentData],\n    (experimentData) => {\n        if (experimentData.isExperimentDataLoading) { return []; }\n        return experimentData.data.dataruns.map(datarun => {\n            const timeSeries = groupDataBy(datarun.prediction, 'y_raw');\n            const timeseriesPred = groupDataBy(datarun.prediction, 'y_raw_hat');\n            const timeseriesErr = groupDataBy(datarun.prediction, 'es_raw');\n            const eventWindows = groupByEventWindows(datarun.events, timeSeries.map(series => series[0]));\n            return {\n                ...datarun,\n                timeSeries,\n                timeseriesPred,\n                timeseriesErr,\n                eventWindows,\n            };\n        });\n    },\n);\n"]},"metadata":{},"sourceType":"module"}