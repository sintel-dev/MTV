{"ast":null,"code":"import * as d3 from 'd3';\nlet brush = null;\nlet brushContext = null;\n\nfunction getScale(width, height, dataRun) {\n  let minValue = Number.MAX_SAFE_INTEGER;\n  let maxValue = Number.MIN_SAFE_INTEGER;\n  const timeSeries = dataRun.timeSeries;\n  const timeSeriesMin = timeSeries[0][0];\n  const timeSeriesMax = timeSeries[timeSeries.length - 1][0];\n  const x = d3.scaleTime().range([0, width]);\n  const y = d3.scaleLinear().range([height, 0]);\n  minValue = minValue > timeSeriesMin ? timeSeriesMin : minValue;\n  maxValue = maxValue < timeSeriesMax ? timeSeriesMax : maxValue;\n  x.domain([minValue, maxValue]);\n  y.domain([-1, 1]);\n  return {\n    x,\n    y\n  };\n}\n\nexport function drawBrush(element, width, onPeriodTimeChange) {\n  width -= 25;\n  const brushHeight = 43;\n  const xRange = d3.scaleTime().range([0, width]);\n  brush = d3.brushX().extent([[0, 0], [width, brushHeight]]);\n  brushContext = element.append('g').attr('class', 'brushContext');\n  brushContext.append('g').attr('class', 'brush').attr('transform', 'translate(5, 3)').call(brush).call(brush.move, xRange.range());\n  brush.on('brush start', () => {\n    // onPeriodTimeChange(d3.event.selection);\n    // console.log(this);\n    // updateBrushPeriod();\n    debugger;\n    if (!d3.event.sourceEvent || !d3.event.selection) return;\n    let currentBrush = d3.select(this);\n\n    if (currentBrush.attr('simulate')) {\n      return;\n    }\n\n    let selection = d3.selectAll('.brush:not([active])');\n    currentBrush.attr('active', true);\n    selection.attr('simulate', true);\n    selection.call(brush.move, d3.event.selection).on('end', function () {\n      selection.attr('simulate', null);\n      currentBrush.attr('active', null);\n    }());\n    currentBrush.attr('active', null);\n    selection.attr('simulate', null);\n  });\n}\nexport function updateBrushPeriod() {\n  if (!d3.event.sourceEvent || !d3.event.selection) return;\n  let currentBrush = d3.select(this);\n  debugger;\n\n  if (currentBrush.attr('simulate')) {\n    return;\n  }\n\n  console.log(currentBrush);\n  let selection = d3.selectAll('.brush:not([active])');\n  currentBrush.attr('active', true);\n  selection.attr('simulate', true);\n  selection.call(brush.move, d3.event.selection).on('end', function () {\n    selection.attr('simulate', null);\n    currentBrush.attr('active', null);\n  }());\n  currentBrush.attr('active', null);\n  selection.attr('simulate', null);\n}\nexport function updateBrushPeriodsss() {\n  const eventRange = d3.event.selection;\n  if (!d3.event.sourceEvent || !eventRange) return;\n  brush.on('brush end', null);\n  const existingBrushes = d3.selectAll('.brush'); // existingBrushes.call(d3.brushX().extent([[0, 0], eventRange]));\n  // d3.select(this).transition().call(brush.move, eventRange);\n\n  existingBrushes.call(brush.move, null);\n  existingBrushes // .transition()\n  .call(brush.move, eventRange).on('end', null);\n}\nexport function drawChart(width, height, dataRun, onPeriodTimeChange) {\n  const chartWidth = width - 35;\n  const timeSeries = dataRun.timeSeries,\n        eventWindows = dataRun.eventWindows;\n\n  const _getScale = getScale(chartWidth, height, dataRun),\n        x = _getScale.x,\n        y = _getScale.y;\n\n  const line = d3.line().x(d => x(d[0])).y(d => y(d[1]));\n  const highlightedEvents = eventWindows.map(event => timeSeries.slice(event[0], event[1] + 2));\n  const svg = d3.select(\"._\".concat(dataRun.id)).append('svg').attr('width', chartWidth).attr('class', 'wave-chart');\n  svg.append('path').attr('class', 'wave-data').attr('d', line(timeSeries)).attr('transform', 'translate(10, 6)');\n  highlightedEvents.map(event => svg.append('path').attr('class', 'wave-event').attr('transform', 'translate(10, 6)').attr('d', line(event)));\n  drawBrush(svg, width, onPeriodTimeChange);\n}","map":{"version":3,"sources":["/home/sergiu/Projects/mtv-react/src/components/Timeseries/Overview/chartUtils.js"],"names":["d3","brush","brushContext","getScale","width","height","dataRun","minValue","Number","MAX_SAFE_INTEGER","maxValue","MIN_SAFE_INTEGER","timeSeries","timeSeriesMin","timeSeriesMax","length","x","scaleTime","range","y","scaleLinear","domain","drawBrush","element","onPeriodTimeChange","brushHeight","xRange","brushX","extent","append","attr","call","move","on","event","sourceEvent","selection","currentBrush","select","selectAll","updateBrushPeriod","console","log","updateBrushPeriodsss","eventRange","existingBrushes","drawChart","chartWidth","eventWindows","line","d","highlightedEvents","map","slice","svg","id"],"mappings":"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","sourcesContent":["import * as d3 from 'd3';\n\nlet brush = null;\nlet brushContext = null;\nfunction getScale(width, height, dataRun) {\n  let minValue = Number.MAX_SAFE_INTEGER;\n  let maxValue = Number.MIN_SAFE_INTEGER;\n  const { timeSeries } = dataRun;\n  const timeSeriesMin = timeSeries[0][0];\n  const timeSeriesMax = timeSeries[timeSeries.length - 1][0];\n  const x = d3.scaleTime().range([0, width]);\n  const y = d3.scaleLinear().range([height, 0]);\n\n  minValue = minValue > timeSeriesMin ? timeSeriesMin : minValue;\n  maxValue = maxValue < timeSeriesMax ? timeSeriesMax : maxValue;\n  x.domain([minValue, maxValue]);\n  y.domain([-1, 1]);\n\n  return { x, y };\n}\n\nexport function drawBrush(element, width, onPeriodTimeChange) {\n  width -= 25;\n  const brushHeight = 43;\n  const xRange = d3.scaleTime().range([0, width]);\n\n  brush = d3.brushX().extent([\n    [0, 0],\n    [width, brushHeight],\n  ]);\n  brushContext = element.append('g').attr('class', 'brushContext');\n\n  brushContext\n    .append('g')\n    .attr('class', 'brush')\n    .attr('transform', 'translate(5, 3)')\n    .call(brush)\n    .call(brush.move, xRange.range());\n\n  brush.on('brush start', () => {\n    // onPeriodTimeChange(d3.event.selection);\n    // console.log(this);\n    // updateBrushPeriod();\n\n    debugger;\n    if (!d3.event.sourceEvent || !d3.event.selection) return;\n    let currentBrush = d3.select(this);\n\n    if (currentBrush.attr('simulate')) {\n      return;\n    }\n\n    let selection = d3.selectAll('.brush:not([active])');\n    currentBrush.attr('active', true);\n    selection.attr('simulate', true);\n\n    selection.call(brush.move, d3.event.selection).on(\n      'end',\n      (function() {\n        selection.attr('simulate', null);\n        currentBrush.attr('active', null);\n      }()),\n    );\n\n    currentBrush.attr('active', null);\n    selection.attr('simulate', null);\n  });\n}\n\nexport function updateBrushPeriod() {\n  if (!d3.event.sourceEvent || !d3.event.selection) return;\n  let currentBrush = d3.select(this);\n  debugger;\n\n  if (currentBrush.attr('simulate')) {\n    return;\n  }\n\n  console.log(currentBrush);\n\n  let selection = d3.selectAll('.brush:not([active])');\n  currentBrush.attr('active', true);\n  selection.attr('simulate', true);\n\n  selection.call(brush.move, d3.event.selection).on(\n    'end',\n    (function() {\n      selection.attr('simulate', null);\n      currentBrush.attr('active', null);\n    }()),\n  );\n\n  currentBrush.attr('active', null);\n  selection.attr('simulate', null);\n}\n\nexport function updateBrushPeriodsss() {\n  const eventRange = d3.event.selection;\n  if (!d3.event.sourceEvent || !eventRange) return;\n  brush.on('brush end', null);\n  const existingBrushes = d3.selectAll('.brush');\n\n  // existingBrushes.call(d3.brushX().extent([[0, 0], eventRange]));\n\n  // d3.select(this).transition().call(brush.move, eventRange);\n\n  existingBrushes.call(brush.move, null);\n  existingBrushes\n    // .transition()\n    .call(brush.move, eventRange)\n    .on('end', null);\n}\n\nexport function drawChart(width, height, dataRun, onPeriodTimeChange) {\n  const chartWidth = width - 35;\n  const { timeSeries, eventWindows } = dataRun;\n  const { x, y } = getScale(chartWidth, height, dataRun);\n  const line = d3\n    .line()\n    .x(d => x(d[0]))\n    .y(d => y(d[1]));\n\n  const highlightedEvents = eventWindows.map(event => timeSeries.slice(event[0], event[1] + 2));\n  const svg = d3\n    .select(`._${dataRun.id}`)\n    .append('svg')\n    .attr('width', chartWidth)\n    .attr('class', 'wave-chart');\n\n  svg\n    .append('path')\n    .attr('class', 'wave-data')\n    .attr('d', line(timeSeries))\n    .attr('transform', 'translate(10, 6)');\n\n  highlightedEvents.map(event =>\n    svg\n      .append('path')\n      .attr('class', 'wave-event')\n      .attr('transform', 'translate(10, 6)')\n      .attr('d', line(event)),\n  );\n\n  drawBrush(svg, width, onPeriodTimeChange);\n}\n"]},"metadata":{},"sourceType":"module"}