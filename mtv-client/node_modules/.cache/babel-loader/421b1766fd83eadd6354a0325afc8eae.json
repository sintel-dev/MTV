{"ast":null,"code":"import { createSelector } from 'reselect';\nexport const getSelectedExperimentData = state => state.experimentData;\n\nconst groupDataBy = (datarun, option) => {\n  const indexValue = datarun.names.indexOf(option);\n  return datarun.data.map(value => [Math.trunc(value[0]) * 1000, value[indexValue]]);\n};\n\nexport const getProcessedData = createSelector([getSelectedExperimentData], experimentData => {\n  if (experimentData.isExperimentDataLoading) {\n    return [];\n  }\n\n  const result = [];\n  return experimentData.data.dataruns.map(datarun => {\n    const timeSeries = groupDataBy(datarun.prediction, 'y_raw');\n    let timeseriesPred = groupDataBy(datarun.prediction, 'y_raw_hat');\n    let timeseriesErr = groupDataBy(datarun.prediction, 'es_raw');\n    result.push(...datarun, timeSeries, timeseriesPred, timeseriesErr);\n    debugger;\n    return result; // return ([\n    //     ...datarun,\n    //     timeSeries,\n    //     timeseriesPred,\n    //     timeseriesErr,\n    // ]);\n  });\n});","map":{"version":3,"sources":["/home/sergiu/Projects/mtv-react/src/model/selectors/experiment.js"],"names":["createSelector","getSelectedExperimentData","state","experimentData","groupDataBy","datarun","option","indexValue","names","indexOf","data","map","value","Math","trunc","getProcessedData","isExperimentDataLoading","result","dataruns","timeSeries","prediction","timeseriesPred","timeseriesErr","push"],"mappings":"AAAA,SAASA,cAAT,QAA+B,UAA/B;AAEA,OAAO,MAAMC,yBAAyB,GAAIC,KAAD,IAAWA,KAAK,CAACC,cAAnD;;AAEP,MAAMC,WAAW,GAAG,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrC,QAAMC,UAAU,GAAGF,OAAO,CAACG,KAAR,CAAcC,OAAd,CAAsBH,MAAtB,CAAnB;AACA,SAAOD,OAAO,CAACK,IAAR,CAAaC,GAAb,CAAiBC,KAAK,IAAI,CAC7BC,IAAI,CAACC,KAAL,CAAWF,KAAK,CAAC,CAAD,CAAhB,IAAuB,IADM,EAE7BA,KAAK,CAACL,UAAD,CAFwB,CAA1B,CAAP;AAIH,CAND;;AASA,OAAO,MAAMQ,gBAAgB,GAAGf,cAAc,CAC1C,CAACC,yBAAD,CAD0C,EAEzCE,cAAD,IAAoB;AAChB,MAAIA,cAAc,CAACa,uBAAnB,EAA4C;AAAE,WAAO,EAAP;AAAY;;AAC1D,QAAMC,MAAM,GAAG,EAAf;AACA,SAAOd,cAAc,CAACO,IAAf,CAAoBQ,QAApB,CAA6BP,GAA7B,CAAiCN,OAAO,IAAI;AAC/C,UAAMc,UAAU,GAAGf,WAAW,CAACC,OAAO,CAACe,UAAT,EAAqB,OAArB,CAA9B;AACA,QAAIC,cAAc,GAAGjB,WAAW,CAACC,OAAO,CAACe,UAAT,EAAqB,WAArB,CAAhC;AACA,QAAIE,aAAa,GAAGlB,WAAW,CAACC,OAAO,CAACe,UAAT,EAAqB,QAArB,CAA/B;AACAH,IAAAA,MAAM,CAACM,IAAP,CACI,GAAGlB,OADP,EAEIc,UAFJ,EAGIE,cAHJ,EAIIC,aAJJ;AAMA;AACA,WAAOL,MAAP,CAX+C,CAY/C;AACA;AACA;AACA;AACA;AACA;AACH,GAlBM,CAAP;AAmBH,CAxByC,CAAvC","sourcesContent":["import { createSelector } from 'reselect';\n\nexport const getSelectedExperimentData = (state) => state.experimentData;\n\nconst groupDataBy = (datarun, option) => {\n    const indexValue = datarun.names.indexOf(option);\n    return datarun.data.map(value => [\n        Math.trunc(value[0]) * 1000,\n        value[indexValue],\n    ]);\n};\n\n\nexport const getProcessedData = createSelector(\n    [getSelectedExperimentData],\n    (experimentData) => {\n        if (experimentData.isExperimentDataLoading) { return []; }\n        const result = [];\n        return experimentData.data.dataruns.map(datarun => {\n            const timeSeries = groupDataBy(datarun.prediction, 'y_raw');\n            let timeseriesPred = groupDataBy(datarun.prediction, 'y_raw_hat');\n            let timeseriesErr = groupDataBy(datarun.prediction, 'es_raw');\n            result.push(\n                ...datarun,\n                timeSeries,\n                timeseriesPred,\n                timeseriesErr,\n            );\n            debugger;\n            return result;\n            // return ([\n            //     ...datarun,\n            //     timeSeries,\n            //     timeseriesPred,\n            //     timeseriesErr,\n            // ]);\n        });\n    },\n);\n"]},"metadata":{},"sourceType":"module"}